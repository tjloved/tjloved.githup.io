<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" href="stylesheets/github-dark.css">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>我的博客</title>
  <meta name="description" content="">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">我的博客</h1>
    </header>
    <div id="container">
      <p class="tagline"></p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/tjloved/tjloved.githup.io/tarball/master" class="download-button tar"><span>Download</span></a>
          <a href="https://github.com/tjloved/tjloved.githup.io/zipball/master" class="download-button zip"><span>Download</span></a>
          <a href="https://github.com/tjloved/tjloved.githup.io" class="code">View 我的博客 on GitHub</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
          <p>欢迎来到我的博客
LINUX系统操作（上）
目录
一、简介： 2
1、什么是linux  2
2、发展史：    2
二、安装    2
1、创建一个虚拟机系统（攒机，创建一台裸机）    2
2、设置启动盘（引导顺序）   5
3、启动电脑，开始安装 7
三、根目录讲解   16
四、shell的操作， 18
1、什么是shell  18
2、Linux命令组成部分 18
3、常用的命令集。   19
（1）ls   19
（2）pwd  20
（2）cd切换目录   20
（3）clear 清屏命令   20
（4）字符界面与图形界面的切换 20
（5）系统时钟命令：    20
（6）系统关机重启命令。  21
五、 vi编辑器操作    22
1、什么是vi编辑器    22
2、vi的三种操作模式 22
3、使用vi    23
4、基本操作    23
（1）命令行模式下操作 23
（2）编辑模式下使用    24</p>

<p>一、简介：
1、什么是linux
是一个软件，是一个操作系统软件，是一个性能稳定的多用户网络操作系统。很多服务架构在linux服务器上，比如典型的LAMP LNMP 架构.
特点：
免费、开源
支持多线程，多用户
安全性好
对内存和文件管理优越。
2、发展史：
目标：了解unix与linux的关系，linux的内核与各发行版本。
（1）unix
（2）linux
（3）linux的主要产品</p>

<p>二、安装
安装方式：使用一个虚拟机软件，来安装linux系统，通过虚拟机软件来虚拟出一台电脑。
虚拟机软件：VMare workstation和 virturalbox
安装步骤非常简单：单击下一步即可。
1、创建一个虚拟机系统（攒机，创建一台裸机）
（1）单击新建开始创建</p>

<p>（2）指定一个虚拟电脑的名称，和安装的系统类型</p>

<p>（3）给虚拟机指定内容大小，最小是256MB，</p>

<p>（4）设置虚拟硬盘大小设置方式</p>

<p>动态设置：给虚拟机硬盘动态的分配空间
固定设置：一次性把虚拟机硬盘需要的空间，给划分出来。
（5）设置虚拟机硬盘的大小，以及虚拟机系统的存储位置。</p>

<p>（6）单击create创建完成，</p>

<p>2、设置启动盘（引导顺序）
计算机在启动时，设置的引导顺序，
在安装系统时，设置光盘（u 盘）引导，在安装完成系统后，设置硬盘引导。</p>

<p>把光盘塞进光驱里面，（让虚拟机系统加载系统的安装镜像）</p>

<p>3、启动电脑，开始安装</p>

<p>安装步骤：
（1）选择第一个，开始安装</p>

<p>（2）检测硬键是否有错误，可以使用tab键切换到”skip”进行略过。</p>

<p>（3）选择安装界面的提示文字，自然选择谁（中文简体）</p>

<p>（4）选择键盘，使用“美国英语式”</p>

<p>（5）重新初始化所有。</p>

<p>（6）给超级管理员（root）用户创建一个秘密</p>

<p>（7）选择自定义分区：</p>

<p>分区的讲解：
分区的目的，便于存储数据，
window里面的分区，采用cdef…作为盘符。</p>

<p>window里面的文件系统：比如要读取c盘里面的nihao.txt文件。读取方式：c:/nihao.txt</p>

<p>linux的分区：
在linux里面至少需要两个分区：一个是根分区（/）和swap分区（交换分区）
swap分区，是交换分区，是当linux里面的内存空间不够用时，拿出该分区的空间作为内存使用。一般设置为内存的1到2倍大小，最多不要超过1G。</p>

<p>linux的文件系统：就是一个倒置的树。</p>

<p>linux的文件系统与分区的关系，</p>

<p>（8）开始分区
选择标准分区:</p>

<p>建立一个swap分区：</p>

<p>建立一个根分区</p>

<p>（9）选择“软件开发工作站”，会安装系统需要的所有的软件。</p>

<p>开始安装：</p>

<p>4、安装完成后，启动虚拟机
在启动时创建一个普通用户。</p>

<p>注意点：如果安装完成系统后，需要重启，则需要修改引导顺序，改为硬盘优先（或把安装光盘拿出也可以）</p>

<p>三、根目录讲解
根目录下面的文件夹</p>

<p>通过讲解根目录下面的文件，知道，哪些文件夹存储哪些文件。
 /bin
是存储所有的用户的命令文件。</p>

<p> /dev 
是存储硬件设备文件，在linux里面所有的硬件都是文件，要操作该硬件就要操作该硬件对应的文件。
比如：光驱对应的硬件是：/dev/cdrom或/dev/sr0</p>

<p> /home
用户的家目录，每创建一个用户，会在该目录下面创建一个和用户名同名的一个文件夹。
当用户登录后，就默认进入到自己的家目录里面，来进行操作。
注意：root 用户的家目录在/root里面。</p>

<p> /lib
系统的库目录，就类似于 window里面的window目录。
 /media<br>
多媒体目录，用于存储系统的一些媒体文件。
 /mnt （该目录不是必须的）
映射目录，就类似于 window里面使用U盘，移动硬盘的盘符，通过把U盘或移动硬盘的映射到该目录里面，读取该目录就读取u 盘或移动硬盘里面的内容。
 /proc 
内存的映射目录，
 /sbin 
超级管理员的命令目录，该目录里面存储的命令只有超级管理员能够使用，比如关机命令，添加用户，删除用户的命令，都在该目录里面。
 /tmp 
临时文件目录，
 /var 
可变文件存储目录，比如一些日志文件，数据库文件（mysql里面的data目录）等等，我们也可以使用该目录布局网站，
比如商城网站：/var/www/shop
比如门户网站：/var/www/cms
 /boot 
存储系统引导文件目录，
 /etc 
配置文件目录，存储一些系统的配置文件（比如用户配置文件passwd,shadow），系统服务的配置文件，等等，也可以存储，我们自己安装的一些程序文件的配置文件。
 /lost+found 
失物招领处，存储系统非正常关机的一些文件，由系统自动调用，无需我们干预。
 /opt
存储第三方程序文件的目录，
 /root
root用户的家目录，
 /usr 
该目录就类似于window系统里面的C:\Program Files  是默认软件的安装路径。
比如我们后面安装的apache软件、mysql软件，php软件，redis,memcache等等软件可以安装到该目录里面。
四、shell的操作，
1、什么是shell
shell就是命令集，用户通过（字符界面或命令行界面）发送shell 命令集来驱动内核调用硬件完成命令。</p>

<p>2、Linux命令组成部分
如果是在图形界面可以单击右键选择终端，就会进入到命令行操作。</p>

<p>语法格式：
命令   选项   参数（操作对象）
比如： ls  -l   /home
比如： useradd   xiaowang   </p>

<p>3、常用的命令集。
（1）ls 
查询指定路径下面的文件内容。
选项：
-l   是以详情的格式来显示文件内容。</p>

<p>-a  显示出所有的文件，包括隐藏文件，在linux里面，以 .开头的文件是以隐藏文件。</p>

<p>（2）pwd
查看当前工作的路径</p>

<p>（2）cd切换目录
切换目录可以使用绝对路径，也可以是相对路径。</p>

<p>cd  /  直接切换到根目录
cd  ..切换到上一级目录。
（3）clear 清屏命令
（4）字符界面与图形界面的切换
从图形界面直接切换到字符界面   init 3 
从字符界面直接切换到图形界面   init 5 （必须安装了图形界面才能操作，必须是本地操作）
（5）系统时钟命令：
date 查看系统时间
date –s  设置系统时间，
语法：date   –s   “年-月-日 时:分:秒” </p>

<p>以上设置，如果系统重启了，则时间又恢复到以前的状态。
要想让时间永久有效，则要把时间信息写入到计算机的 cmos（理解成计算机的硬件）里面。
clock –r  查看计算机的硬件时钟。
clock –w  把系统时钟写入到硬件时钟里面。</p>

<p>注意：在更改时，不要设置为系统安装之前的时钟。
比如，我们安装系统的时间是2015年10月22日8点整；如果要把时钟改为2015年10月22日8点整之前的时间，则无法启动系统了。
（6）系统关机重启命令。
超级管理员用户才可以设置，普通用户在默认时，没有 shutdown命令权限的。
shutdown  –h   10    表示10分钟之后，关闭计算机
shutdown  –r   10    表示10分钟之后，重启计算机
shutdown  -k   10    表示10分钟之后，关闭计算机，（并不是真正的关闭计算机，吓唬其他登录的用户）
shutdown –c  取消关机
shutdown –h now  表示立即关闭计算机 
shutdown –r  now  表示立即重启计算机
halt  等同于shutdown –h now  表示立即关闭计算机 
reboot等同于shutdown –r  now  表示立即重启计算机
当执行shutdown 命令后，会在其他用户的界面出现如下提示的。</p>

<p>五、 vi编辑器操作
1、什么是vi编辑器
Vim是一个功能强大的全屏幕文本编辑器，是Linux/UNIX 上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。 
Vim没有菜单,只有命令。</p>

<p>2、vi的三种操作模式</p>

<p>有命令行模式，输入模式（编辑模式），末行模式（尾行模式） 
在不同的模式下，执行不同的操作，</p>

<p>3、使用vi</p>

<p>vi    filename  使用vi编辑该文件，如果该文件不存在，则自动创建
vi  +  filename 使用vi编辑该文件，光标定位到最后一行。
vi  +n  filename：使用vi编辑该文件，光标定位到第n行。
vi +/string filename：使用vi编辑该文件，光标定位到string所在的行。<br>
vi  filename1   filename1  使用vi可以编辑多个文件，使用  :n切换到下一个文件，使用:prev切换到上一个文件。</p>

<p>4、基本操作
（1）命令行模式下操作
移动光标操作
字符级
            上       下       左        右(键盘箭头键)
            h(左)    j(下)    k(上)    l(右)
行级
            $   行尾
            0   行首
文档级
            G   文档尾部
            1+G 文档首部（1和G联合使用）
            n+G 定位到文档的第n行</p>

<p>删除内容操作
dd      删除本行
n+dd    当前行开始往下删除n行
x       删除单个字符
复制内容的操作
yy      复制本行
p       粘贴内容
                    [删除的内容也可以被粘贴,
                    删除内容和复制内容一样被先存入系统的缓存里边]
n+yy    从当前行往下复制n行
（2）编辑模式下使用
从命令模式进入编辑模式
    a:  光标后面输入内容
    i:  光标前面输入内容
    o:  另起空白行进入编辑模式
    s:  删除光标所在字母
（3）尾行模式下面使用
:q      退出vi编辑器
    :w      保存修改
    :wq     保存并退出编辑
    :q!     强制退出，不保存修改
    :wq!    强制保存退出
    :set  number  (:set nu)  给编辑器设置序号
    :set  nonumber (:set nonu) 取消序号显示</p>

<ol>
<li>三种模式
命令(默认)、尾行、编辑模式</li>
<li>
<p>尾行模式
:
:q      退出vi编辑器
:w      保存修改
:wq     保存并退出编辑
:q!     强制退出，不保存修改
:wq!    强制保存退出
:set  number  (:set nu)  给编辑器设置序号
:set  nonumber (:set nonu) 取消序号显示
:/内容/     搜索指定内容，小写"n"寻找下一个，大写"N"，找上一个
/内容       搜索指定内容</p>

<p>:s/被替换内容/替换内容/     替换当前行的第一个目标内容
:s/被替换内容/替换内容/g    替换当前行全部目标
:%s/被替换内容/替换内容/g   替换文档的全部目标</p>

<p>:n          跳转到n行</p>
</li>
<li>
<p>命令模式操作
① 光标移动
    字符级
        上       下       左        右(键盘)
        h(左)    j(下)    k(上)    l(右)
    单词级
        e  (本)下个单词的尾字母end
        w   下个单词的首字母word
        b  (本)上个单词的首字母before
    行级
        $   行尾
        0   行首
    段落级
        {   本(上一个)段落首部
        }   本(下一个)段落尾部
    屏幕级
        L   屏幕尾部
        H   屏幕首部
            不支持跨屏幕跳转
    文档级
        G   文档尾部
        1+G 文档首部（1和G联合使用）
        n+G 定位到文档的第n行</p>

<p>② 删除内容
        dd      删除本行
        n+dd    当前行开始往下删除n行
        x       删除单个字符</p>

<pre><code>    d+光标移动的区域
    d+$     从当前位置一直删除至行尾(包括光标所在位置)
    d+0     从当前位置一直删除至行首(保留光标所在字母)
    d+e     从当前位置一直删除至本单词结尾
    d+w     从当前位置删除至下个单词的首字母(下个单词首字母有保留)
    d+}     删除到段落的尾部(包括光标所在字母)
    d+{     删除到段落的首部(不包括光标所在字母)
    d+n+G   删除到第n行(连同光标所在行，不用考虑向下、向上删除)
</code></pre>

<p>③ 内容复制
        yy      复制本行
        p       粘贴内容
                [删除的内容也可以被粘贴,
                删除内容和复制内容一样被先存入系统的缓存里边]
        n+yy    从当前行往下复制n行</p>

<pre><code>    y+光标移动的区域
</code></pre>

<p>④ 快捷操作
        r+字符  快速替换单个字符
        u       撤销undo
        .       点，重复上一次命令
        J       大写J，合并两行</p>
</li>
<li>
<p>编辑模式
从命令模式进入编辑模式
a:  光标向后移动一位
i:  光标没有动作
o:  另起空白行进入编辑模式
s:  删除光标所在字母</p>

<p>从编辑模式退回命令模式
esc</p>

<p>对编辑的内容进行保存
编辑模式----》命令模式----》尾行模式(保存退出动作)</p>
</li>
</ol>

<p>LINUX系统操作（中）
目录
一、linux系统的启动流程    1
1、选择操作系统  1
2、选择登陆界面（字符界面还是图形界面）  1
3、挂载文件系统  3
二、用户管理  4
1、用户与用户组的概念 4
2、用户与用户组的配置文件   4
（1）group 配置文件   5
（2）/etc/gshadow配置文件 6
（3）用户配置文件/etc/passwd    6
（4）/etc/shadow  7
3、用户组管理命令   7
（1）添加用户组  7
（2）修改用户组信息    8
（3）删除用户组  8
4、用户管理    8
（1）添加用户 8
（2）修改用户 9
（3）删除用户 9
5、密码管理    10
6、禁止账号登陆  11
7、添加删除组成员   11
8、赋予普通用户特殊权限  11
三、文件管理  13
1、文件目录权限  13
2、权限的说明 13
3、更改文件权限  15
（1）更改文件权限   15
（2）更改文件拥有者    17
（3）更改文件所属组    18
4、目录管理    18
（1）创建目录 18
（2）删除目录 19
5、文件创建与删除   19
6、复制文件或目录   20
7、移动文件或目录   21
8、搜索匹配行 21
9、显示文件内容  22
四、系统定时任务    23</p>

<p>一、linux系统的启动流程
1、选择操作系统
通过配置文件/etc/grub.conf里面的配置来完成</p>

<p>如果计算机安装了多个操作系统，则会有多个14行到17行的内容。
计算机默认启动的操作系统是通过 第10行的“default=操作系统的序号”来设置的。
2、选择登陆界面（字符界面还是图形界面）
linux系统里面，有字符界面，还有图形界面，到底进入到哪个界面是由/etc/inittab 配置文件里面的配置来决定的。
使用vi   /etc/inittab打开配置文件
（1）运行级别</p>

<p>在 linux里面运行级别有7种，
0     关机
1     单用户模式启动，使用该模式可以修复简单的系统故障，就类似与window里面的安全模式。
2      多用户模式，不开启网络服务
3      字符界面
4      未定义，保留模式，给linux的开发人员使用的。
5      图形界面
6      重启
一般常用是3（字符界面）和5（图形界面）</p>

<p>第26行说明当前系统进入图形界面，如果系统启动后，默认进入字符界面则需要把第26行改为： id:3:initdefault;</p>

<p>（2）根据运行级别运行对应的目录里面的服务。 
ls –l /etc/rc.d </p>

<p>如果我们选择了3运行级别，则运行rc.d/rc3.d目录里面的服务。 </p>

<p>以K开头的是需要关闭的服务 
以S开头的是需要开启的服务。 
不同的运行级别会运行不同的服务。 
注意：rc.d目录下面的rc.sysinit文件是每个运行级别都要运行的。 
rc.local文件是登录系统之前运行的一个文件。 </p>

<p>3、挂载文件系统
（1）挂载的概念
把系统里面的目录和磁盘里面的某个区域建立对应关系
（2）/etc/fstab配置文件来完成挂载分区。</p>

<p>第一个列：分区设备文件名或UUID（硬盘通用唯一识别码）
第二个列：挂载点（系统的目录）
第三个列：文件系统类型
第四个列：挂载参数
第五个列：指定分区是否被dump备份，0代表不备份，1代表每天备份，2代表不定期备份
第六列：指定分区是否fsck检测，0代表不检测，其他数字代表检测的优先级，那么当然1优先级比2高
二、用户管理
1、用户与用户组的概念</p>

<p>在计算机里面创建的用户必须属于一个组，一个组中可以有多个用户，一个用户可以分别属于多个组，但是要注意：一个用户只能有一个初始组，可以有多个附属组 </p>

<p>初始组（主组）：给用户一开始分配的或加入的组，一个用户只能有一个初始组 
附加组（附属组）：后面给用户分配的组，附属组可以有多个。 
2、用户与用户组的配置文件
在linux 里面，通过使用配置文件来记录用户与用户组信息的。
有4个配置文件；
用户组的配置文件：/etc/group
用户组的密码文件：/etc/gshadow
用户的配置文件 :/etc/passwd
用户密码的配置文件：/etc/shadow
（1）group 配置文件</p>

<p>每一行是表示一个组，用冒号分成了4列，
第一列：表示组名
第二列：表示组密码，此处是x，x不是真正的密码，真正的密码是存储到/etc/gshadow配置文件里面的。
第三列：组的id(GID)  0表示是管理员组  1-499是系统组，系统默认创建的组。500-65535之间是我们自己创建的组。
第四列：隶属于该附属组的用户。
（2）/etc/gshadow配置文件</p>

<p>每一行是表示一个组，用冒号分成了4列，每一行和/etc/group配置文件里面的行一一对应。
第一列：组的名称
第二列：组的密码，如果为! 或空则表示没有密码。
第三列：组的管理员，
第四列：隶属于该附属组的用户。
（3）用户配置文件/etc/passwd</p>

<p>每一行表示一个用户，通过使用冒号分成7列，
第一列：用户的名称
第二列：用户的密码，此处的x不是真正的密码，真正的密码是保存在/etc/shadow文件中的，
第三列：用户的id,如果是0，则是超级管理员，1-499是系统创建的用户（伪用户）的id。
    500-65535是我们自己创建的用户的id,如果把一个普通用户的id改成0，则该用户变成了超级管理员了。注意：伪用户不能登录，不能删除。
第四列；用户的主组的组id,
在创建一个用户时，如果没有指定该用户的主组，则会自动生成一个和用户名同名的组，该组就该用户的主组。
第五列：用户的备注信息。
第六列：用户的家目录
第七列：shell类型，执行的命令集类型。</p>

<p>（4）/etc/shadow</p>

<p>每一行表示一个用户, 每一行和/etc/passwd配置文件里面的行一一对应。
第一列：用户的名称
第二列：用户的密码，该密码是加密后的密码，如果有!或*则是没有密码。
3、用户组管理命令
（1）添加用户组 
语法：groupadd  [选项] 组名 
-g   添加用户组时指定组ID</p>

<p>（2）修改用户组信息 
语法：groupmod   [选项] 组名
-n 修改组名
-g 修改组ID </p>

<p>案例1：把wagangzai改名为datang
groupmod  -n 新组名  旧组名</p>

<p>案例2:把  datang组的组 id改为999
groupmod  -g 999   datang</p>

<p>（3）删除用户组 
语法：groupdel 组名
注意：如果一个组下有用户，是不能删除这个组的。
案例：比如把前面创建的emen组给删除掉</p>

<p>4、用户管理
（1）添加用户 
语法： useradd [选项]  用户名
-g  group_name :添加用户指定所属主组
-d  home      :添加用户时指定自己的家目录</p>

<p>案例1：添加一个yangguo的用户。
useradd yangguo
注意：在创建一个用户时，如果没有指定该用户的主组，则会自动生成一个和用户名同名的组，该组就该用户的主组。
案例2:  添加一个liangshan组，
在该组里面添加一个songjiang 的用户。</p>

<p>案例3：添加一个likui 的用户，主组为 liangshan,家目录为“/xiaokui”
useradd –g  liangshan –d  /xiaokui   likui</p>

<p>（2）修改用户 
语法：usermod [选项] 用户名
-c  comment  :修改备注信息
-l  login_name :修改用户名
-d  home_dir  :修改用户家目录
-g  group_name:修改用户所属组</p>

<p>案例1：把likui改名为lidakui  并且把家目录改为/home/xiaokui
usermode –l  新的名称   -d  新的家目录   用户名</p>

<p>（3）删除用户 
语法：userdel [选项] 用户名
-r   删除用户的家目录</p>

<p>5、密码管理 
新建的用户，如果没有设置密码则是无法登陆的。
语法：passwd [选项] 用户
-S  ：查看用户密码状态
-l  ：锁定用户的密码（禁止登录）
-u  ：解除用户密码锁定
-d  ：删除用户密码
录
案例1：给songjiang设置密码
语法：passwd  songjiang</p>

<p>加密之后的密码：</p>

<p>案例2：锁定songjiang用户</p>

<p>锁定宋江用户后，密码的状态，</p>

<p>也可以直接修改/etc/shadow文件里面用户的密码，也能够完成用户的锁定，注意，在修改密码时，一般在该密码前面添加一个特殊的符号，比如使用!，当解除锁定时，直接把密码前面的特殊符号给去掉即可。</p>

<p>案例3：删除songjiang用户的密码，
删除用户密码的用户，只能在本地登陆，不能进行远程登录。</p>

<p>案例4：查看songjiang用户的密码状态</p>

<p>6、禁止账号登陆 
（1）禁止某个账号登陆 
方式一：通过  passwd –l 用户名   命令执行，
方式二：通过修改/etc/shadow 配置文件中，用户对应的密码内容，一般前面添加特殊字符。</p>

<p>（2）禁止所有普通账号登陆</p>

<p>想要禁止所有的用户登录，则需要在/etc目录下面新建一个nologin 的文件。</p>

<p>建立一个新文件的命令是  touch  /etc/nologin命令。
注意：无法禁用root用户。
7、添加删除组成员 
语法：gpasswd [选项] 组名
-a  user_name   添加组成员
-d  user_name   删除组成员
案例1：把宋江用户添加到瓦岗寨附属组。
语法： gpasswd –a  songjiang    wagangzai</p>

<p>8、赋予普通用户特殊权限
普通用户的权限受限，比如通过普通用户执行添加用户的操作，会出现如下的提示 ：</p>

<p>/etc/sudoers 
在这个文件中，记录了哪些用户可以执行哪些命令， 
visudo命令   或  vi  /etc/sudoers
这两个命令都可以用来管理/etc/sudoers文件
案例：比如给宋江用户授予添加用户的权限。
使用 visudo 命令：</p>

<p>切换到宋江登录用户
sudo –l 查看当前用户可以执行哪些指令 </p>

<p>使用“sudo 某些命令” 来执行特权命令。
添加用户：
sudo  useradd 添加的用户</p>

<p>whereis  命令，查看该命令的全路径，</p>

<p>三、文件管理
1、文件目录权限 
对文件（目录）权限本身划分 
r       读          4
w      写          2
x       执行        1
假如对一个文件的权限是7  则表示对该文件的权限是全部，（读取、写，执行）
假如对一个文件的权限是5  则表示对该文件的权限是读和执行。</p>

<p>权限从用户的角度划分 
所有者：文件的拥有者，创建该文件的用户
所属组：默认是该文件的拥有者所属初始组里面的其他用户。
其他人：</p>

<p>2、权限的说明</p>

<p>最前面的第一列：
如果是一个“-”表示是一个文件
如果是一个  ”d”表示是一个文件夹
如果是一个 “l”表示是一个链接文件，链接文件就类似于window里面的快捷方式。</p>

<p>设置的权限：rw-r--r--
第一组：rw-  是文件的所有者的权限。当前权限是读和写，没有执行的权限。
第二组：r--   是授予所属组用户的权限，比如当前权限是读，没有写和执行的权限。
第三组：r--   是授予其他人的权限，比如当前权限是读，没有写和执行的权限。
可以把rw-r--r--变成数字表示：644</p>

<p>注意：如果想要对目录中的某个文件具有删除的权限，则如何设置。对一个文件有写权限，不能删除该文件，要想删除该文件，则必须对文件所在目录具有写的权限。</p>

<p>3、更改文件权限 
（1）更改文件权限 
语法1：chmod   [选项] &lt;权限数字&gt;&lt;文件或目录&gt;  注意：比较适合于设置权限
比如对一个文件的所有者具体有读写的权限，对所属组具有执行的权限，对其他人具有读取的权限。
chmod  614   one</p>

<p>语法2：chmod [{ugo}{+-=}{rwx}][文件或目录] 注：比较适合于修改权限。
-R:递归改变 是把目录下面的所有的内容跟着改变。
two.doc原来的文件权限。</p>

<p>对two.doc文件所属组添加执行的权限。
chmod   g+x  two.doc</p>

<p>比如想把文件的所有者去掉读的权限。
chmod  u-r two.doc
组合使用用法
chmod  u-r,o+w,g+w  two.doc
chmod  u=rwx two.doc</p>

<p>（2）更改文件拥有者 
语法：chown [用户][文件或目录] 
-R:递归改变</p>

<p>（3）更改文件所属组 
语法：chgrp  [用户组][文件或目录] 
-R:递归改变</p>

<p>4、目录管理 
（1）创建目录 
    语法：mkdir [选项] 目录名
    -p  :递归创建目录
    -m  :创建目录时指定权限 
案例1：比如在根目录下面建立一个 demo目录。
mkdir   /demo</p>

<p>案例2：比如在根目录下面的demo目录里面新建一个one 目录，one/two/three/four
mkdir –p  /demo/one/two/three/four</p>

<p>案例3：在/home建立一个目录，目录名称为public,权限设置为777.</p>

<p>（2）删除目录 
    语法：rmdir [选项] 目录名
    -p  :递归删除
注意：该命令只能删除空的目录。</p>

<p>5、文件创建与删除 
（1）创建文件 
    语法：touch 文件名 </p>

<p>（2）删除文件 
    语法：rm [选项] 文件名
    -r  :递归删除（用于删除文件夹）
    -f  :关闭确认</p>

<p>使用-rf的组合，可以删除非空的目录。</p>

<p>6、复制文件或目录 
语法：cp [选项]  &lt;源文件或目录&gt;&lt;目标文件或目录&gt; 
-R  :递归复制,复制目录时常用。
-p  :复制过程中保持文件原有属性。
-v  ：显示复制过程
案例1：把/home目录下面的two.doc文件给复制到/demo目录里面。
cp  /home/two.doc  /demo/</p>

<p>案例2：把/boot目录里面的所有的内容，复制的到/demo目录里面。
命令：cp  -R  /boot   /demo
复制成功后，查看/demo目录</p>

<p>7、移动文件或目录 
语法：mv [选项]  &lt;源文件或目录&gt;&lt;目标文件或目录&gt; 
-v  :显示过程
案例1：把/home下面的one.doc 文件给移动到/demo目录里面，
mv  /home/one.doc  /demo/one.doc</p>

<p>案例2：可以使用该命令进行对文件改名操作
比如，把/demo下面的one.doc文件改名为111.doc
mv  /demo/one.doc   /demo/111.doc</p>

<p>8、搜索匹配行 
语法：grep [选项] &lt;字符串&gt;&lt;源文件&gt; 
-n  :显示行号
-c  :共匹配多少行 
-i  :忽略大小写
-v  :排除指定字符串</p>

<p>比如显示出一个文件中除了注释的内容，
grep   –v   ^#    /etc/inittab </p>

<p>9、显示文件内容 
cat  查看文件的内容：
语法：cat   文件名称
注意：比较适合于查看内容比较少的文件。</p>

<p>head   可以显示出文件的前n行
语法：head –n  文件名称</p>

<p>tail  可以显示出文件的后n行
语法：tail –n  文件名称</p>

<p>more
比较适合显示内容比较多的文档。按空格则翻屏显示，按回车是逐行显示。
less
四、系统定时任务
用户的crontab设置 
选项： 
-e  编辑crontab定时任务 
-l  查询crontab任务 
-r  删除当前用户所有的crontab任务 
shell&gt;crontab –e</p>

<h1>
<a id="进入crontab编辑界面会打开vim编辑你的工作" class="anchor" href="#%E8%BF%9B%E5%85%A5crontab%E7%BC%96%E8%BE%91%E7%95%8C%E9%9D%A2%E4%BC%9A%E6%89%93%E5%BC%80vim%E7%BC%96%E8%BE%91%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>进入crontab编辑界面，会打开vim编辑你的工作。</h1>

<p>语法： </p>

<ul>
<li>* * * * 执行的任务 </li>
</ul>

<p>说明的案例：</p>

<p>比如要定义一个每天凌晨5点执行某个命令。</p>

<ul>
<li> 5  * * *</li>
</ul>

<p>案例：</p>

<ul>
<li>/5 * * * *  /bin/echo ‘hello world’ &gt;&gt; /demo/test 
5 5 * * 2 /sbin/shutdown –r now 
0 5 1,10,15 * * /root/sh/autobak.sh 
案例说明：
第一步：执行crontab –e编辑计划任务，会自动打开vi编辑器。
文件的内容：</li>
<li>* * * *   echo “nihao” &gt;&gt; /demo/nihao.txt</li>
</ul>

<p>保存退出即可，就会每隔一分钟，向nihao.txt文件里面写入nihao的字符串。</p>

<ul>
<li>* * * *    /wamp/php/php.exe  /amp/demo/a.php</li>
</ul>

<p>shell&gt;crontab –e</p>

<h1>
<a id="进入crontab编辑界面会打开vim编辑你的工作-1" class="anchor" href="#%E8%BF%9B%E5%85%A5crontab%E7%BC%96%E8%BE%91%E7%95%8C%E9%9D%A2%E4%BC%9A%E6%89%93%E5%BC%80vim%E7%BC%96%E8%BE%91%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>进入crontab编辑界面，会打开vim编辑你的工作。</h1>

<p>LINUX系统操作（下）
目录
一、配置网络  1
（1）使用配置文件配置ip地址。  1
（2）重启网络服务，让配置生效 1
（3）测试是否启动成功 2
（4）测试是否与外部其他的计算机连接成功。   2
二、远程连接linux的服务器：  4
三、挂载光驱  6
四、安装FTP服务   7
1、软件安装方式：   7
2、 RPM软件包安装语法：    7
3、 使用rpm包开始安装FTP服务：   8
五、安装LAMP环境  11
1、安装apche软件   11
（1）解压软件 11
（2）进入解压的目录， 12
（3）执行配置 12
（4）执行编译 12
（5）执行安装 12
（6）安装完成后，要启动apache的服务，    12
2、安装mysql 软件  13
3、安装php软件 16
（1）解压，    16
（2）进入解压的文件    16
（3）配置   16
（4）编译   16
（5）安装   17
（6）复制php的配置文件，注意：进入到php解压的目录  17
（7）配置让apache支持php 17
（8）编辑一个文件，测试是否和mysql连接成功。 17
4、新建一个虚拟主机测试，   17
（1）打开apche的配置文件，支持虚拟主机的配置。  17
（2）打开 apache的辅助配置文件。    18
5、把ecshop软件给部署到linux里面  19
（1）上传ecshop软件，进行解压    19
（2）把解压后的upload 目录，拷贝到虚拟主机里面。    19
（3）在浏览器访问域名，执行安装，出现如下提示，要修改如下目录的权限。 19
6、把apache和mysql配置为开机启动。   20</p>

<p>一、配置网络
（1）使用配置文件配置ip地址。
给网卡设置ip地址，使用网卡的配置文件，
第一块网卡的配置文件：/etc/sysconfig/network-scripts/ifcfg-eth0 
第二块网卡的配置文件：/etc/sysconfig/network-scripts/ifcfg-eth1
使用vi编辑器，打开该配置文件。</p>

<p>DEVICE      :网卡的设备名称
HWADDR      :网卡的物理地址（mac）
ONBOOT      :设置为yes则系统启动时，网卡也跟着启动
IPADDR      :ip地址
NETMASK :网卡的子网掩码
BOOTPROTO   ：网卡的设置方式，static静态方式，我们自己设置ip地址，如何dhcp动态获取。
TYPE            : 网络的类型，以太网。
注意：配置linux里面的ip地址不要和window主机的 ip地址重复。
当前设置如下：</p>

<p>（2）重启网络服务，让配置生效
语法： service network start|restart|stop
如果在启动时出现如下提示；说明有一个程序NetworkManger来管理网络，让该程序禁用即可。</p>

<p>禁用：NetworkMangaer服务</p>

<p>再次重新启动网络：</p>

<p>（3）测试是否启动成功
使用ifconfig命令来测试</p>

<p>（4）测试是否与外部其他的计算机连接成功。
使用ping命令
语法：ping 对方的ip地址。
要注意：让虚拟机软件支持连接外部的网络。</p>

<p>linux连接外部网络测试：</p>

<p>window主机连接linux 系统。</p>

<p>二、远程连接linux的服务器：
使用putty远程连接软件来连接linux的服务器。
要注意：被连接的linux服务器需要安装一个服务：ssh  该服务的端口号：22，
我们默认已经安装好了。 
查看该服务的状态，是已经运行了，</p>

<p>设置连接界面的字符集：</p>

<p>设置链接界面的字体</p>

<p>设置链接界面要保持连接，防止自动断开。</p>

<p>开始连接</p>

<p>如果连接失败，需要关闭防火墙，关闭防火墙的语法 ：
service iptables stop</p>

<p>三、挂载光驱
挂载光驱就是读取光驱里面的数据。</p>

<p>光驱的硬件位置：/dev/cdrom 
在系统里边需要一个目录，让其与光驱硬件进行挂载，建立映射关系，通读取该目录，就读取里面光驱里面的内容。 
语法： 
mount  硬件设备  挂载点 
卸载： 
umount  硬件设备|挂载点 </p>

<p>（1）需要把光盘加载到光驱里面（如果是真实的机器，直接把光盘放到光驱里面即可）</p>

<p>（2）新建一个目录，该目录用于和光驱硬件建立映射关系。</p>

<p>（3）开始挂载，使用新建的目录与光驱的硬件建立映射关系。
语法： 
mount  硬件设备  挂载点(新建的目录) 
mount  /dev/cdrom  /cdrom
出现如下提示，表示挂载成功。</p>

<p>（4）挂载成功后，读取/cdrom目录，就读取里了光盘里面的内容。</p>

<p>（5）取消挂载
umount  硬件设备|挂载点 
umoutn  /dev/cdrom   或  umount   /cdrom</p>

<p>四、安装FTP服务
1、软件安装方式： 
（1）.rpm :二进制软件包 
安装简单，安装速度快 
缺点：自定义性差，依赖性强 
比如：安装a 软件，提示要先安装 b 软件，安装b软件，又提示安装 c软件，安装c软件，又提示安装d软件。
（2）.tar.gz  :源代码编译安装 
开源，自由定制 
缺点：编译时间较长，一旦报错解决困难。 
（3）智能 yum方式 
特点：解决了依赖性，要求服务器有网络，不灵活，不可以设置自己需要的具体软件版本。 
2、 RPM软件包安装语法： 
安装： 
rpm  –ivh  包全名 
-i  安装
-v  :显示详细信息
-h  :显示进度 
卸载语法：
rpm –e 软件名
--nodeps 不检测依赖性
查询软件包是否安装
rpm –qa 软件名
-a 查询所有已经安装的软件包</p>

<p>3、 使用rpm包开始安装FTP服务：
注意：rpm包在linux的安装光盘里面。
（1）挂载光驱，读取光盘里面的数据。</p>

<p>（2）开启安装，
前提：已经要进入到光盘里面的Packages文件夹
语法：rpm  –ivh  包全名 </p>

<p>（3）要启动ftp服务，</p>

<p>（4）使用ftp客户端软件，进行连接，上传文件。
注意：root用户默认不能登录ftp服务的。</p>

<p>如果出现如下提示500的错误提示。：
原因：redhat面向目标是企业，为了安全，增加了一个selinux 服务，关闭该服务即可。 
在 /etc/selinux/config 
把enforcing=&gt;disabled
运行setenforce 0命令使立即生效</p>

<p>关闭selinux 服务的步骤：
第一步：使用vi  打开配置文件/etc/selinux/config </p>

<p>第二步：让该配置立即生效，运行setenforce 0命令使立即生效</p>

<p>再次连接ftp服务，就成功了。</p>

<p>注意点：如果连接不成功，
（1）查看vsftpd服务是否开启，（2）关闭防火墙(service iptables stop)（3）用户名或密码是否输入错误。
五、安装LAMP环境
安装顺序，建议是apache-&gt;mysql-&gt;php
源码安装的步骤：
解压软件包
configure配置
make编译
make install安装
1、安装apche软件
（1）解压软件
软件解压格式： 
后缀tar.gz    tar   –zxvf  压缩包 
后缀tar.bz2   tar   –jxvf   压缩包 
tar命令解压缩语法： 
-x 解包.tar文件 
-v显示详细信息 
-f指定解压文件 
-z解压缩 </p>

<p>（2）进入解压的目录，</p>

<p>（3）执行配置
可以使用./configure –help查看配置 的帮助。</p>

<p>（4）执行编译
make</p>

<p>（5）执行安装
make install</p>

<p>（6）安装完成后，要启动apache的服务，
开启服务语法：/usr/local/apache/bin/apachectl   start|stop|restart</p>

<p>查看是否启动成功：
netstat –tunpl |grep 80</p>

<p>apache启动成功后，进行测试：</p>

<p>注意：安装完成出现如下提示的解决方案：</p>

<p>步骤1：打开apache的配置文件：</p>

<p>查看自己的linux的主机名称：</p>

<p>步骤2:打开/etc/hosts的配置文件：</p>

<p>2、安装mysql 软件
（1）新建一个mysql的组
shell&gt;groupadd mysql
（2）新建一个mysql用户，加入到mysql组里面来
shell&gt;useradd  -g  mysql  mysql
（3）解压软件</p>

<p>（4）进入解压后的文件夹</p>

<p>（5）#配置mysql编译选项，指定安装路径及支持的字符集
shell&gt;./configure --prefix=/usr/local/mysql \
    --with-charset=utf8 \
    --with-extra-charsets=gbk,gb2312,binary</p>

<p>（6）执行编译
make
（7）执行安装
make  install
（8）复制mysql的配置文件，注意：是从解压的目录里面复制到/etc/my.cnf</p>

<p>（9）初始化数据库，</p>

<p>（10）安全性配置</p>

<p>（11）启动mysql 服务
注意：&amp;表示该服务在后台执行。</p>

<p>查看是否启动：</p>

<p>（12）登录mysql服务器，
注意：在安装完成后，默认 mysql是没有root用户密码的。</p>

<p>为了安全要更改mysql里面root用户的密码。
语法：
use  mysql
update user set password=PASSWORD(‘root’) where user=’root’;</p>

<h1>
<a id="清空权限缓存使更改立即生效" class="anchor" href="#%E6%B8%85%E7%A9%BA%E6%9D%83%E9%99%90%E7%BC%93%E5%AD%98%E4%BD%BF%E6%9B%B4%E6%94%B9%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>清空权限缓存，使更改立即生效。</h1>

<p>执行：flush privileges</p>

<p>重新登录：</p>

<p>关闭服务的一个命令：
pkill  服务名称<br>
比如要关闭apache则使用pkill httpd,比如要关闭mysql则使用 pkill mysqld,
注意：在默认情况下，操作源码包安装的软件，不要使用service来操作。</p>

<p>3、安装php软件
（1）解压，</p>

<p>（2）进入解压的文件</p>

<p>（3）配置</p>

<p>（4）编译
make 
（5）安装
make install
（6）复制php的配置文件，注意：进入到php解压的目录
cp  php-5.2.5/php.ini-dist /usr/local/php/lib/php.ini</p>

<p>（7）配置让apache支持php</p>

<p>步骤：打开apache的配置文件，添加如下代码：</p>

<p>（8）编辑一个文件，测试是否和mysql连接成功。</p>

<p>4、新建一个虚拟主机测试，
（1）打开apche的配置文件，支持虚拟主机的配置。</p>

<p>（2）打开 apache的辅助配置文件。</p>

<p>配置完成虚拟 主机后，出现如下提示：如何解决？</p>

<p>解决步骤
（1）开启访问权限，
打开apache的配置文件，</p>

<p>（2）打开 apache的配置文件，修改默认首页面，</p>

<p>再次测试就正常了：</p>

<p>5、把ecshop软件给部署到linux里面
（1）上传ecshop软件，进行解压
对.zip文件，解压使用unzip命令：
语法： unzip  压缩文件名称</p>

<p>（2）把解压后的upload 目录，拷贝到虚拟主机里面。</p>

<p>（3）在浏览器访问域名，执行安装，出现如下提示，要修改如下目录的权限。</p>

<p>修改权限如下：</p>

<p>6、把apache和mysql配置为开机启动。
打开 /etc/rc.local,linux系统每次启动后都会自动执行这个文件，在该文件中，加入以下两行内容：
/usr/local/apache/bin/apachectl start
/usr/local/mysql/bin/mysql_safe --user=mysql &amp;</p>

<p>如何卸载源码包安装的软件 ：停止服务，删除掉整个安装目录即可。
比如卸载apace则删除/usr/local/apache目录，比如卸载mysql则删除/usr/local/mysql目录。</p>

<p>网页静态化与mysql优化（一）
目录
网页静态化与mysql优化（一）  1
一、衡量大型网站的标准   1
二、大型网站带来的问题   2
三、高并发的解决方案：   2
四、大流量（带宽）的解决方案  2
1、配置压缩，减少数据传输的数据量。    2
2、减少http的请求，  5
3、把比较占用流量的资源单独部署服务器。  6
4、花钱买带宽。  7
五、大存储解决方案 7
1、使用缓存技术  7
2、对mysql进行优化    8
六、页面静态化技术：  8
1、概述：   8
2、几个重要的概念   8
3、实现方式    9
4、ob缓存的介绍   9
5、ob缓存对应的函数。  10
6、生成静态页面的案例：  13
7、生成静态页面的案例扩展：    14
8、静态化在smarty里面使用，   15
9、真静态的优缺点说明：  15
七、伪静态的讲解    15
1、什么是伪静态  15
2、实现方式，入门案例 16</p>

<p>一、衡量大型网站的标准
pv 值(page views):页面的浏览量
概念：一个网站的所有页面，在一天内，被浏览的总次数，达到千万级别，几百万也可以。
uv值(unique visitor)独立访客
概念：一个网站，在一天内，有多少个用户访问过我们的网站，几十万以上，
独立ip：
概念：一个网站，在一天内，有多少个独立的ip地址来访问我们的网站。
uv值略大于独立ip的。</p>

<p>如果要考虑公司的局域网，则uv值略大于独立ip的</p>

<p>二、大型网站带来的问题
大并发： 
概念：在同一时间点，有多少用户同时访问网站。 
大流量： 
大并发，必然要导致大流量，需要高的带宽。 
大存储： 
数据库存储，表达到G,T级别。 </p>

<p>三、高并发的解决方案：
网站重新架构，分层技术，负载均衡，集群，读写分离
负载均衡器： 
硬件： 
F5-BIGIP:立竿见影，效果非常好，价格昂贵。一些大型的网站公司和网游公司在用。 
软件： 
lvs(linux virtual server)集成到linux的内核里面了， 
nginx  (该软件可以做web服务器，也可以做负载均衡使用)
负载均衡器的策略： 
（1）轮询技术：就是负载均衡把请求轮流转发给 web服务器。 
（2）最少连接：负载均衡把请求转发给最空闲的web服务器。 
（3）ip哈希：同一地址的客户端始终请求同一台 web服务器。 </p>

<p>四、大流量（带宽）的解决方案</p>

<p>1、配置压缩，减少数据传输的数据量。
原理图：</p>

<p>缺点：在服务器端，要进行对数据压缩，要耗费时间，在浏览器端解压缩，要耗费时间。</p>

<p>原理：为了提高网页在网络上的传输速度，服务器对主体信息进行压缩。如常见的gzip压缩，deflate压缩，compress压缩以及google、chrome正在推的sdcn压缩。
查看浏览器支持的压缩格式：通过firbug等系列软件，查看请求的头信息。</p>

<p>Apache上利用gzip压缩算法进行压缩的模块有两种：mod_gzip和mod_deflate. 
Apache 1.x系列没有内建网页压缩技术，使用额外的第三方mod_gzip模块。
Apache2.0以上的版本中gzip压缩使用mod_deflate模块。
配置压缩的步骤：
（1）apache服务器，要开启deflate模块，或gzip模块
打开apache的配置文件，</p>

<p>（2）在虚拟主机里面添加如下的配置
 
DeflateCompressionLevel  6       #压缩级别为6，可选1-9，推荐为6 
AddOutputFilterByType DEFLATE  text/plain #压缩文本文件 
AddOutputFilterByType DEFLATE  text/html #压缩html文件 
AddOutputFilterByType DEFLATE  text/xml #压缩xml文件
 
DeflateCompressionLevel 指令来设置压缩级别。该指令的值可为1（压缩速度最快，最低的压缩质量）到9（最慢的压缩速度，压缩率最高）之间的整数，其默认值为6（压缩速度和压缩质量较为平衡的值）</p>

<p>注意：为什么要指定文件类型来压缩？
压缩也是要耗费cpu资源的，图片/视频等文件，压缩效果也不好，不要压缩。一般压缩文本格式的文件。
没有压缩之前：</p>

<p>添加压缩代码之后；</p>

<p>查看文件的类型，通过响应头里面的”content-type”属性来查看。</p>

<p>虚拟主机里面的配置：</p>

<p>2、减少http的请求，
主要是合并文件，合并js，css,背景图片等文件。把浏览器一次请求需要的js,css，背景图片文件，合并成一个文件，这样，浏览器请求一次即可。</p>

<p>效果：</p>

<p>3、把比较占用流量的资源单独部署服务器。
一般占用流量的资源就是视频和图片，</p>

<p>4、花钱买带宽。
五、大存储解决方案
1、使用缓存技术
目的：做到，少查或不查数据库，
（1）页面静态化技术（磁盘缓存）
把一个动态页面（操作数据库的）转换成一个静态的html页面。
原理：</p>

<p>apache处理静态页面的速度要远远快于处理php页面的速度。</p>

<p>（2）内存缓存
内存缓存技术有：memcache和redis以及mysql里面的memory引擎。
原理：</p>

<p>注意：计算机从内存里面读取数据的速度，要远远快于从磁盘里面读取。
2、对mysql进行优化
六、页面静态化技术：
1、概述：
就是把一个动态的页面变成一个静态页面，后续用户直接访问静态页面。</p>

<p>页面静态化技术分为两种：真静态和伪静态。
真静态：把一个动态的页面，转成一个静态的页面,即.html文件
伪静态：所谓伪静态是从url地址上看是一个静态页面，但是实际上还是对应一个动态页面，
比如：<a href="http://www.abc.com/news-sport-id12.html">http://www.abc.com/news-sport-id12.html</a>
实际上是操作。<a href="http://www.abc.com/news.php?type=sport&amp;id=12">http://www.abc.com/news.php?type=sport&amp;id=12</a>,
2、几个重要的概念
（1）动态网址：
所谓动态网址，一般来说去查询数据库，比如:<a href="http://www.abc.com/goods.php?id=120">http://www.abc.com/goods.php?id=120</a>
特点：查询数据库，速度慢；接收参数，安全性要注意（sql注入）；不利于seo搜索引擎优化。
（2）静态网址
比如：<a href="http://www.abc.com/index.htm%E8%BF%99%E4%B8%AA%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%BD%91%E5%9D%80%EF%BC%9A">http://www.abc.com/index.htm这个就是一个静态网址：</a>
特点：不查询数据库，速度快；不接收参数，安全性高；利于seo
（3）伪静态网址：
从形式上看是一个静态页面，但是实际上对应一个动态页面，
比如：<a href="http://www.abc.com/news-sport-id12.html">http://www.abc.com/news-sport-id12.html</a>
实际上是操作。<a href="http://www.abc.com/news.php?type=sport&amp;id=12">http://www.abc.com/news.php?type=sport&amp;id=12</a>,
特点：本身需要查询数据库，执行速度慢；不接收参数，因此安全；利于seo
3、实现方式
真静态：使用ob缓存技术来实现
伪静态：使用web服务器的rewrite机制（url的重写机制）来实现。</p>

<p>4、ob缓存的介绍
（1）程序缓存。
程序缓存，缓存的数据是，返回给浏览器的数据（包含头信息和主体信息）
程序缓存不能关闭，默认就有的。
（2）ob缓存
ob就是 output_buffering:输出缓存，缓存的数据是返回的响应的主体数据，可以自由的关闭打开。
在请求一个php的过程中，我们实际上经过三个缓存，ob缓存，程序缓存，浏览器缓存。 </p>

<p>注意点：如果开辟了ob缓存，主体数据首先存储到ob缓存里面，头信息要存储到程序缓存（无论是否开启ob缓存），当代码执行完毕后，ob缓存里面的数据刷新（移动）到程序缓存，程序缓存再输出到浏览器缓存中，最后输出内容。
（3）如何开启ob缓存。
有两种方式：
方式一：直接在页面中执行ob_start() 函数。
方式二：在php.ini文件中开启。
output_buffering = 容量|on|off</p>

<p>5、ob缓存对应的函数。
ob_start()开启 ob缓存，只针对当前页面有效。
ob_clean();清空ob缓存里面的数据</p>

<p>ob_get_contents();获取ob缓存里面的数据内容。</p>

<p>ob_end_clean();清空ob缓存，并关闭ob缓存。</p>

<p>ob_flush();把ob缓存里面的数据，给刷新（移动）到程序缓存，并不关闭ob缓存。</p>

<p>ob_end_flush();把ob缓存里面的数据，刷新（移动）到程序缓存，并关闭ob缓存，。</p>

<p>总结：
常用的是：ob_start()   ob_get_contents()   ob_clean()
$content = ob_get_contents();
file_put_contents(‘index.html’,$content);</p>

<p>案例1：
&lt;?php 
ob_start(); 
echo "abc";
header("content-type:text/html;charset=utf-8");
echo "hello";<br>
ob_clean();
echo "aa";
header("content-type:text/html;charset=utf-8");
?&gt;
6、生成静态页面的案例：
newslist.php新闻的列表页面</p>

<p>newsinfo.php新闻的详情页面。</p>

<p>7、生成静态页面的案例扩展：
给一个生存周期，比如说300秒，过了300秒后，要重新生成静态页面。</p>

<p>如果没有做静态化，并发量是1000，在300秒内，查询数据库多少次。300*1000
如果做了静态化，并发量是1000，而且缓存周期为300秒，在300秒内，查询数据库多少次？仅仅1次。</p>

<p>如何给一个页面设置生命周期。
比如生命周期为300秒，满足什么条件在有效期内。
创建文件的时间戳+生命周期&gt;当前的时间戳</p>

<p>8、静态化在smarty里面使用，
$smarty-&gt;cache_dir = “./cache/";  //缓存目录 
$smarty-&gt;caching = true;  //开启缓存,为flase的时侯缓存无效 
$smarty-&gt;cache_lifetime = 60;  //缓存时间(单位 秒) 
if(!$smarty-&gt;isCached(’01.html’)){ 
    //判断模板文件是否被缓存。 
} 
9、真静态的优缺点说明：
优点： 1. 速度快 2. 安全性高 3. 利于seo 
缺点：就是占有磁盘空间., 如果过大，对磁盘响应速度有影响
在什么情况下，建议不要使用真静态
1.  页面的数据更新频繁，最好不要使用真静态(比如股票，基金，等实时报价系统)
2.  会生成海量页面(比如大型论坛 bbs ,csdn)
3.  查询该页面一次后，以后再也不查询该页面.
4.  不愿意被搜索引擎抓取的页面.
5.  访问量小的页面.</p>

<p>七、伪静态的讲解
1、什么是伪静态
伪静态：把一个动态的地址伪装成一个静态的地址。
实现方式：利用web服务器的rewrite机制。
rewrite机制：将一个请求URL重写到另一个请求上！
比如：
index.html   重写成 index.php 
abc.php  重写成  123.php 
news_sport_id12.html   重写成  news.php?type=sport&amp;id=12 
原理图：</p>

<p>2、实现方式，入门案例
（1）开启重写模块
打开apache的配置文件，</p>

<p>（2）语法说明，
RewriteEngine  on  重写引擎开关，一旦开启，所有的重写条件都生效。
RewriteCond  重写条件，当达到什么条件时，完成重写。
RewriteRule :定义重写规则，哪个地址应该被重写到哪个目标地址。
具体的配置，可以在虚拟主机里面完成配置，也可以在.htaccess文件里面配置。</p>

<p>（3）入门案例；
比如请求index.html 页面，变成请求index.php页面。</p>

<p>网站静态化与mysql优化（二）
目录
一、伪静态 1
1、正则表达式的回顾    1
2、伪静态实现方式语法，详解。 5
（1）RewriteCond  重写条件    5
（2）RewriteRule :定义重写规则  6
3、入门案例： 6
4、伪静态在 ecshop里面的使用。   8
5、防盗链效果 9
6、[QSA]   10
二、 mysql优化  12
1、优化概述    12
2、分析需要优化的语句 12
（1）慢查询日志  13
（2）mysql里面的profiles机制，  14
3、mysql里面的索引， 16
（1）索引的分类：   16
（2）索引的创建  16
（3）索引的删除，   17
（4）索引的查看  18
4、创建索引的注意事项 18
5、索引的数据结构   19
（1）myisam引擎的索引    19
（2）innodb的索引的数据结构   19
6、explain(执行计划)工具使用   20
（1）语法分析：  21
（2）分析type列的值。   23</p>

<p>一、伪静态
1、正则表达式的回顾
（1）要求取出练习的4个数字</p>

<p>（2）要求取出，形式为：xxx-yyy-xxx的数据</p>

<p>正则中几个概念：
子表达式：简单理解成用小括号括起的部分就是一个子表达式，
捕获：把子表达式的内容，保存在内存。
反向引用：圆括号的内容被捕获后，可以在这个括号后被使用。
（3）要求取出，形式为：xxx-yzy-xxx的数据</p>

<p>（4）贪婪模式与非贪婪模式
如果有U即换成非贪婪匹配。
贪婪：尽可能的多匹配。
非贪婪：尽可能的少匹配。</p>

<p>（5）匹配中文</p>

<p>案例：结巴程序：
$str=”我我要要….学学php编编….程”;
直接变成：我要学习php编程
提示：使用该函数来完成，preg_replace()
2、伪静态实现方式语法，详解。</p>

<p>主要是三个配置：
RewriteEngine  on
RewriteCond
RewriteRule</p>

<p>RewriteEngine  on  重写引擎开关，一旦开启，所有的重写条件都生效。
（1）RewriteCond  重写条件
RewriteCond  重写条件，当达到什么条件时，完成重写。
语法为：
RewriteCond  判断依据  条件表达式  [条件标志] 
判断依据可以使用服务器变量。服务器可以得到一些特定信息 </p>

<p>条件表达式，可以为如下形式：
正则或特殊标识
-f   表示是一个文件。
-d   表示是一个目录
正则，正则表达式字符串。
条件标志： 
[OR]    条件间的或者关系，当出现多个条件时，默认为并且的关系，条件应该是或者的关系下，可以使用OR来表示! 
[NC]条件不区分大小写。条件匹配时不区分大小写
[OR,NC] 
（2）RewriteRule :定义重写规则
RewriteRule :定义重写规则，哪个地址应该被重写到哪个目标地址。
语法：
RewriteRule 匹配地址   目标地址 [标识] 
匹配的地址：所请求的地址，可使用正则匹配
目标地址： 所重写到的地址，可以使用反向引用！$N表示正则匹配到的第N个子模式！
比如：RewriteRule   goods-id(\d+).html  goods.php?id=$1 
标志：
[NC]        不区分大小写
[QSA]   查询字符串追加，在目标地址已经具有get参数时，会将真实请求的get参数追后边。
3、入门案例：
如果访问的文件存在，则访问该文件，若不存在，则执行重写：</p>

<p>比如请求： <a href="http://www.demo.com/index.html">www.demo.com/index.html</a>    如果index.html 文件存在，则请求该文件，如果不存在执行重写规则。
实现步骤：
使用分布式文件来完成配置，在网站的根目录下面新建一个.htacccess的文件。
（1）在www.demo.com网站根目录下面新建一个.htaccess的文件。
通过编辑器另存为的方式来建立该文件。</p>

<p>（2）修改虚拟主机里面的配置。</p>

<p>（3）在.htaccess文件里面的，具体的配置</p>

<p>4、伪静态在 ecshop里面的使用。</p>

<p>伪静态网址：<a href="http://www.myecshop.com/goods-36.html">http://www.myecshop.com/goods-36.html</a>
重写到该地址：<a href="http://www.myecshop.com/goods.php?id=36">http://www.myecshop.com/goods.php?id=36</a>
<a href="http://www.myecshop.com/goods.php?id=39">http://www.myecshop.com/goods.php?id=39</a>    该地址的伪静态网址是：
<a href="http://www.myecshop.com/goods-39.html">http://www.myecshop.com/goods-39.html</a></p>

<p>重写规则应该如何写？
goods-(\d+).html       goods.php?id=$1</p>

<p>让ecshop支持重写，把到商品详情页面的链接地址变成伪静态的。</p>

<p>具体的配置：</p>

<p>5、防盗链效果
（1）什么是盗链，
原理图说明：</p>

<p>（2）如何判断请求的来源，使用 referer头信息。</p>

<p>（3）具体的配置，只允许本网站的页面来访问该图片，</p>

<p>也可以把请求的图片重写到一个警示图片，</p>

<p>效果如下：</p>

<p>伪静态常用：把html地址，重写成php地址。
6、[QSA]
[QSA]   查询字符串追加，在目标地址已经具有get参数时，会将真实请求的get参数追后边。
123.php代码：</p>

<p>在重写规则里面没有带[QSA]</p>

<p>效果如下：</p>

<p>在重写规则里面添加[QSA]</p>

<p>效果如下：</p>

<p>二、 mysql优化
1、优化概述
设计角度：存储引擎的选择，字段类型选择，范式
利用mysql自身的特性：索引，查询缓存，分区分表，存储过程，sql语句优化配置，
部署大负载架构体系：主从复制(读写分离)。
硬件升级：
2、分析需要优化的语句 
要分析的sql语句是执行速度比较慢的。查找执行速度比较慢的sql语句。找到后，具体分析。
（1）慢查询日志
是一种mysql提供的日志，记录所有执行时间超过某个时间界限的sql的语句。这个时间界限，我们可以指定。在mysql中默认没有开启慢查询，即使开启了，只会记录执行的sql语句超过10秒的语句。
如何开启慢查询日志：
打开mysql的配置文件，window下是：my.ini    linux系统下是my.cnf</p>

<p>注意： 修改完成后，要重启mysql。
测试慢查询日志是否记录超过0.5秒的sql 语句。
benchmark(count,expr)函数可以测试执行count次expr操作需要的时间。</p>

<p>查看慢查询日志里面记录的sql语句的情况。</p>

<p>在mysql的客户端进行查看慢查询日志的时间界限</p>

<p>也可以更改该时间界限，只对当前会话有效。</p>

<p>（2）mysql里面的profiles机制，
该机制能够精确的记录执行sql语句的时间，能精确到小数点后8位
开启方式：直接在 mysql的客户端进行开启
set profiling=1|0(开启和关闭)</p>

<p>查看记录的时间：
show profiles</p>

<p>注意：不适应时，最好将其关闭</p>

<p>php当mysql的客户端，php代码如何实现，
//开启
$sql=”set profiling=1”；
mysql_query($sql);
//查询
$sql=”show profiles”;
mysql_query($sql);</p>

<p>一个sql语句执行比较慢，大多数的原因是没有用到索引，</p>

<p>3、mysql里面的索引，
索引的作用：是用于快速定位实际数据位置的一种机制。
索引在mysql中，是独立于数据的一种特殊的数据结构。
（1）索引的分类： 
普通索引： 
利用特定的关键字，标识数据记录的位置（磁盘上的位置，盘号，柱面，扇面，磁道）。 
唯一索引： 
限制索引的关键字不能重复的索引。 
主键索引： 
限制索引的关键字不能重复，并且不能为NULL。（不能为NULL的唯一索引）。一个表中只允许有一个主索引。 
全文索引：
索引的关键字，不是某个字段的值，而是字段值中有意义的词来作为关键字建立索引。
复合索引，如果一个索引（以上四种任何都可以），是依赖于多个字段创建的话，称之为复合索引。
一个myisam表的对应的三个文件,表结构文件.frm   数据文件.myd  索引文件.myi</p>

<p>添加一个普通索引后，索引文件会变大，</p>

<p>（2）索引的创建
第一种方式，在创建表时，一块创建索引。</p>

<p>第二种方式：建完表后，以alter方式建立索引。</p>

<p>（3）索引的删除，
删除主键索引：alter table   tablename   drop primary key<br>
在删除主键索引时，要注意是否有auto_increment属性，如果有，则先要删除该属性，才能删除主键索引。
删除其他索引：alter table  tablename   drop index 索引的名字 
注意：如果没有指定索引的名字则是使用该字段名称作为索引的名字的。</p>

<p>（4）索引的查看
show indexes from table_name; 
show index from table_name 
show create table table_name 
show keys from table_name 
desc table_name 
4、创建索引的注意事项 
（1）较频繁的作为查询条件字段应该创建索引
    select * from emp where empno = 1 
（2）唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
    select * from emp where sex = '男‘ 
比如： is_best  is_new   is_hot    is_sale   is_delete 
（3）更新非常频繁的字段不适合创建索引
    select * from emp where logincount = 1 
     比如登录的状态，
（4）不会出现在WHERE子句中字段不该创建索 </p>

<p>5、索引的数据结构
（1）myisam引擎的索引
索引的节点中存储的是数据的物理地址（磁道和扇区）
在查找数据时，查找到索引后，根据索引节点中的物理地址，查找到具体的数据内容 </p>

<p>（2）innodb的索引的数据结构
innodb的主键索引文件上 直接存放该行数据,称为聚簇索引，非主索引指向对主键的引用
myisam中, 主索引和非主索引,都指向物理行(磁盘位置).</p>

<p>注意: innodb来说, 
1: 主键索引 既存储索引值,又在叶子中存储行的数据
2: 如果没有主键, 则会Unique key做主键 
3: 如果没有unique,则系统生成一个内部的rowid做主键. 
4: 像innodb中,主键的索引结构中,既存储了主键值,又存储了行数据,这种结构称为”聚簇索引” 
先创建一个 myisam引擎的表，并插入数据
create table t5(
    id int primary key auto_increment,
    name varchar(12) not null  comment '名称'
)engine myisam charset utf8;</p>

<p>说明：mysiam引擎的表的数据是按照插入的顺序显示的。
再创建一个inodb引擎的表，并插入数据
create table t6(
    id int primary key auto_increment,
    name varchar(12) not null  comment '名称'
)engine innodb charset utf8;</p>

<p>说明：innodb引擎的表的数据是按照主键的顺序插入的。</p>

<p>6、explain(执行计划)工具使用 </p>

<p>主要用于分析sql语句的执行情况（并不执行sql语句）得到sql语句是否使用了索引，使用了哪些索引。 
语法：explain  sql语句\G   或 desc sql语句\G 
在mysql之前的版本中，explain只支持select语句，但是在最新的5.6版本中，它支持 explain update/delete了。 </p>

<p>做实验创建几张表：
create table user( 
    id int primary key auto_increment, 
    name varchar(32) not null default '', 
    age tinyint unsigned not null default 0, 
    email varchar(32) not null default '', 
    classid int not null default 1 
)engine myisam charset utf8; 
insert into user values(null,'xiaogang',12,'<a href="mailto:gang@sohu.com">gang@sohu.com</a>',4), 
(null,'xiaohong',13,'<a href="mailto:hong@sohu.com">hong@sohu.com</a>',2), 
(null,'xiaolong',31,'<a href="mailto:long@sohu.com">long@sohu.com</a>',2), 
(null,'xiaofeng',22,'<a href="mailto:feng@sohu.com">feng@sohu.com</a>',3), 
(null,'xiaogui',42,'<a href="mailto:gui@sohu.com">gui@sohu.com</a>',3); 
创建一个班级表：
create table class( 
    id int not null default 0, 
    classname varchar(32) not null default '' 
)engine myisam charset utf8; 
insert into class values(1,'java'),(2,'.net'),(3,'php'),(4,'c++'),(5,'ios'); 
（1）语法分析：
explain  sql语句：</p>

<p>select_type:SIMPLE
表示查询的类型，此处是一个简单的查询
table :user;
表示要查询的表。
type列：是指查询的方式，非常重要，是分析“查数据过程”的重要依据。 
可能的值：all   index   range   ref    const 
possible_key:可能用到的索引
注意：系统估计可能用的几个索引，但最终，只能用1个。 
key:最终用的索引。 
key_len:使用的索引的最大长度。 
rows:是指估计要扫描多少行。 
extra: 
using index :是指用到了索引覆盖，效率非常高 
using where:是指光靠索引定位不了，还得where判断一下。 
using temporary:是指用上了临时表，group by 与order by不同列时，或grop by,order by 别的表的列。 
using filesort:文件排序（文件可能在磁盘，也可能在内存）</p>

<p>（2）分析type列的值。
 all：是扫描所有的数据行，性能最差，一般是没有添加索引，或没有使用到索引，</p>

<p>index:比all性能稍好一点，是指要扫描所有的索引节点。</p>

<p>出现index, 则说明只在索引文件中查找。 
（1）索引覆盖的查询情况下，能利用上索引，但是又必须全索引扫描。 
（2）是利用索引来排序，但只能取出索引的列。 
range:意思是查询时，能根据索引做范围扫描。 </p>

<p>ref:是指，通过索引列，可以直接引用到某些数据行。</p>

<p>const,system,null这3个分别指查询优化到常量级别，甚至不需要查找时间。
一般按照主键来查询时，易出现 const,system 
或者直接查询某个表达式，不经过表时，出现null. </p>

<p>网站静态化与mysql优化（三）
目录
一、索引的使用细节 1
1、全值匹配    1
2、范围匹配（&lt;= &gt;= between and） 1
3、独立的列    2
4、左值匹配    3
5、or运算都有索引    4
6、多列索引： 5
7、当取出的数据量超过表中数据的20%，优化器就不会使用索引，而是全表扫描。  9
二、索引覆盖  9
三、分表技术  10
1、垂直分割。 10
2、水平分割。 11
四、翻页优化和延迟缓存   12
五、锁机制讲解   16
1、mysql里面的锁介绍 17
2、mysql表锁的演示： 17
3、mysql行锁的演示。 19
4、锁机制在php代码里面演示；    20
六、数据碎片与维护 21
七、表分区 22
1、基本概念    22
2、创建表分区的语法： 23
3、分区的类型 24
4、分区表的限制；   25
八、列类型的选择    26</p>

<p>一、索引的使用细节
1、全值匹配 
条件字段使用“=”</p>

<p>2、范围匹配（&lt;= &gt;= between and） </p>

<p>3、独立的列 
是指索引列不能是表达式的一部分，也不能是函数的参数 </p>

<p>注意：要求索引的列必须是独立的一列才能用到索引。</p>

<p>4、左值匹配 
在使用like(模糊匹配)的时候，在左边没有通配符的情况下，才可以使用索引。
在mysql里，以%开头的like查询，用不到索引。</p>

<p>比如：根据歌词搜索歌曲的名称，根据剧情搜索电影的名称。sphinx来完成。
5、or运算都有索引 
如果出现OR(或者)运算，要求所有参与运算的字段都存在索引，才会使用到索引。</p>

<p>6、多列索引： 
对于创建的多列(复合)索引，只要查询条件使用了最左边的列，索引一般就会被使用。 </p>

<p>因为联合索引是需要按顺序执行的，比如c1234组合索引，要想在c2上使用索引，必须先在c1上使用索引，要想在c3上使用索引，必须先在c2上使用索引，依此。 </p>

<p>假设某个表有一个联合索引（c1,c2,c3,c4）
A where c1=x and c2=x and c4&gt;x and c3=x 
B where c1=x and c2=x and c4=x order by c3 
C where c1=x and c4= x group by c3,c2 
D where c1=x and c5=x order by c2,c3 
E where c1=x and c2=x and c5=? order by c2,c3 
有谁知道下面A-E能否可以使用索引
该表插入的数据：
create table t4 ( 
c1 tinyint(1) not null default 0, 
c2 tinyint(1) not null default 0, 
c3 tinyint(1) not null default 0, 
c4 tinyint(1) not null default 0, 
c5 tinyint(1) not null default 0,
index c1234(c1,c2,c3,c4) 
); 
insert into t4 values (1,3,5,6,7),(2,3,9,8,3),(4,3,2,7,5); </p>

<p>分析：对name 和age 和email分别建立独立索引：最终只能使用到一个索引。</p>

<p>如果对name和age和email 建立了联合索引，在按照建立索引的顺序使用时，都用到了索引。</p>

<p>结论：如果有多个条件经常出现在where条件中，则可以对条件字段建立联合索引。</p>

<p>应用：比如goods表里面，cat_id和价格，就可以建立一个联合索引。
7、当取出的数据量超过表中数据的20%，优化器就不会使用索引，而是全表扫描。 </p>

<p>二、索引覆盖
索引覆盖是指：如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘再找数据，这种查询速度非常快，称为“索引覆盖” </p>

<p>索引覆盖就是，我要在书里 查找一个内容，由于目录写的很详细，我在目录中就获取到了，不需要再翻到该页查看。</p>

<p>如果在一个 sql 语句中，经常查询某些列，就可以把某些列建立一个联合索引，查询时就会用到索引覆盖，速度更快。</p>

<p>三、分表技术
1、垂直分割。
典型案例：把不经常查询的字段单独分割出来，形成一张新表。</p>

<p>扩展案例：
比如一个网站，需要存储如下信息，
电影信息
图片信息
音乐信息
软件信息
水果信息
方案1：可以建立一张大表，表中有各种类型的字段，
比如以上信息：
id  title   导演   主演   作词  作曲   语言  出版  下载地址    产地  甜度<br>
方案2:可以针对不同的类型建立不同的表。
比如电影表
movie 表
id  title   addtime   viewcount    导演   主演    地区    剧情   上映时间 
music表
id  title   addtime   viewcount    作词   作曲    语言   原唱
soft表
id   title  addtime   viewcount    语言   作者    下载地址……
方案3：使用内容主表+附加表。
内容主表：用于存储各种类型的公有的字段信息，
附加表：用于存储各种类型独有的一些字段信息。
当查询公有的信息时就无需连表查询，只有当查询具体数据的时候，需要连表。
后面讲的dedecms的表的设计就是如此。</p>

<p>内容主表的记录数  ====   各个附加表记录数的之和。</p>

<p>2、水平分割。
比如用户注册，存储用户的表，可以分表，
原来：user表，
分表后，形成三张表，表名为：
user_0     user_1    user_2;
在用户注册时，用户如何存储呢、用户到底存储到哪张表呢？
需要单独一张表比如 user表，该表就一个字段，用于生成用户的id,
根据id与分表的数量进行取模运算，比如此处是3个表，
取模的值如果为0则存储到user_0表里面，
如果取模的值为1则存储到user_1表里面
如果取模的值为2则存储到user_2表里面</p>

<p>四、翻页优化和延迟缓存 
limit offset,N  当offset非常大时，效率极低。 
原因是： mysql并不是跳过offset行，然后单取N行。而是取offset+N行， 
返回时，放弃前offset行，返回N行。效率较低，当offset越大是，效率越低
优化方式：
（1）非技术手段限制分页，比如百度翻页一般不会超过70页，谷歌不会超过40页。
//计算总的记录数
$total = 
//定义每页显示数量
$perpage  = 10;
//计算总的页数
$pagecount  = min(ceil($total/$perpage),70);
（2）不用offset，用条件查询：
$sql=”select * from user limit 10,10”;
$sql=”select * from user where id&gt;10 limit 10”</p>

<p>缺点：如果数据有被删除，则取出的数据结果会不一致。</p>

<p>解决方案：
解决：数据不进行物理删除（可逻辑删除）
最终在页面上显示数据时，逻辑删除的条目不显示即可。
（一般来说，大网站的数据都是不物理删除的，只做逻辑删除，比如is_delete=1）
（3）非要物理删除，还要用offset精确查询，还不限制用户分页，怎么办
我们现在必须要查，则只查索引，不查数据，得到id 
再用id去查具体条目，这种技巧就是延迟索引。 
第一步：
//select * from user limit 10000,10 （没有用到索引）
//取出数据的id<br>
select  id from user limit  10000,10(用到索引覆盖)
第二步：根据取出 id再查具体的数据，因为使用id查询比较快，因为id是主键。
因此使用一个连接查询，就可以，我们使用内连接。inner  join   left join  right join</p>

<p>五、锁机制讲解
比如有如下操作：
（1）从数据库中取出id的值，（2）把这个值加1，（3）在把该值存回到数据库。
假如该id初始值为100；
如果有两个用户同时操作。
第一个用户 ：
id=100
100+1
id=101
第二个用户：
id=100
100+1
id=101
经过两个用户操作数据库，值应该为102才对，
假如是一个购物网站，库存还剩1件，有两个用户同时购买1件商品，
mysql中的锁：同一个时间只有一个人可以获得锁，其他人只能阻塞等待第一个人释放锁。
第一个用户                             第二个用户
get lock（获得锁）                        waiting。。。。
id=100                                   waiting。。。。
100+1                                   waiting。。。。
id=101                                   waiting。。。。
unlock(释放锁)                           get lock(获取锁)
                                                                                                                    id=101
                                        id+1
                                        id=102
                                       unlock(释放锁)</p>

<p>1、mysql里面的锁介绍
mysql 的锁有以下几种形式：
表级锁：开销小，加锁快，发生锁冲突的概率最高，并发度最低。myisam引擎属于这种类型。
行级锁：开销大，加锁慢，发生锁冲突的概率最低，并发度也最高。innodb属于这种类型。 </p>

<p>2、mysql表锁的演示：
（1）添加读锁，
对myisam表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的操作。 </p>

<p>添加读锁语法：lock  table 表名 read     释放锁的语法；unlock tables</p>

<p>添加完读锁后，自己不能修改该表</p>

<p>注意：当前进程只能操作被锁定的表，如果想要锁定多张表，可以使用如下语句；
 lock table tablename1  read, tablename2 read;</p>

<p>（2）添加写锁
对myisam表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</p>

<p>当前进程就可以执行读写操作。</p>

<p>总结：
read:所有人都只可以读，只有释放锁之后才可以写。 
write:只有锁表的客户可以操作这个表，其他客户读都不能读。</p>

<p>缺点：阻塞。有些功能需要锁多张表，而有些表整个网站都要用，一旦锁定，会让整个网站处在阻塞状态
3、mysql行锁的演示。
innodb存储引擎是通过给索引上的索引项加锁来实现的，这就意味着：只有通过索引条件检索数据，innodb才会使用行级锁，否则，innodb使用表锁。 
语法： 
begin;
执行语句； 
commit; </p>

<p>4、锁机制在php代码里面演示；
建立一个表，原始数据是100，</p>

<p>模拟并发进行测试；
比如模拟50个并发，使用apache里面有一个ab.exe工具，可以使用该工具进行模拟并发</p>

<p>ab.exe工具的语法：
ab.exe –n 总的请求数量 –c并发数   网页的地址；
php代码：</p>

<p>六、数据碎片与维护 
在长期的数据更改过程中，索引文件和数据文件，都将产生空洞，形成碎片，我们可以通过一个nop操作（不产生对数据实质影响的操作）来修改表，</p>

<p>执行如下操作： delete from t9 where id=1;  操作完成后，数据应该减少三分之一才对。
执行完成该语句后，发现数据文件并没有减少三分之一，这样在数据文件中，就会产生了一个垃圾的空洞的数据文件，因此需要整理。</p>

<p>整理方法：
第一种方法：执行：alter table table_name engine 原来的存储引擎。</p>

<p>第二种方法：执行该语句：optimize  table  table_name</p>

<p>执行后，</p>

<p>注意：修复表的数据及索引碎片，就会把所有的数据文件重新整理一遍，使之对齐，这个过程，如果表的行数比较大，也是比较耗费资源的操作，所以，不能频繁的修复。
如果表的update操作很频繁，可以按周月来修复。 
七、表分区
1、基本概念
基本概念，把一个表，从逻辑上分成多个区域，便于存储数据。
采用分区的前提：数据量非常大。</p>

<p>比如一个用户表，想分成4个区域，如何分呢？
用户的id  1   到1000  分到  东区
用户的id  1001   到2000  分到 南区
用户的id  2001   到3000  分到 西区
用户的id  大于3001   的 分到 北区</p>

<p>2、创建表分区的语法：
create  table user (
    //创建表的语句
)engine myisam charset utf8
partition by 分区类型（分区的关键字）(
    //分区的项
);
比如前面规划的案例：
create table user(
    id int,
    name varchar(32)
)</p>

<p>3、分区的类型
list :条件值为一个数据列表。 
通过预定义的列表的值来对数据进行分割
例子：假如你创建一个如下的一个表，该表保存有全国20家分公司的职员记录，这20家分公司的编号从1到20.而这20家分公司分布在全国4个区域，如下表所示：
职员表：
id  name   store_id(分公司的id) 
北部    1,4,5,6,17,18 
南部    2,7,9,10,11,13 
东部    3,12,19,20 
西部    8,14,15,16 
create table p_list( 
    id int, 
    name varchar(32), 
    store_id int 
)partition by list (store_id)( 
    partition p_north values in (1,4,5,6,17,18), 
    partition p_east values in(2,7,9,10,11,13), 
    partition p_south values in(3,12,19,20), 
    partition p_west values in(8,14,15,16) 
); 
测试是否用到了分区：
explain partitions select * from p_list where store_id=20\G
注意：在使用分区时，where后面的字段必须是分区字段，才能使用到分区。</p>

<p>Range（范围） 
这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区
create table p_range( 
    id int, 
    name varchar(32), 
    birthday date 
)partition by range (month(birthday))( 
    partition p_1 values less than (3), 
    partition p_2 values less than(6), 
    partition p_3 values less than(9), 
    partition p_4 values less than MAXVALUE 
); 
less than   小于等于； 
MAXVALUE可能的最大值 
4、分区表的限制；
只能对数据表的整型列进行分区，或者数据列可以通过分区函数转化成整型列
最大分区数目不能超过1024 
如果含有唯一索引或者主键，则分区列必须包含在所有的唯一索引或者主键在内</p>

<p>不支持外键
 不支持全文索引（fulltext）
按日期进行分区很非常适合，因为很多日期函数可以用。但是对于字符串来说合适的分区函数不太多 </p>

<p>八、列类型的选择 
1、在精度要求高的应用中，建议使用定点数来存储数值，以保证结果的准确性。 
要用decimal不要使用float
mysql&gt; create table t1(price float(9,2),dprice decimal(9,2));
mysql&gt; insert into t1 values(1234567.55,1234567.55); </p>

<p>2、录入手机号带来的问题， 
使用char(11)会占用较多的字节，gbk占用2字节<em>11，utf-8占用3</em>11， 
可以使用bigint,宽度是20，只占用8个字节。 
3、 ip地址也可以采用int整型。
使用函数进行转换：
inet_aton()：把ip地址转换成整数 
inet_ntoa();把整数转换成ip地址。 
IPv4存储为int型 
PHP：ip2long(),long2ip()
MySQL: inet_aton(), inet_ntoa();
4、根据需求选择最小整数类型。比如用户在线状态：离线，在线，离开，忙碌，隐式等，可以采用0,1,2,3,来表示。 
5、避免字段内容为null，原因：null不利于索引，要用特殊的字节来标注，在磁盘上占据的空间其实更大。 
NULL的判断只能用is null,is not null 
NULL 影响查询速度,一般避免使值为NULL 
mysql&gt; create table t3(name char(1) not null default '')engine myisam; 
Query OK, 0 rows affected (0.01 sec) </p>

<p>mysql&gt; create table t4(name char(1))engine myisam; 
Query OK, 0 rows affected (0.01 sec) </p>

<p>为大型网站提速--memcached缓存技术
目录
一、memcache 的介绍    1
1、memcached基本概念   1
2、基本原理    2
3、与mysql 进行比较   2
二、memcache的安装 3
三、客户端操作memcache   5
1、设置数据    7
2、删除数据    9
3、其他命令    9
4、状态命令： 10
5、缓存时间的设置的讨论  10
四、php操作 memcache    11
1、先安装memcache的扩展，让php支持。    11
2、入门案例： 12
五、php数据类型存储memcache探讨   13
六、案例操作  15
七、案例扩展，   16
八、memcache在tp框架里面使用   18
九、memcache的分布式存储    19
1、session数据入memcache的问题：    19
2、分布式系统具体的配置  21
十、其他事项  22
1、memcache适合于存储哪些数据 22
2、memcache的安全性    23
3、数据过期的问题   23
4、数据存储空间满了，还能否存储数据呢？  23
5、如果需要设置许多缓存项时，失效时间最好不要设置为相同的。    24</p>

<p>一、memcache 的介绍
1、memcached基本概念
（1）Memcached是danga的一个项目，最早是LiveJournal 服务的，最初为了加速 LiveJournal 访问速度而开发的，后来被很多大型的网站采用。 官方网站: <a href="http://www.danga.com">www.danga.com</a>  和 memcached.org 
（2）Memcached是一个高性能的分布式的内存对象缓存系统，目前全世界不少人使用这个缓存项目来构建自己大负载的网站，来分担数据库的压力，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。
2、基本原理</p>

<p>3、与mysql 进行比较
（1）与mysql一样，是一个c/s架构的软件。
（2）mysql里面的数据，是存储到磁盘里面的，memcache里面的数据是存储到内存里面的，一旦断电，服务器重启，则会丢失数据。
（3）要使用mysql则先要创建数据库，再创建表，以及表结构。在memcache里面数据的存储是键值对。可以理解成两列的表， key与value
name   小刚
age     12
email    <a href="mailto:xiaogagn@sohu.com">xiaogagn@sohu.com</a>
二、memcache的安装
方式一：直接使用，无需安装，（在开发时推荐使用）</p>

<p>（1）把软件拷贝到指定位置，一般和其他的安装软件（比如apache等）在同级目录下面，主要是便于管理。</p>

<p>（2）以cmd的方式，运行memcache</p>

<p>启动后，该窗口不要关闭，一旦关闭，则服务就停止了。</p>

<p>方式二：把 memcahce安装成window的一个服务，（在生产环境中推荐使用）
通过查看memcached 的帮助。</p>

<p>注意：在把 memcache安装成window的一个服务时，要以管理员的方式启动cmd.</p>

<p>查看服务是否安装成功：</p>

<p>安装可能失败的原因： 
（1） 如果你是用win7,win8系统，他对安全性要求高，因此，需要大家使用管理员的身份来安装和启动. 具体是 程序开始===&gt;所有程序==》附件==》cmd(单击右键，选择以管理员的身份来执行) 
（2）存放memcache.exe 目录不要有中文或者特殊字符
（3） 安装成功，但是启动会报告一个错误信息，提示缺少xx.dll ，你可以从别的机器拷贝该dll文件，然后放入到system32下即可. 
（4）如果上面三个方法都不可以，你可以直接这样启动mem 
cmd&gt;memcached.exe  -p  端口 【这种方式不能关闭窗口 </p>

<p>三、客户端操作memcache
使用，telnet连接memcache服务器端。
memcache的默认端口号是11211.
语法：telnet    ip地址   端口号</p>

<p>注意：telnet客户端无法使用的解决方案：</p>

<p>1、设置数据
（1）添加数据，
语法：add  key  是否压缩（0|1）  缓存时间  数据的长度
key ：键的名称
是否压缩：0表示不压缩，1表示要压缩，压缩的目的让数据变小，存储更多的数据。
缓存时间：失效时间，表示过了该时间数据就失效。
数据的长度：单位是字节，</p>

<p>注意：在使用add添加数据时，如果该键已经存在，则添加失败，不会覆盖。</p>

<p>（2）修改数据
replace key  0|1  缓存时间  数据的长度
注意：如果键不存在，则修改失败。</p>

<p>（3）设置数据
set key  0|1  缓存时间  数据长度
如果键已经存在，则是修改，如果键不存在，则是添加。</p>

<p>2、删除数据
语法：delete key</p>

<p>flush_all 是删除所有的缓存项</p>

<p>3、其他命令
incr  增加指定的值
语法：incr key number</p>

<p>decr  减少指定的值</p>

<p>比如有1000件商品，需要在60秒内抢购。
一开始就设置number的值为1000   ，当用户抢购时执行decr number ,如果执行后返回的值大于0则说明抢购成功，
4、状态命令：
stats </p>

<p>通过查看状态的参数，主要是计算命中率，
get_hits/cmd_get  ====得出一个命中率，命中率越高越好，如果命中率比较低，则需要调整缓存项。</p>

<p>5、缓存时间的设置的讨论
在设置缓存时间有两种设置方式：
（1）使用秒数（时间间隔）&lt;=2592000
（1）使用到期的时间戳  该时间戳必须要大于当前的时间戳才有效。
在设置时，设置的参数都是整数，如何区分是时间戳还是时间间隔呢？
在使用时间间隔设置缓存时间时，有一个限制的，不能超过30天，30<em>24</em>3600秒2592000
比如如果要把一个缓存项失效时间设置为2个月如何设置呢？
time()+30<em>24</em>3600<em>2
比如要把一个缓存项失效时间设置为10天如何设置？
有两种设置方案：
使用时间间隔：  10</em>24<em>3600
使用时间戳： time()+10</em>24*3600
比如如果一个缓存项失效时间设置为123489,该值是时间戳还是时间间隔。
如果该值小于等于2592000则是时间间隔，如果大于该值是时间戳，</p>

<p>注意：如果缓存时间设置为0，表明此数据永不过期
四、php操作 memcache
1、先安装memcache的扩展，让php支持。
（1）准备php支持的扩展文件，要注意要和php的版本对应。</p>

<p>（2）把扩展文件拷贝到php的安装目录下面的ext目录里面。</p>

<p>（3）打开php.ini的配置文件，引入扩展。</p>

<p>（4）要重启apache
（5）使用phpinfo 函数测试是否引入成功。</p>

<p>2、入门案例：</p>

<p>五、php数据类型存储memcache探讨
标量类型：整型   浮动型  布尔  字符串</p>

<p>说明标量类型是可以存储到memcache 里面的，都是以字符串的形式存储的，最后输出也变成了字符串。
非标量类型的存储：数组  对象  null  资源</p>

<p>取出数据的代码：</p>

<p>数组 对象 资源  null在 memcache里面存储的形式。</p>

<p>说明：数组 对象 资源 是以序列化之后的结果存储到memcache里面的。
但是在取出数据时，又自动反序列化之后显示的。
序列化与反序列化的过程是由memcache的客户端完成的，无需我们自己干预。
说明则memcache里面存储的数据，是以字符串的形式来存储的。
注意：不能把资源类型存储到memcache里面，因为在取出资源类型时，把资源类型变成了整型。在实际应用中，存储数组的情况居多。
六、案例操作
想把一个sql语句的执行结果，给缓存到memcache里面。
要注意说明的，sql语句执行的结果数据要小于1MB。
在mecache 里面，键与值是有要求的，
键的长度要小于250字节。
数据值的大小要小于1MB。</p>

<p>七、案例扩展，
把新闻内容存储到memcache里面。
新闻列表页面newslist.php</p>

<p>新闻详情页面newsinfo.php</p>

<p>思考：如果新闻内容修改了如何办？修改完成新闻后要清空缓存即可。
八、memcache在tp框架里面使用
分两步：
（1）初始化memcache
S(array(
    ‘type’=&gt;’memcache’,
    ‘host’=&gt;’ip地址’,
    ‘port’=&gt;端口号
));
（2）具体的操作
获取数据；
$data = S(key);
设置数据：
S(key,value,失效时间);
清空数据：
S(key,null)</p>

<p>九、memcache的分布式存储
1、session数据入memcache的问题：
应用图示：</p>

<p>具体的配置：
打开php.ini 配置文件：</p>

<p>可以使用函数ini_set()函数改变php.ini 的配置，只对当前页面有效。
ini_set(“session.save_handler”,’memcache’);
ini_set(‘session.save_path’,’tcp://ip地址1:端口,tcp://ip地址2:端口’)</p>

<p>注意：使用session的方式和以前是一样的。
session信息存储到memcache里面是以sessionid为键的，失效时间与session相同的。</p>

<p>2、分布式系统具体的配置
注意两点：
（1）要实现分布式配置需要两台以上memcache服务器（2）使用一个算法，该算法决定数据向哪台服务器存储。</p>

<p>（2）配置实现：
设置数据
取出数据：</p>

<p>注意：在设置数据与取出数据是，memcache服务器添加顺序与个数要一致。原因是使用的算法是取模算法，
在设置数据或取出数据时，根据键名转换成一个数字与服务器的个数进行取模。取模的结果就决定向哪台服务器存储数据。
注意：memcache服务器的算法是取模算法，是内置的，我们自己无需干预。
十、其他事项
1、memcache适合于存储哪些数据
（1）安全性不是很高的数据，丢失无所谓的数据，因为memcache服务器，一旦重启或关机，则会丢失所有的数据。
（2）查询比较频繁的数据，比如热点新闻，等等。
（3）更新比较频繁的数据，比如用户的在线状态。
（4）一个键值，数据量不要很大，要小于1MB的数据。
2、memcache的安全性
memcache没有任何的安全认证（比如用户名与密码），因为是主要做缓存使用，不是做数据存储使用的。
-l   监听的ip地址，启动后，只能监听该网卡（ip地址）进来的请求。
可以把memcache服务器放入到内网中，与互联网隔离，让其他外网用户无法访问。 </p>

<p>3、数据过期的问题
在memcache里面数据过期后，不会自动删除，当get时，发现过期后，才删除该数据。
• Lazy Expiration
memcached内部不会监视记录是否过期，而是在get时查看记录的时间戳，检查记录是否过
期。这种技术被称为lazy（惰性）expiration。
因此，memcached不会在过期监视上耗费CPU时间。</p>

<p>4、数据存储空间满了，还能否存储数据呢？
• LRU
memcached会优先使用已超时的记录的空间，但即使如此，也会发生追加新记录时空间不
足的情况，此时就要使用名为 Least Recently Used（LRU）机制来分配空间。
顾名思义，这是删除“最近最少使用”的记录的机制。因此，当memcached的内存空间不足时
（无法从slab class 获取到新的空间时），就从最近未被使用的记录中搜索，并将其空
间分配给新的记录。从缓存的实用角度来看，该模型十分理想</p>

<p>5、如果需要设置许多缓存项时，失效时间最好不要设置为相同的。
主要目的：防止缓存雪崩现象。</p>

<p>redis的操作
目录
redis的操作  1
一、NOSQL 1
1、出现背景： 1
2、特点  1
3、优缺点：    1
4、NOSQL使用场景   1
5、常见nosql产品   2
二、redis介绍   2
1、概述  2
2、与memcache比较说明 2
三、安装启动  3
1、安装软件    3
2、启动软件    4
四、数据类型讲解:   4
1、字符串类型 4
2、hashes类型及操作   7
3、lists类型 9
4、集合的操作 13
5、有序集合    17
五、服务器相关的命令  17
六、安全认证  21
七、php当客户端操作redis    22
1、安装扩展    22
2、入门使用    24
八、高级案例  24
九、持久化机制   25
1、snapshotting(快照)默认方式    26
2、持久化机制之aof方式 27</p>

<p>一、NOSQL
NoSQL ,（Not Only SQL），泛指非关系型数据库。 
NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。
1、出现背景： 
随着互联网web2.0网站的兴起，传统的关系型数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点，得到了非常迅速的发展。
2、特点
NoSQL 通常是以key-value形式存储， 
不支持SQL语句， 
没有表结构 
3、优缺点： 
优点：
大数据量的扩展（高并发读写的性能 分布式存储） 
配置简单 
灵活、高效的操作与数据模型 
低廉的成本 
不足之处： 
没有统一的标准 
没有正式的官方支持 
各种产品还不算成熟
4、NOSQL使用场景
（1）对数据高并发读写
（2）对海量数据的高效率存储和访问
（3）对数据的高可扩展性和高可用性。</p>

<p>5、常见nosql产品</p>

<p>二、redis介绍
1、概述
（1）redis是一个开源的，先进的key-value存储。它通常被称为数据结构服务器，
（2）它支持存储的value类型很多，包括string(字符串)、list(链表)、set(集合)、Zset(有序集合)。 
（3）为了保证效率数据都是缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。 
（4）提供的API语言包括：C、C++、C#、Clojure     Common Lisp  Erlang  Haskell Java Javascript Lua Objective-C Perl PHP Python Ruby Scala Go Tcl </p>

<p>2、与memcache比较说明
redis与memcache比较
（1）数据类型:memcache支持的数据类型就是字符串，redis支持的数据类型有字符串，哈希，链表，集合，有序集合。
（2）持久化：memcache数据是存储到内存里面，一旦断电，或重启，则数据丢失。redis数据也是存储到内存里面的，但是可以持久化，周期性的把数据给保存到硬盘里面，导致重启，或断电不会丢失数据。
（3）数据量：memcahce一个键存储的数据最大是1M,而redis的一个键值，存储的最大数据量是1G的数据量。
三、安装启动
1、安装软件
（1）下载软件，上传到linux服务器。</p>

<p>（2）解压软件</p>

<p>（3）进入解压后的目录，</p>

<p>（4）直接执行make
（5）执行安装，在安装时指定安装的目录
make PREFIX=/usr/local/redis install </p>

<p>安装成功后， 在安装的目录下面生成一个bin目录，该目录下面有5个文件。</p>

<p>redis-benchmark 是性能测试工具。
redis-check-aof和redis-check-dump文件是日志检测工具
redis-cli是客户端连接程序
redis-server是服务器端启动程序
（6）在解压的目录里面复制配置文件到安装目录里面。</p>

<p>2、启动软件
（1）使用vim打开配置文件,进行配置，让redis服务在后台执行。</p>

<p>（2）执行启动
语法：redis-server 指定配置文件</p>

<p>查看是否启动成功：
redis的默认启动端口是： 6379，</p>

<p>关闭服务：pkill redis-server</p>

<p>（3）客户端连接 redis服务器
语法：redis-cli  -h ip地址 –p端口
如果是本机，端口默认，则直接执行redis-cli即可。</p>

<p>四、数据类型讲解:
它支持存储的value类型很多，包括string(字符串)、list(链表)、set(集合)、Zset(有序集合)。
1、字符串类型
String是最简单的类型，一个 key对应一个Value，</p>

<p>set
设置键值
语法  set  key   value</p>

<p>注意：如果key存在，则是修改，如果key 不存在则是添加。</p>

<p>get
获取键值
语法：get key</p>

<p>setnx 
设置键值，在设置时，要判断该键是否存在，如果存在，则设置失败。
语法：setnx key value</p>

<p>setex 
设置键值,在设置键值时，指定该键的有效期，单位是秒。
语法：setex  key 有效期  value</p>

<p>mset 
设置键值，可以一次性设置多个键值。
语法：mset key1 value1  key2 value2……..</p>

<p>mget 
获取键值，可以一次性获取多个键值。
语法：mget key1 key2……..</p>

<p>incr(incrby)
自增操作，加1操作，如果该键不存在，则返回1.
语法；incr  key</p>

<p>incrby
加法操作，可以指定相加的值
语法： incrby key number</p>

<p>2、hashes类型及操作 
Redis hash是一个string类型的field和value的映射表。它的添加、删除操作都是0（1）（平均）。hash特别适合用于存储对象。相较于将对象的每个字段存成单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。 </p>

<p>hset 
设置哈希的值：
语法： hset   key   field  value</p>

<p>hget 
获取哈希里面的field的值
语法： hget   key   field</p>

<p>hmset 
设置哈希的值,可以一次性设置多个field
语法：hmset key field1 value1  field2 value2……</p>

<p>hmget 
获取哈希的里面多个field的值
语法：hmget key  field1 feild2 ….</p>

<p>hlen 
计算哈希里面field的个数
语法；hlen key</p>

<p>hdel 
删除哈希里面指定field
语法：hdel key  field</p>

<p>hgetall 
返回哈希里面所有的field与value
语法：hgetall key</p>

<p>3、lists类型 
list是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等，操作中key 理解为链表的名字
可以把链表理解成一个容器，存储一些字符串元素。
可以模拟栈的操作：</p>

<p>可以模拟队列的操作。</p>

<p>注意：存在链表中的元素是有顺序的，0表示是头部的元素，依次类推。链表中就可以存在重复的元素。</p>

<p>lpush 
从头部向链表里面添加元素
语法：lpush  key  value</p>

<p>lrange 
是获取链表里面的元素
语法：lrange key 开始下标  结束下标
如果开始下标为0则是从头部开始取，如果结束下标为-1则是到链表的尾部结束。</p>

<p>rpush 
从尾部向链表里面添加元素
语法：lpush  key  value</p>

<p>lrem 
删除链表里面的元素
语法：lrem key 删除个数 指定的元素</p>

<p>ltrim 
保留指定范围的元素
语法：ltrim  key 开始下标  结束下标</p>

<p>lpop 
删除链表头部的一个元素
语法：lpop key</p>

<p>lindex 
返回链表中指定下标的元素。
语法：lindex key 下标</p>

<p>Lsize:计算链条里键的个数。
4、集合的操作
sets类型及操作 
set是集合，它是string类型的无序集合。set是通过hash table实现的、添加、删除和查找的复杂度都是0(1)。对集合我们可以取并集、交集、差集。通过这些操作我们可以实现sns中的好友推荐和blog的tag功能。</p>

<p>集合的概念和数学里面的集合 的概念类似。
集合的特点：集合里面的元素具有唯一性，无序性。</p>

<p>sadd 
向集合里面里面添加元素
语法： sadd  key</p>

<p>smembers 
返回集合里面的元素
语法：smembers key</p>

<p>srem 
删除集合中指定 的元素
语法：srem key 指定的元素</p>

<p>sdiff 
返回集合中的差集，在集合1中出现过，不在集合2中出现的元素。</p>

<p>sinter
返回两个集合的交集。
语法：sinter 集合1  集合2 </p>

<p>sunion 
返回集合的并集，多个集合合并，去掉重复的元素。
语法：sunion 集合1 集合2</p>

<p>scard 
返回集合中元素的个数</p>

<p>sismember 
判断某个元素是否在该集合里面。
语法：sismember 集合名称  指定的元素。</p>

<p>5、有序集合
给集合中的元素添加顺序编号（下标）</p>

<p>五、服务器相关的命令
keys
获取当前的键，可以使用通配符。* ?</p>

<p>exists
判断key是否存在，
语法：exists key</p>

<p>del
删除指定的key
语法：del key</p>

<p>expire
给指定的键设置失效时间
语法：expire key 失效时间（秒）</p>

<p>ttl 
返回该键的未失效时间。</p>

<p>type
返回key的类型，</p>

<p>select
选择数据库，在redis 里面，默认有16个数据库（0-15），默认是进入的0号数据库。
语法：select 数据库的编号（0-15）</p>

<p>dbsize 
查看当前数据里面的键的数量</p>

<p>flushdb 
清空当前数据库里面的键。</p>

<p>flushall 
清空所有数据库里面的键</p>

<p>六、安全认证
设置客户端连接后进行任何其他操作前需要使用的密码。 
注意：因为 redis速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150k次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解
配置方法：
使用vi打开redis的配置文件。</p>

<p>注意：设置完成密码后，要关闭redis服务，重新开启。</p>

<p>如果设置了密码，没有经过授权，则可以连接，但无法操作。
认证方式，有两种，可以在登录时授权，也可以在登录后授权。</p>

<p>方式一：在客户端登录redis服务的时候，
语法：redis-cli    –a 密码</p>

<p>方式二：客户端登录服务器后，执行auth可以授权。
语法：auth 密码</p>

<p>七、php当客户端操作redis
1、安装扩展
（1）准备扩展，要注意安装的扩展要和php的版本对应。要安装不带nts的。</p>

<p>（2）要把对应扩展的两个文件，拷到php的安装目录ext目录下面。
 注意：如果你的php版本是5.3系列的直接拷贝一个文件即可（php_redis.dll）。 
（3）打开php.ini的配置文件，要引入扩展
注意：extension=php_igbinary.dll一定要放在extension=php_redis.dll的前面，否则此扩展不会生效。</p>

<p>（4）重启apache，使用phpinfo函数进行测试</p>

<p>2、入门使用</p>

<p>八、高级案例
完全是redis来做，
1、用户的注册</p>

<p>2、用户的显示</p>

<p>九、持久化机制
redis是一个支持持久化的内存数据库，也就是说redis需要经常将内存中的数据同步到硬盘来保证持久化。 
redis支持两种持久化方式： 
（1）snapshotting(快照)默认方式 
（2）append-only file( 缩写aof)的方式
1、snapshotting(快照)默认方式
快照是默认的持久化方式。这种方式是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb.可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key修改就自动做快照。</p>

<p>具体的配置：</p>

<p>假如有1个键发生了更新。
0       60       60      60     60     60  60  300      900</p>

<p>可以手动发起快照，有两种操作方法
方法一：未登录时，
语法：./redis-cli  -a  密码  -h ip地址   bgsave  手动发起一次快照保存操作</p>

<p>方法二：已经登录
语法：直接执行bgsave</p>

<p>2、持久化机制之aof方式
由于快照方式是在一定间隔做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。 
aof比快照方式有更好的持久化性，是由于在使用aof时，redis会将每一个收到的写命令都通过write函数追加到文件中，当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容
具体的配置：
appendonly   yes    //启用 aof 持久化方式
appendfilename   appendonly.aof   //保存命令的文件</p>

<h1>
<a id="appendfsync-always---每次收到写命令就立即强制写入磁盘最慢的但是保证完全的持久化不推荐使用" class="anchor" href="#appendfsync-always---%E6%AF%8F%E6%AC%A1%E6%94%B6%E5%88%B0%E5%86%99%E5%91%BD%E4%BB%A4%E5%B0%B1%E7%AB%8B%E5%8D%B3%E5%BC%BA%E5%88%B6%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E6%9C%80%E6%85%A2%E7%9A%84%E4%BD%86%E6%98%AF%E4%BF%9D%E8%AF%81%E5%AE%8C%E5%85%A8%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>appendfsync always   //每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用</h1>

<p>appendfsync everysec   //每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐</p>

<h1>
<a id="appendfsync-no---完全依赖-os性能最好持久化没保证" class="anchor" href="#appendfsync-no---%E5%AE%8C%E5%85%A8%E4%BE%9D%E8%B5%96-os%E6%80%A7%E8%83%BD%E6%9C%80%E5%A5%BD%E6%8C%81%E4%B9%85%E5%8C%96%E6%B2%A1%E4%BF%9D%E8%AF%81" aria-hidden="true"><span class="octicon octicon-link"></span></a>appendfsync no   //完全依赖 os，性能最好,持久化没保证</h1>

<p>aof文件的重写，把备份文件里面的命令操作重新整理成命令，
比如incr number执行10次后，结果为10，默认是保存了10次incr number命令，aof执行重写后，就直接把10次incr number变成set number  10,会 减少aof 的文件的容量，提高效率。
手动重写：bgrewriteaof 命令，
可以在未登录执行，也可以在登录后执行s</p>

<p>环境搭载系列
课程体系（第1天）
一共分为四个阶段
基础阶段: php基础知识(底层知识)介绍, 7天
Mysql基础: mysql操作+编程(PHP+mysql), 5 + 1天
PHP高级编程: 面向对象(类): 项目, 12天左右
中级项目: 以小组为单位, 6天</p>

<p>基础知识
1.  什么是PHP?
一种运行在服务器端的脚本语言(超文本预处理语言)
PHP: Personal HomePage,个人主页, 用Perl语言写的一种脚本语言
PHP: PHP Hypertext Preprocessor超文本预处理语言(C语言)</p>

<p>PHP定义：一种服务器端的 HTML 脚本/编程语言,是一种简单的、面向对象的、解释型的、健壮的、安全的、性能非常之高的、独立于架构的、可移植的、动态的脚本语言。是一种广泛用于 Open Source（开放源代码）的尤其适合 Web 开发并可以嵌入 HTML 的多用途脚本语言。它的语法接近 C，Java 和 Perl，而且容易学习。该语言让 Web 开发人员快速的书写动态生成的网页。</p>

<ol>
<li><p>什么是脚本语言?
脚本语言是一种解释性语言, 相对编译型语言来说.
编译型语言: 写好的原代码不能直接运行,必须先通过第三方软件(编译器)进行编译后得到编译结果(可执行文件): c语言在windows下编译结果是.exe文件, java编译成.class文件
特点: 一次编译可以永久执行
脚本语言: 需要执行的时候才会进行编译(每次执行都必须先编译)
特点: 效率没有编译型语言高; 跨平台性能高</p></li>
<li><p>PHP的历史?
作者: Rasmus Lerdorf
发展历程
1994:1.0 个人perl
1996:2.0 C语言底层, 性能和稳定性都得到很大的提高
1998:3.0 zend公司,开发出zendEngine(zend引擎)用来高效率的处理PHP代码
2000:4.0 session(会话技术)+输出缓冲等
2004:5.0 zend引擎2代
2015:7.0 向纯面向对象发展</p></li>
</ol>

<p>Web基础
1.  如何实现上网?
条件: 联网(TCP/IP), 浏览器(输入URL), 服务器</p>

<p>步骤:
1.  在个人电脑上打开浏览器输入URL: <a href="http://www.itcast.cn:80/gz/php/index.php">http://www.itcast.cn:80/gz/php/index.php</a> (浏览器都是默认携带80端口进行访问: URL中可以没有端口)
URL: Uniformed Resource Location,统一资源定位
1.1 进行域名解析: <a href="http://www.itcast.cn%E5%8F%98%E6%88%90%E5%AF%B9%E5%BA%94%E7%9A%84ip%E5%9C%B0%E5%9D%80">www.itcast.cn变成对应的ip地址</a>: 192.168.25.13(本地域名解析[局域网]+DNS(Domain Name System[互联网]))
<a href="http://192.168.25.13/gz/php/index.php">http://192.168.25.13/gz/php/index.php</a>: 确定找到网络上的某台电脑</p>

<p>1.2 服务器处理请求: 通过端口找到电脑上对应的服务软件(apache)
服务器: 一台装有服务器软件的电脑
服务器软件: 区分服务器软件进行不同服务的处理的是服务器上的端口(Port)
Web服务(监听80): apache, iis, tomcat, nginx等
文件服务(监听21): ftp等
数据库服务(监听3306): mysql, oracle, sqlserver等</p>

<p>1.3 apache处理请求
1.3.1 寻找文件夹: 别名解析: 将域名解析成对应的文件夹
<a href="http://www.itcast.cn">www.itcast.cn</a> ====&gt; ServerName: D:/wamp/www
1.3.2 寻找文件: URI(Uniformed Resource Identifier), 统一资源标志: url中域名之后的所有内容
URI: /gz/php/index.php ====&gt; D:/wamp/www/gz/php/index.php
1.3.3 权限控制: 判断当前请求是否符合当前网站被访问的允许条件: Allow和Deny
1.3.4 读取index.php中的内容
1.3.5 将读到的内容返回给浏览器</p>

<p>1.4 浏览器解析内容: HTML + CSS + JS</p>

<p>开发环境
1.  什么是开发环境?
开发环境指的是某台电脑(服务器) 能够进行某种编程语言的开发以及运行测试.
环境通常不只是一个软件, 而是多个软件的共同协作.
Web2.0(动态网站)开发环境
接收用户请求的软件: 服务器软件(apache)
处理交互的语言: PHP
处理数据的软件: 数据库软件(mysql)</p>

<ol>
<li><p>开发环境分类
a)  集成环境: 需要共同协作的软件被集成到一起: 变成一个软件, 一次安装就可以实现多种功能: wamp, xapp, phpstudy,appserv等
特点: 
都不是由某个公司发表, 都是由个人制作
功能相对简单(简化)
不安全
b)  独立环境: 单独安装所有需要协作的软件(apache,php,mysql), 需要将软件彼此进行配置(共同协作)
特点:
安装麻烦: 安装多个软件,外加单独配置
安全</p></li>
<li><p>如何选择开发环境?
通常作为开发环境,会使用集成环境: 简单方便
作为服务器通常会使用独立环境: 安全</p></li>
<li><p>独立环境的安装?
独立环境由三个部分构成: apache+php+mysql
独立环境分为两种
Wamp: windows + apache + mysql + php
Lamp: Linux + apache + mysql + php
Lnmp: Linux + nginx + mysql + php</p></li>
</ol>

<p>搭建独立环境
安装apache</p>

<ol>
<li><p>获得apache安装软件: 建议去官网下载: <a href="http://www.apache.org">www.apache.org</a></p></li>
<li><p>双击运行: 进入欢迎界面</p></li>
<li><p>点击”next”进入到协议界面</p></li>
<li><p>接收协议点击”next”, 进入到协议界面</p></li>
<li><p>点击”next”进入到apache配置界面</p></li>
<li><p>进行各项配置之后, 点击”next”进入到安装配置类型选择界面</p></li>
<li><p>选择”Custom”点击”next”进入到安装配置界面</p></li>
</ol>

<p>路径的配置: 不能有空格, 不能有中文
8.  修改apache的安装目录为D:/server/apache, 点击”next”进入到安装准备界面</p>

<ol>
<li><p>点击”install”进行安装</p></li>
<li><p>点击”finish”完成安装</p></li>
</ol>

<p>安装失败可能出现的问题
1.  Windows允许安装多个apache, 但是必须指定不同的端口: 如果出现红点,那么说明apache安装成功: 但是启动失败(端口占用)</p>

<ol>
<li><p>验证apache是否正常工作: 在浏览器中输入url: localhost</p></li>
<li><p>查看apache的目录结构</p></li>
<li><p>www目录保存: 保存所有的脚本文件</p></li>
<li> Bin/mysql/mysql5.6/data/数据库名字文件: 整个数据库对应的文件夹名字全部保存</li>
<li><p>Bin/mysql/mysql5.6/data/ibdata1</p></li>
<li><p>查看apache的bin目录
a)  Ab.exe: 用来测试脚本的执行效率以及服务器的压力</p></li>
</ol>

<p>B)  httpd.exe,本质是apache的服务器</p>

<p>-M 测试可以使用的功能(加载的模块)</p>

<p>-t 语法测试(配置文件语法)</p>

<p>解决ServerName问题: apache的配置文件: D:/server/apache/conf/httpd.conf</p>

<p>Apache工作原理
Apache不解释任何代码: 只读取内容返回给浏览器</p>

<p>Apache是模块化运行: 所有的功能都是以模块的形式存在</p>

<p>安装PHP</p>

<ol>
<li><p>获取php的安装文件: 建议去官网. <a href="http://www.php.net">http://www.php.net</a>
PHP最新的版本是7.0测试版(不稳定)</p></li>
<li><p>解压缩</p></li>
<li><p>PHP不需要真正安装可以直接使用: 将PHP文件夹移动到D:/server/下,并且重命名为php</p></li>
<li><p>PHP之所以能够处理php代码,全依赖: php.exe, 专门解析PHP代码(PHP之外的其他内容都会原封不动的保留): 命令行运行</p></li>
<li><p>Php.exe解析php文件</p></li>
</ol>

<p>PHP能够解析PHP代码, 但是不服务于apache: apache能够获取接收浏览器的请求, 但是不能处理PHP代码: 要实现动态网站开发,就必须结合apache和PHP. </p>

<p>Apache加载PHP</p>

<p>加载原理: apache是模块化运转, 功能都是由一个个模块组成, 需要将PHP变成apache的一个模块.</p>

<ol>
<li> Apache加载PHP模块: D:/server/apache/conf/httpd.conf
LoadModule   php5_module  php对apache提供的操作接口路径</li>
</ol>

<p>任何一次修改配置文件,若要生效,必须重启apache.
2.  Apache必须给PHP分配任务: 如果是php代码就交给PHP模块处理: apache是不认识什么是php代码: 通过文件后缀判断.
AddType   application/x-httpd-php   .php       #以.php结尾的文件交给php处理</p>

<ol>
<li> 效果: 重启apache之后</li>
</ol>

<p>安装mysql
1.  获取mysql的安装文件: 建议去官网: <a href="http://www.mysql.com">www.mysql.com</a></p>

<ol>
<li><p>在win7或者win8下面: 软件的安装都需要管理员权限: 给安装文件所有权限</p></li>
<li><p>双击运行: 右键-&gt;管理员权限运行: 进入到欢迎界面</p></li>
<li><p>点击”next”,进入到协议界面</p></li>
<li><p>选择同意协议,点击”next”进入到安装类型选择界面</p></li>
<li><p>点击”Custom”进入到功能选择界面:
a)  修改mysql的安装路径</p></li>
</ol>

<p>b)  修改mysql的数据存储路径</p>

<ol>
<li><p>修改两个路径,点击”next”进入到准备安装界面</p></li>
<li><p>点击”Install”安装: 安装时间有点: 中途需要点击两次”next”进入到安装完成界面</p></li>
<li><p>点击”finish”进入到mysql实例配置欢迎界面</p></li>
<li><p>点击”next”进入到配置类型选择界面</p></li>
<li><p>选择详细配置, 点击”next”进入到服务器类型选择配置</p></li>
<li><p>选择开发者机器, 点击”next”进入到数据库功能选择界面</p></li>
<li><p>选择多功能数据库,点击”next”进入到innodb存储引擎(事务处理)数据存储位置</p></li>
<li><p>直接点击”next”进入到数据库并发量选择界面</p></li>
<li><p>选择手动配置,将配置的并发量设置为15个: 点击”next”进入到网络配置</p></li>
<li><p>勾选增加防火墙例外点击”next”进入到字符集选择</p></li>
<li><p>选择手动选择字符集,并将字符集设置成utf8,点击”next”进入到操作系统配置界面</p></li>
<li><p>构造加入到环境变量, 点击”next”进入到安全配置</p></li>
<li><p>输入两次root用户密码,(选择性勾选允许远程root用户访问). 点击”next”进入到配置准备界面</p></li>
<li><p>点击”Execute”进行配置: 等待四个圆圈都被打上勾: 配置成功</p></li>
<li><p>点击”finish”完成安装</p></li>
<li><p>查看mysql的安装目录结构</p></li>
<li><p>测试安装是否成功: 时刻谨记(当前服务器是安装在一台不知道的计算机上)
Mysql是一种c/s结构的软件(客户端/服务端): 必须由客户端访问服务端</p></li>
</ol>

<p>客户端:
1.  找到服务器所在的电脑: -h: host,主机地址,可以是域名或者ip地址,默认是localhost(127.0.0.1)
2.  找到对应的软件端口: -P:port,端口,确定软件, 默认是3306
3.  验证用户权限: -u:username 用户名; -p: password用户密码</p>

<p>PHP配置mysql
PHP默认的是不能操作mysql的: 但是PHP可以通过扩展实现操作mysql
1.  找到PHP的配置文件: php.ini</p>

<ol>
<li><p>将开发环境对应的配置文件复制一份,重命名为php.ini</p></li>
<li><p>PHP加载mysql扩展: extension</p></li>
<li><p>指定扩展所在位置: extension_dir</p></li>
<li><p>必须将PHP的配置文件交给apache管理: apache的配置文件中加载php.ini
PHPIniDir    php配置文件所在的路径</p></li>
<li><p>查看apache是否加载php.ini成功: phpinfo()</p></li>
<li><p>修改PHP所在的时区: php.ini</p></li>
</ol>

<p>网站: 网络站点, 网络上的某台计算机(装了apache软件: 提供web服务)
用户角度: 能够输入URL得到网页服务
程序猿角度: 服务器上的某个文件夹</p>

<p>虚拟主机
虚拟主机: 不是真实存在的主机, 是程序猿模拟出来的主机, 通过apache来模拟</p>

<p>Apache模拟虚拟主机有两种方式
基于IP的虚拟主机: 一个IP地址一个网站(一个主机名)
一个网卡绑定一个IP地址: 但是一台电脑可以绑定多个网卡</p>

<p>基于域名的虚拟主机: 一台电脑上只有一个IP地址, 但是可以通过给不同的文件夹进行别名设置(主机名): 通过用户进行访问时, 匹配主机名---&gt; 找到不同的文件夹</p>

<p>基于域名的虚拟主机配置
1.  先开启apache的基于域名的虚拟主机功能
NameVirtualHost <em>:80    #监听来自所有IP地址(</em>)的所有80端口请求(浏览器请求)</p>

<ol>
<li>
<p>配置虚拟主机: 给不同的文件夹设置不同的别名(主机名)
</p>

<h1>
<a id="指定文件夹所在目录" class="anchor" href="#%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>指定文件夹所在目录</h1>

<p>DocumentRoot 路径</p>

<h1>
<a id="指定别名" class="anchor" href="#%E6%8C%87%E5%AE%9A%E5%88%AB%E5%90%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a>指定别名</h1>

<p>ServerName 别名
</p>
</li>
<li><p>重启apache之后,若要实现使用新的主机名访问网站: 必须配置hosts文件</p></li>
<li>
<p>权限配置: 针对网站下的对应文件夹内部的内容的访问权限配置
</p>

<h1>
<a id="权限的管理顺序" class="anchor" href="#%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%A1%E7%90%86%E9%A1%BA%E5%BA%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限的管理顺序</h1>

<p>Order Deny,Allow    #Deny和Allow没有顺序限制: 代表等下要执行的顺序</p>

<h1>
<a id="权限限定" class="anchor" href="#%E6%9D%83%E9%99%90%E9%99%90%E5%AE%9A" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限限定</h1>

<p>Allow from all #允许所有的用户访问: 最后读到是Allow,之后不能再读取Deny(后面的Deny无效: 如果有allow继续有效果)
Deny from 192.168.25.100 #禁止来自局域网内的某个ip(100)访问</p>
</li>
</ol>

<p></p>

<ol>
<li> 一般情况下, 一个网站都会给用户提供一个默认的首页: 用户一般不知道首页名字
DirectoryIndex 首页文件 首页文件2 首页文件3: 一个一个的匹配</li>
</ol>

<p>效果</p>

<ol>
<li> 为了开发方便: 通常当访问一个文件夹的时候希望得到的是文件夹内部的文件列表
Options Indexes FollowSymLinks #FollowSymLinks是否支持软连接</li>
</ol>

<p>效果</p>

<ol>
<li> 启动虚拟主机之后: 默认的localhost就会失效: 所以所有的匹配不上主机的web请求,都会被apache自动拦截成第一个虚拟主机的访问.
若要实现localhost: 重新配置一个localhost虚拟主机即可.</li>
</ol>

<p>Httpd.conf下面是配置apache的大体表现, 虚拟主机是一种专门的单独的配置: 不应该将虚拟主机配置到httpd.conf下: 应该单独配置到一个文件中: /apache/conf/extra/httpd_vhost.conf</p>

<p>Apache主配置文件: httpd.conf需要加载虚拟主机的配置文件</p>

<ol>
<li> 搭建新的localhost的虚拟主键</li>
</ol>

<p>回顾（第2天）
开发环境搭建: 独立环境
Apache: 接收浏览器的请求
加载PHP
LoadModule php5_module php5apache2_2.dll路径 #加载PHP模块
AddType application/x-httpd-php  .php #分配任务给PHP
PHPIniDir php.ini所在的路径 #加载PHP的配置文件
PHP: 处理PHP代码
开启mysql扩展
Extension = php_mysql.dll   ;开启mysql扩展
Extension_dir = D:/server/php/ext   ;指定扩展路径
Mysql: 处理数据</p>

<p>虚拟主机: 基于IP和基于域名</p>

<p>开启虚拟主机
NameVirtualHost *:80</p>

<p>搭建虚拟主机
</p>

<h1>
<a id="指定根目录路径" class="anchor" href="#%E6%8C%87%E5%AE%9A%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>指定根目录(路径)</h1>

<p>DocumentRoot 文件夹路径</p>

<h1>
<a id="别名主机名" class="anchor" href="#%E5%88%AB%E5%90%8D%E4%B8%BB%E6%9C%BA%E5%90%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a>别名(主机名)</h1>

<p>ServerName 主机名</p>

<h1>
<a id="权限控制" class="anchor" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限控制</h1>

<p></p>

<h1>
<a id="权限顺序管理" class="anchor" href="#%E6%9D%83%E9%99%90%E9%A1%BA%E5%BA%8F%E7%AE%A1%E7%90%86" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限顺序管理</h1>

<p>Order Deny,Allow</p>

<h1>
<a id="权限规则" class="anchor" href="#%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限规则</h1>

<p>Deny from 要限制的内容
Allow from 允许的内容(all, 192.168.31.*)</p>

<h1>
<a id="查看文件夹列表" class="anchor" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%97%E8%A1%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>查看文件夹列表</h1>

<p>Options Indexes</p>

<h1>
<a id="默认首页-系统自带默认indexhtml" class="anchor" href="#%E9%BB%98%E8%AE%A4%E9%A6%96%E9%A1%B5-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E9%BB%98%E8%AE%A4indexhtml" aria-hidden="true"><span class="octicon octicon-link"></span></a>默认首页: 系统自带默认(index.html)</h1>

<p>DirectoryIndex 首页1 首页2  ... 

</p>

<p>PHP基础知识</p>

<p>PHP: 一种运行在服务器端的脚本语言(嵌入到HTML中)</p>

<p>PHP标签
标签的意义: 为了区分PHP代码和其他代码</p>

<p>PHP标签从发展的历史到现在总共分为四种: 标准标记, 脚本标记, 短标记, ASP标记</p>

<p>标准标记
&lt;?php
//PHP代码
?&gt;</p>

<p>脚本标记
PHP本质也是一种脚本语言: 脚本语言自有的标记是
Script默认是js脚本标记: 为了区分js,必须加上language属性: language=”PHP”</p>


 

<p>注意: 为了区分js,通常PHP不使用脚本标记</p>

<p>短标记
短标记是在标准标记的前提下: 去除一部分(php)
&lt;?
//PHP代码
?&gt;</p>

<p>短标记: 默认的PHP已经不支持, 如果想要支持,需要修改配置文件,重新开启短标记</p>

<p>开启短标记</p>

<p>效果</p>

<p>ASP标记
在早期, php模拟了Asp做脚本语句, 使用过Asp的标记.</p>

<p>&lt;%
//PHP语句
%&gt;</p>

<p>默认的: PHP早就不支持asp标记了</p>

<p>开启Asp标记</p>

<p>效果</p>

<p>PHP基础语法
PHP的每一条都必须有语句技术符:分号”;”: 最后一条语句可以省略语句结束符: 原因是PHP自带的标记结束符相当于有一个分号.</p>

<p>只能最后一行没有语句结束符:其他的不行</p>

<p>PHP不是一次性读取所有标记内的代码: 是读到开始标记之后, 一行一行的解析直到碰到标记结束符号. 
如果没有结束标记: 那么PHP也能正常解析, 只要保证开始标记之后全部都是PHP代码即可.</p>

<p>特别注意: 如果一个脚本没有PHP结束标记,那么最后一行代码也必须加上语句结束符:分号</p>

<p>经常性,如果没有语句结束符的时候(echo的时候),系统会提示期望出现逗号或者分号.
Echo允许使用逗号将需要输出的多个内容进行分隔.</p>

<p>变量
变量: 临时存储数据的”容器”.</p>

<p>变量是用来临时的保存数据所存储的内存地址
访问数据: 通过变量找到对应的内存地址,取出内存地址中存储的数据.</p>

<p>PHP变量的基本规则
1.  所有的变量名前面必须加上一个符号: $符号(变量符号)</p>

<ol>
<li><p>变量名字只能由: 字母,数字和下划线组成, 不能以数字开头</p></li>
<li><p>PHP中的变量名字是区分大小写: $a与$A是两个不同的变量</p></li>
<li><p>PHP变量的定义就是赋值</p></li>
<li><p>变量: 可以改变的量,变量可以随时被修改</p></li>
<li><p>变量可以被删除: 从内存中清除
利用系统提供的一个删除变量的函数: unset(变量)</p></li>
</ol>

<p>常量
与变量一样都是数据的”容器”.
常量: 一旦定义不可以被修改(更新和删除)</p>

<p>常量规则
1.  常量不需要使用$符号
2.  常量的定义方式与变量完全不一样
a)  使用系统自带的函数: define(‘常量名’,常量值);</p>

<p>b)  使用const关键字: const 常量名 = 值;</p>

<ol>
<li><p>PHP中所有需要用户(程序猿)命名的内容都可以理解为: 由字母,数字和下划线构成,其中,不能使用数字开头(常量变态一点: 可以使用特殊符号, 但是不能直接访问常量,必须使用常量访问函数: constant(‘常量名’))</p></li>
<li><p>常量的时候,直接使用常量名</p></li>
<li><p>常量默认区分大小写: 通常常量全部都用大写字母</p></li>
<li><p>常量可以不区分大小写: 使用define函数的第三个参数</p></li>
</ol>

<p>注释
注释: 给人看的, 计算机(php.exe)会自动忽略所有的注释</p>

<p>注释分为两种: 行注释和块注释</p>

<p>行注释: 只注释一行
//和#
块注释: 注释多行
/* 跨行 */</p>

<p>系统变量和常量
系统已经定义好的变量和常量, 程序猿只需要直接使用即可.</p>

<p>系统变量
系统变量: 超全局预定义变量
超全局: 没有使用范围限制: 在php代码中的任何位置都可以直接访问
预定义: 在用户开始写代码之前就已经定义好</p>

<p>PHP提供了9大预定义变量: 都是数组
$GLOBALS: 自动的包含所有的全局变量: 变量名作为数组的下标, 变量值作为数组元素的值
$global = ‘haha’;
&lt;=====&gt;
$GLOBALS[‘global’] = ‘haha’;</p>

<p>$_SERVER:   收集服务器信息(还包括来请求的浏览器)</p>

<p>$_GET: 自动接收所有的来自浏览器提交的数据: get方式提交(url之后跟的数据)
$_POST: 自动接收所有的来自浏览器提交的数据: post方式提交(form表单,method为post)
$_REQUEST: 自动接收所有的来自浏览器提交的数据: 无论是get还是post
元素的值为用户输入的数据, 元素的下标(键名)是来自于表单中的name属性的值</p>

<p>$_SESSION:  自动的获取所有的session数据(来自服务器)
$_COOKIE: 自动的获取所有的cookie数据(来自浏览器)
$_FILES: 自动的获取浏览器上传的文件信息: 每个文件都固定有5个信息(名字,临时名字,类型,大小,错误编码)</p>

<p>$_ENV:  enviroment,自动获取环境信息(修改variables_order)</p>

<p>系统常量
PHP_OS: php运行的操作系统的版本</p>

<p>PHP_VERSION: 当前PHP的版本</p>

<p>PHP_INT_SIZE: PHP整型所占用的字节数: 4个字节, 32位</p>

<p>PHP_INT_MAX: 获取PHP所能表示最大整数</p>

<p>PHP中整型(数值型)都是有符号类型(有正负): 在所有的二进制位(32位),最左边的一位表示符号位(0表示是正的,1表示是负)</p>

<p>魔术常量: 常量的值是不固定的 ,根据具体所处的环境自动改变(用户改变不了)
<strong>FILE</strong>: 获取当前文件的绝对路径(包含文件名)</p>

<p><strong>LINE</strong>: 获取当前行号</p>

<p><strong>DIR</strong>: DIR是Directory的意思: 路径的意思, 获取当前文件所在的路径(不包括文件名)</p>

<p><strong>FUNCTION</strong>: 获取当前函数的名字(必须在函数内部使用)
<strong>METHOD</strong>: method叫方法,本质是函数: 方法是必须在类的内部: 带类</p>

<p>可变变量
可变变量: 必须存在两个变量
其中, 有一个变量的值刚好是另外一个变量的名字, 可以通过当前变量访问另外一个变量的值.</p>

<p>$左手 = ‘右手’;
$右手 = ‘苹果’;</p>

<p>通过左手变量访问右手的数据
$$左手 ===&gt; 苹果</p>

<p>变量传值
变量传值: 就是将一个变量保存的数据传递给另外一个变量.
变量在传值的过程中有两种方式: 值传递和引用传递.</p>

<p>值传递
将一个变量的值, 复制一份,把新的这份交给另外一个变量保存: 从而在内存中产生两个变量, 对应两个不同的值: 任何一个的修改都不会影响彼此.</p>

<p>$变量1 = 值;
$变量2 = $变量1;</p>

<p>引用传值
引用传值: 变量实际保存的是数据对应的内存地址, 如果将一个变量所保存的内存地址赋值给另外一个变量: 存在两个变量共同指向同一块内存地址, 一个变量的修改会导致另外一个变量的修改.</p>

<p>引用传递必须在被传递的变量之前使用地址符号: &amp;</p>

<p>$变量1 = 值;
$变量2 = &amp;$变量1;   //取$变量1的地址</p>

<p>PHP内存模拟
内存分析
内存都是分为以下几个部分
栈区: 是程序所能操作的理论上唯一的内存区域, 内存很小, 但是效率最高
堆区: 是唯一的内存地址连续的内存, 内存很大, 但是效率最低
代码段: 装载代码的内存, 程序要运行,必须先将代码装载到代码段, 然后在代码段里面逐行的运行程序代码
数据段: 是普通数据存储的内存, 里面通常还分为两块区域: 全局区存放普通数据; 静态区存储常量和静态数据.
数据段和堆区都是由栈区来操作</p>

<p>PHP代码的执行</p>

<p>PHP是一种高级语言(接近自然语言), 所以不可能被计算机直接解析(计算机只能识别机器码(二进制));</p>

<ol>
<li> 将所有的脚本(代码)加载到内存(代码段)</li>
<li> 编译
a)  词法分析
b)  语法分析</li>
<li> 生成opcode: 机器可以执行的代码(二进制)</li>
<li> zendEngine(zend引擎)解析opcode, 返回执行结果</li>
</ol>

<p>PHP代码内存分析
1.  将代码加载到代码段: 编译
2.  逐行的执行代码
3.  PHP将执行结束的结果返回给</p>

<p>PHP数据类型
PHP是一种弱类型语言: PHP的变量没有数据类型的概念, 可以存放任意的数据类型.
数据本身都是有数据类型的, 数据是人为分类的, 分成不同的类型.</p>

<p>在php中所讲的数据类型指的是变量所保存的数据本身.
通常都是用变量的数据类型来代替变量所保存的数据的数据类型.</p>

<p>PHP将数据类型分为三大类八小类</p>

<p>三大类: 基本(标量)数据类型,复合数据类型和特殊数据类型</p>

<p>标量数据类型
标量又称之为基本数据类型(简单数据类型)
分为四种: 整型, 浮点型, 布尔型和字符串型</p>

<p>整型</p>

<p>Php变量保存的数据是整数(有效范围内)</p>

<p>$a = 3; //3是一个整型, $a是一个整型
$b = -3;    //整型包含正和负(有符号)</p>

<p>Php还能保存其他进制的整型
$num = 123; //默认是十进制数据
$num = 0123;    //0不代表前缀: 告诉服务器当前数据是八进制
$num = 0x123;//十六进制</p>

<p>通用的转十进制的方法: 将位数上的值 * 对应的进制的N - 1次方(从右往左)</p>

<p>PHP可以安装数据本身的进制进行输出: 需要使用特定的输出方式printf()
Printf(‘输出方式占位符’,要输出的数据列表);</p>

<p>十进制输出: %d
八进制输出:%o
十六进制输出:%x</p>

<p>浮点型</p>

<p>浮点型: 带小数点的数值都是浮点型, 超出整型范围的数值类型也是浮点型.</p>

<p>浮点型数据又称之为精度型数据: 分为单精度(float)和双精度(double)
Float: 使用4个字节保存数据: 表示的数据范围10^38, 但是表示的有效数字(精度)大概为7位
Double: 使用8个字节保存数据: 表示的数据范围10^308, 表示的精度范围大概为15位</p>

<p>PHP中只有双精度,没有单精度: 双精度也是有float表示不是double</p>

<p>浮点数如果超出精度范围后, 会自动的四舍五入</p>

<p>为什么浮点数能够存储较大的数据呢? 4字节(单精度)
4个字节一共32位: 如果全部用来存储数据最多表示42亿多
浮点数: 使用一部分用来存储数据, 另外一部分存储指数</p>

<p>布尔类型</p>

<p>布尔类型只有两种数据: true或者false, 布尔类型通常用于判断</p>

<p>在PHP中大部分的数据转换成布尔类型的时候都是true,只有以下几种类型会转换成false
空字符串: ‘  ’ / ‘’
0值: 0/ ‘0’/0.0
空数组: array()
NULL: null</p>

<p>字符串类型</p>

<p>存储的数据是字符串数据: 是一类应用最广的数据类型(互联网之间传递的数据和文件内部存储的数据全部都是字符串)</p>

<p>在php中,字符串有三种定义方式
单引号: 数据用单引号包裹</p>

<p>双引号: 数据用双引号包裹</p>

<p>单引号与双引号的区别
1.  单引号与双引号解析的转义字符不一样
a)  单引号能转移的字符: \, \’
b)  双引号能转义的字符: \, \”, \r\n, \t, \$</p>

<ol>
<li> 双引号字符串内部的$符号会被解析成变量符号: 如果有$符号会被自动当做变量进行输出</li>
</ol>

<p>双引号解析变量的时候注意事项: 系统没有办法自动的区分变量名字,只要$符号后面跟的普通字符串(字母,下划线和数字)都会被系统当做变量的名字: </p>

<p>解决方案1: 使用非字母,数字或者下划线的符号(空格)</p>

<p>解决方案2: 使用{}将变量包裹起来: 告诉系统内部是一个变量</p>

<p>定界符: 使用定界符包裹数据
$变量 = &lt;&lt;&lt;定界符标志
//中间所有的内容都是字符串
定界符标志;</p>

<p>定界符特点
1.  定界符的首标志后面不能跟任何内容: 包括空格和注释</p>

<ol>
<li><p>定界符内部的内容全部都是属于字符串内容(包括注释)</p></li>
<li><p>定界符的结束标志必须定格: 前面不能有任何内容(空格和tap)</p></li>
<li><p>定界符的结束符号后面也不能有任何内容</p></li>
</ol>

<p>定界符的存在其实本质是为了解决引号字符串的多行问题以及结构问题
定界符分为两种: 分别代表单引号和双引号</p>

<p>Heredoc结构: 代表双引号</p>

<p>Nowdoc结构: 代表单引号(内部不能解析变量): 给定界符首符号加上一对单引号</p>

<p>复合数据类型
只有两种小数据类型: 数组和对象: 表示能够存储多个数据(保存在内存中的堆区)</p>

<p>特殊数据类型
只有两种数据类型
空类型: NULL: 变量没有指向内存地址
资源类型: resource, 外部数据类型</p>

<p>总结
Php基础语法: 
标记(标准标记)
基本语法(语句结束符)
变量和常量(系统变量和系统常量[魔术常量])
可变变量, 变量传值(值传递和引用传递)
内存分析PHP执行过程, 代码在内存中的分布(非常重要)
数据类型: 本质是数据的数据类型(PHP是弱类型语言)
标量数据类型: 整型, 浮点型, 布尔型和字符串型</p>

<p>回顾（第3天）
PHP基础知识: 标记, 基础语法, 变量, 常量(系统变量+系统常量), 可变变量, 变量传值(值传递和引用传递), 内存分析(栈:变量标示符, 堆:复合数据类型, 代码段: 代码, 数据段: 数据)</p>

<p>数据类型: 三大类八小类
三大类: 基本数据类型,复合数据类型和特殊数据类型
基本数据类型: 浮点,整型,布尔,字符串类型
复合数据类型: 数组和对象
特殊数据类型: NULL和资源</p>

<p>运算符
对数据进行运算的符号</p>

<p>PHP中的运算符: 算术运算符, 比较运算符, 逻辑运算符, 赋值运算符, 连接运算符, 位运算符, 三目运算符, 自操作运算符, 错误抑制符</p>

<p>算术运算符
对数据进行基本的算术运算: 加,减,乘(*),除(/),取余(取模%)</p>

<p>基本运算注意: 除法运算和取模运算的时候除数不能为0</p>

<p>错误抑制符
错误抑制符: 当代码有可能出现错误(低级别错误: notice,warning等), 该错误可能不影响代码的正确执行, 又不希望错误被用户看到(用户体验性下降), 就可以使用错误抑制符来抑制可能出现的错误. </p>

<p>比较运算符
比较运算符: 对数据进行比较: 大于(&gt;),小于(&lt;)或者等于(==), 大于等于(&gt;=), 小于等于(&lt;=),全等于(===),不等于(!=), 不全等(!==)</p>

<p>所有的比较符号返回的结果都是布尔类型: true或者false</p>

<p>==: 值相等比较, 只要保证两边的数据的值相同即可, 相同返回true,不同返回false
===: 全等比较, 不单要值相同, 还要数据类型相同</p>

<p>在比较的时候(==),会自动转换成同一类型再进行比较; 全等比较(===)是先比较类型,后比较数据</p>

<p>赋值运算符
赋值运算符: 将右边的结果(或者说左边的结果结合右边的结果)赋值给左边的变量.
赋值运算: 赋值(=), 运算赋值(+/-/*///%/.=)
$a += $b ===== $a = $a +($b)  ===/== $a = $b + $a
$a /= $b ===== $a = $a / ($b);  //$b不能为0</p>

<p>右边如果是运算表达式(多重),先算右边结果</p>

<p>如果有除法运算(%和/),那么右边的结果不能为0</p>

<p>连接运算符
连接运算符: 将多个字符串连接到一起,形成一个新的完整的字符串
连接运算: . </p>

<p>凡是系统见到 . 运算符: 就会将两边的数据自动转换成字符串类型</p>

<p>逻辑运算符
逻辑运算符: 本身不是针对业务, 而是针对结果进行运算.
逻辑运算: 逻辑与(&amp;&amp; and), 逻辑或(|| or)和逻辑非(!)
逻辑与: 两个结果都为真的时候, 整体结果为真,否则为假
逻辑或: 两个结果有一个为真的时候,整体为真,否则为假
逻辑非: 对一个结果进行操作, 原结果为真就为假, 原结果为假最终为真</p>

<p>逻辑与和逻辑或都可以通过左边的第一个结果进行判断整个结果: 这种方式称之为短路运算.
如果使用逻辑与: 将容易出错的放前面
如果使用逻辑或: 将容易对的放前面</p>

<p>三目运算符
三目运算也称之为三元运算: 一目代表一个表达式, 三目有三个表达式参与的运算</p>

<p>表达式: 从理论上能够返回结果的任何语句都是表达式
1, $a = 1, 3 &gt; 2等等</p>

<p>三木运算语法
表达式1 ? 表达式2 : 表达式3;
//如果表达式1成立: 结果为true , 执行表达式2 放弃表达式3; 否则相反
//表达式1一定会执行: 表达式2和表达式3选择性执行</p>

<p>三目运算本质是一种简化的if判断</p>

<p>三目运算可以有嵌套三目运算: 每个表达式本身也可以是一个三目运算: 每个子三木运算要使用()包裹.</p>

<p>自操作运算符
自操作: 自己操作自己
自操作运算: ++和--, 自己对自己进行+1或者-1操作</p>

<p>自操作通常有两种位置关系: 自操作符号可以出现在变量之前或者之后
$a++;   //后置++: 先将自己预留出来(保留原来值),给其他运算, 然后自己自增
++$a;   //前置++: 先改变自己, 再将改变后的自己参与其他运算</p>

<p>前置和后置的区别</p>

<p>自操作过程中如果有多次参与其他运算: 每次都会单独改变自己并且影响后续的自己的使用(前置与后置区别依然存在)</p>

<p>自操作通常用于循环变量控制,而不是用于算术运算.</p>

<p>面试题: 将变量引用传递给另外一个变量,然后再进行自操作运算</p>

<p>位运算符
位运算: 针对位进行操作(位只有两种状态: 0和1), 操作的结果必然也是0和1
程序猿不是直接操作位, 而是通过十进制对数据进行”位运算”(计算机内部自动将十进制转换成二进制), 运算的结果页是二进制(计算机又会将结果转换成十进制给用户)</p>

<p>位运算符
按位与(&amp;): 两个位进行与运算: 如果两个都为1,那么结果为1,否则为0</p>

<p>按位或(|): 两个位进行或运算: 如果有一个1,则为1,否则0(两个位都为0)</p>

<p>按位异或(^): 两个位进行比较, 如果不同则为1,否则0</p>

<p>按位取反(~): 对位上的数据进行取反操作: 1变成0, 0变成1</p>

<p>按位左移(&lt;&lt;): 将所有的位顺序向左移动,左边移出的丢失,右边空出来的补0</p>

<p>按位左移称之为乘2操作</p>

<p>按位右移(&gt;&gt;): 将所有的位顺序向右移动,右边移出的丢失,左边空出来的补符号位(正数补0,负数补1)</p>

<p>按位右移称之为除2操作(向下取整)</p>

<p>十进制转二进制: 方案1: 辗转相除法: 将十进制数据一直除2,每次都会有余数(0或者1)直到除尽, 将余数的结果从下向上进行从左向右的排序: 结果就是对应的二进制(补足32位:左边补0)</p>

<p>十进制转二进制:方案2: 2的N次方: 将整个数值变成2的最大的次方(但是不能超过数值大小),将剩余的十进制数据继续求最大的2的N次方,直到剩余的数据为0: 最后从最右边开始向左边开始定义位: 从左右边开始依次从0开始,如果刚好对应的位置上有之前求出来的2的N次方,结果为1,否则为0</p>

<p>计算机整数存储规则: 原码,反码和补码
计算机中: 正数存的就是十进制转换成二进制本身(正数的原码,反码和补码一样); 负数存储的是补码,不是原码
原码: 十进制的数据的绝对值转换成二进制
反码: 在原码的基础上进行取反操作, 符号位不变
补码: 在反码的基础上进行+1操作</p>

<p>存储规则的原因: 从计算机的角度存在+0和-0</p>

<p>代码执行结构
代码的执行结构分为三种: 顺序结构, 分支结构和循环结构</p>

<p>默认的代码的执行结构一定是顺序结构: 从上向下逐条语句的执行.</p>

<p>分支结构
分支结构: 选择性的执行某段代码
计算机通过条件判断(程序猿给的), 选择执行程序猿提供的代码块(多行代码)</p>

<p>分支结构分为两种: if分支和switch分支</p>

<p>If分支
If分支,是指通过if进行条件判断, if能够对任何条件进行判断(大于,小于,等于,全等于)</p>

<p>最简if
If(条件表达式){
要执行的代码块;
//如果符合条件: 执行代码块; 如果不符合就不执行
}</p>

<p>标准if
If(条件表达式){
//满足条件要执行的语句
}else{
//不满足条件要执行的语句
}</p>

<p>复杂if
If(条件表达式1){
//满足1所要执行的代码块
}elseif(条件表达式2){
//满足2索要执行的代码块: 不满条件1
}else if(条件表达式3){
//满足3所要执行的代码块: 不满足条件1和2
}......else{
//不满足所有条件要执行的代码块
}</p>

<p>如果要实现分支: 那么必须条件应该渐变(不应该跳跃): 条件判断是顺序从上往下判断</p>

<p>如果if或者else或者任何条件判断之后只有一条要执行的语句,那么理论上可以省略大括号</p>

<p>建议: 如果是简单if结构,可以这么写,如果是有else或者复杂if else建议使用大括号</p>

<p>注意事项: 如果有if和else或者elseif存在,不要将else或者elseif与前面的大括号离的太开</p>

<p>Switch分支
主要是针对具体的值进行分支判断: switch中其实本质制作 == 比较操作
凡是switch能做的事情,if一定能做;但是if能做的事情,switch不一定能做(如果使用比较的时候,switch会出错)</p>

<p>Switch(条件){
Case 具体的值1: //条件 == 具体的值1
满足条件的代码
Break;  //跳出switch分支: 不再向下执行
Case 具体的值2:
...
Break;
Default:
//不满足所有条件时执行的代码
Break;
}</p>

<p>如果某个case没有使用break: 那么下一个case的条件就会直接跳过(不再进行判断)从而直接执行下一个case的语句</p>

<p>Switch中case不一定要按照顺序,可以随机</p>

<p>循环结构
循环也称之为迭代(iterate): 指的是在某个条件限定范围内, 代码会自动的重复的执行</p>

<p>循环一般都有几个条件规定: 初始化条件, 边界条件, 条件变更</p>

<p>PHP中循环有以下几种: for循环,while循环,do-while循环,foreach循环</p>

<p>Foreach循环
Foreach是php中特有的循环体系, 主要是针对复合数据类型进行遍历操作使用.</p>

<p>For循环
For循环: 将循环初始化条件,边界条件,循环变更都放到循环条件中的循环
For(初始化条件 ; 边界条件判断; 条件变更){
//循环体
//初始化条件中可以有多条语句: 使用逗号”,”分离
}</p>

<p>For循环执行顺序
For(①;②;③){
④
}
执行过程
1.  执行初始化条件: ①,整个循环执行一次(一定会执行)
2.  判断条件是否满足边界条件: ②
i.  满足条件: 执行④
ii. 不满足条件: 循环结束
3.  执行完循环体之后,进行条件变更: 执行③
4.  条件变更可能导致不满足边界: 回到②</p>

<p>For循环中: 三个条件可以一个都没有</p>

<p>For嵌套循环: 输出九九乘法表
因为九九乘法表是二维表: 一个循环只能要么输出行,要么输出列: 需要两个循环嵌套: 一个控制行,一个控制列</p>

<p>While循环
While循环: 在循环的外部进行条件初始化, 进行循环条件判断,在循环内部(循环体)修改循环条件.
定义条件;
While(条件判断){
//循环体
//变更循环条件
}</p>

<p>While循环实现嵌套输出九九乘法表</p>

<p>Do-while循环
Do先做的意思: do-while本质跟while一样: 区别在于do-while一定会执行至少一次循环体</p>

<p>初始化循环条件;
Do{
//循环体
//变更循环条件
}while(条件判断);</p>

<p>循环控制
在循环的内部通过条件判断: 决定是否继续执行循环体或者整个循环.</p>

<p>循环内部有两种控制方式
Continue: 剩下的循环体不再执行,循环重新来
Break: 整个循环不再执行(循环结束)</p>

<p>Continue和break实际上可以控制多层循环: 通过制定循环层数来控制
Continue 1; //控制当前循环
Break 2;    //控制第二层循环</p>

<p>模板标签
PHP代码跟HTML代码是可以互相嵌套</p>

<p>上面的形式: 但是大括号的形式非常影响html的标签模式: php为了让php代码在html中嵌入的时候符合HTML标签的特性(有开始,有结束): 定制了一套模板标签: 代替大括号
If(){
}</p>

<p>===&gt; 模板标记
If():
Endif;</p>

<p>For: for(): endfor;
While: while(): endwhile;
Foreach: foreach(): endforeach;</p>

<p>总结
运算符: 9大类(算术运算符,比较运算符,逻辑运算符,三目运算符,自操作运算符,赋值运算法, 连接运算符,错误抑制符,位运算符)</p>

<p>代码执行结构:顺序结构,分支结构(if和switch),循环结构(for,while和do-while)
模板标签: 代替大括号</p>

<p>作业: 
1.  九九乘法表(while)
2.  网页版计算器: 用户通过输入第一个数字,选择操作符号,输入第二个数字: 点击”=” 算出结果
a)  HTML里面写表单: 提交给PHP运算结果(必须实现)
b)  表单也在PHP中: 用户的输入操作都要被保留(一个脚本实现): 判断是否提交脚本(isset($_POST[‘表单名’])
3.  打印*
a)  打印实心菱形
   *</p>

<hr>

<hr>

<hr>

<hr>

<hr>

<p>*
b)  打印空心菱形: 中间的*用 代替</p>

<p>作业需求: 网页版计算器
1.  数据在提交之后还能够回显(用户输入的什么就显示什么)</p>

<ol>
<li><p>分析: 用户提交内容之后要在表单显示: 表单(HTML)与计算逻辑(PHP)应该同一个界面</p></li>
<li><p>修改表单的action, 指定表单的提交对象.</p></li>
<li><p>处理用户提交的计算请求: homework_calculator.php: 将PHP的接收数据的事情写在头部: 待会在计算完结果之后,需要在表单中显示结果</p></li>
<li><p>接收用户提交的表单数据</p></li>
<li><p>计算结果</p></li>
<li><p>将计算的结果在表单结果的input框中输出</p></li>
<li><p>将计算的php代码从脚本之后移到脚本之前: 先有结果,后才能输出结果(变量)</p></li>
<li><p>保留用户的输入记录</p></li>
<li><p>因为是同一个脚本: 当用户第一次请求的时候,不是提交数据,而是获取表单: 应该判断用户到底是提交还是没有提交才考虑是否接收数据进行计算.</p></li>
<li><p>容错处理: 当用户在输入了不合理的数据的时候(除数为0)应该提示用户</p></li>
</ol>

<p>回顾（第4天）
运算符: 对数据进行运算加工
运算符号: 算术, 比较,逻辑(短路运算),赋值,连接,自操作,三目,位,错误抑制</p>

<p>自操作: ++和--, 位置分为前后
$a = 10;
$b = 10;
Echo $a++;  //输出10, a = 11: 后置操作: 先将自己原来的值给别人用, 然后再改变自己
Echo ++$b;  //输出11, b = 11; 前置操作: 先改变自己,然后将改变后的自己参与其他运算</p>

<p>$a++;
$b++;</p>

<p>代码执行结构: 顺序结构, 分支结构和循环结构
分支结构: if分支和switch分支
循环结构: foreach,for,while和do-while: 循环控制(continue和break)
For(初始化条件;边界判断;循环条件变更){
循环体
}</p>

<p>模板标记: if, for,while,foreach: ====&gt; endif, endfor,endwhile,endforeach</p>

<p>函数
函数: 函数是一种结构, 是一种将某一些代码包裹起来, 形成一个对外的隐蔽, 可以在任意地方通过调用函数从而实现函数内部代码的执行.
函数意义: 实现代码的重复利用(复用)</p>

<p>函数分为两类: 系统函数和自定义函数
系统函数: 系统定义好的, 用户(程序猿)只需要调用即可(随时随地调用)
自定义函数: 用户自己定义, 必须先将函数加载到内存才可以调用</p>

<p>自定义函数
函数作为一种结构有几个部分: 关键字(function), 函数名(自定义), 参数列表(形参和实参), 函数体(函数所包含的代码块), 返回值(函数最终返回的结果: return)</p>

<p>函数内部的代码: 不是一堆无意义的代码,而是为了实现某个具体的功能的代码.
一个函数只是为了实现一个功能(不是多个功能)</p>

<p>定义函数
定义函数: 必须有以下几个部分: 关键字,函数名,参数列表(可选), 函数体, 返回值(可选)</p>

<p>语法
Function 函数名([参数列表]){
//函数内部所有代码都称之为函数体: 甚至包括返回值
//return 任意数据类型;
}</p>

<p>完整函数五要素</p>

<p>调用函数
不管是系统还是自定义函数,都是一样的调用方式.</p>

<p>调用语法
函数名([参数列表]);  //定义函数的时候有多少个参数,调用函数就必须传入多少个参数</p>

<p>如果函数在定义的时候有参数列表,那么调用的时候必须传入参数</p>

<p>正确调用函数: 调用时传入的参数必须与定义时需要的参数一致(调用时可以多,不能少)</p>

<p>多余的参数会被系统自动忽略: 只保留对应的参数</p>

<p>函数参数
参数分为两种: 形式参数(形参)和实际参数(实参)</p>

<p>形式参数: 在定义函数的时候指定的参数(实际上没有数据),叫做形式参数(函数内部工作的时候真实使用的参数)
实际参数: 在调用函数的时候传递的参数(实际上有数据),叫做实际参数</p>

<p>形参与实参的工作原理: 函数在调用时将实际参数的数据 赋值给形参,从而实现在函数的内部使用形参(本质是使用实参的数据)</p>

<p>内存分析实参与形参的工作原理</p>

<p>注意:
1.  函数的调用与定义的顺序无关: 函数的调用只要保证在内存中已经存在该函数即可(函数结构是在编译:加载原代码的时候进入到内存);
2.  形参是在调用函数的时候通过实参才被赋值的.</p>

<p>参数默认值
参数默认值: 有些参数需要外部传入,但是大量的时候外部可能传入的数据都一样, 可以在定义形参的时候给形参一个默认值: 用户在调用函数的时候, 可以不用传入对应的形参的实参值: 使用默认的数据作为形参的值.</p>

<p>Function 函数名(参数名 = 值){
使用形参
}</p>

<p>形参默认值不是在定义函数的时候就真正赋值: 是在调用函数的时候才赋值(形参一定是在调用的时候才有值)
形参是在函数执行检查参数的时候: 如果有形参,但是没有输入实参,才会使用默认值给形参赋值.</p>

<p>注意: 函数参数默认值(形参)一定要在没有默认值的形参之后定义,而不能在之前: 实参给形参赋值是顺序执行: 第一个实参赋值给第一个形参.</p>

<p>正确的默认值参数效果</p>

<p>参数传值方式
参数传值方式: 实参给形参赋值的方式: 变量传值有两种方式: 值传递和引用传递.
实参给形参传值的方式也有两种: 值传递和引用传递</p>

<p>值传递: 将实参的值赋值给形参: 两个变量两个值</p>

<p>引用传递: 将实参的内存地址赋值给形参: 两个变量一个值
使用方式: 在定义函数的时候,给形参增加一个地址符号(&amp;)</p>

<p>使用引用传值的时候: 实参不能是数值常量(数值或者字符串),只能是变量: (数值常量没有地址)</p>

<p>返回值
返回值: 函数将执行后的结果通过某种形式(数据类型)返回给函数调用处.</p>

<p>函数可以没有返回值: 函数一定有返回值: 如果用户在定义函数的时候没有显示的指定return返回值: 函数自动返回NULL</p>

<p>作用域
作用域: 作用的范围: 指的是变量的作用范围.</p>

<p>在php中作用域同样分为两种: 全局作用域和局部作用域
全局作用域: 又称之为外部作用域: 函数之外的位置
局部作用域: 函数内部称之为局部作用域</p>

<p>对应不同的作用域就有不同的变量类型: 
在全局作用域下定义的变量称之为全局变量(函数外部定义的变量都是全局变量);
在函数内部定义的变量称之为局部变量.</p>

<p>在PHP中,全局变量只能在全局作用域下访问;局部变量只能在局部作用域内部访问.</p>

<p>局部作用域访问全局变量
如果要在函数内部(局部作用域)访问函数外部定义的变量(全局变量): 需要变量能够突破作用域的壁垒.
解决方案1: 使用超全局系统变量:$S:自动获取所有的全局变量</p>

<p>函数内部使用$GLOBALS删除全局变量: unset($GLOBALS[‘全局变量名字’]): 使用$GLOBALS来删除全局变量就是删除变量本身</p>

<p>Global关键字
Global关键字: 将一个外部可能存在的同名的全局变量的内存地址获取过来,赋值给内部的一个与外部同名的局部变量, 从而实现两个变量(全局和局部)指向同一块内存地址: 访问的数据就是全局变量的数据.</p>

<p>因为global只是在函数内部定义了一个局部变量指向全局变量(同名)的内存地址: 删除局部变量不影响全局变量,但是修改局部变量会影响全局变量</p>

<p>Global: 如果外部没有同名的全局变量: 系统会自动创建一个</p>

<p>函数计数器: 统计函数被调用了多少次</p>

<p>静态变量
静态变量: 在函数进行加载到内存(编译)就会自动初始化的一种变量: 变量是保存在代码段, 该变量不会随着函数的执行结束而释放.</p>

<p>静态变量的意义: 跨函数共享数据(在函数的不同的调用之间共享数据)
关键字: static: 通常static修饰的变量(静态变量)会直接初始化: 初始化的代码只会在代码编译的时候执行一次.</p>

<p>静态的内存原理</p>

<p>总结
自定义函数: 函数要素(关键字,函数名,参数(形参+实参),函数体和返回值)
形参与实参的关系: 实参赋值给形参(值传递和引用传递), 默认值
作用域: 全局和局部, 跨作用域访问变量($GLOBALS和global)
静态变量</p>

<p>作业: 用函数实现打印菱形(函数可以指定层数)</p>

<p>回顾（第5天）
自定义函数: 关键字(function), 函数名, 参数列表(形参和实参), 函数体, 返回值</p>

<p>调用函数的前提: 函数结构在内存中存在</p>

<p>参数列表
形参: 定义结构的时候所指定的参数称之为形参(形参没有真实值: 调用时才有)
实参: 调用函数的时候传入的参数: 实参赋值给形参
参数传值方式
值传递: 默认的,将实参的值传递给形参(两个变量两个值)
引用传递: 在定义形参的时候使用&amp;符号, 实参的内存地址传给形参(实参必须变量: 两个变量一个值)
参数默认值: 形参给定默认值: 调用时才有可能赋值给形参(如果传入实参默认形参无效): 有多个参数的时候,有默认值的参数必须在没有默认值的参数之后</p>

<p>返回值: 函数将结果返回给函数调用处(没有return默认返回NULL): 函数只要碰到return就会结束</p>

<p>函数是一种封闭的区间: 作用域
全局作用域: 函数外部(外部作用域): 只能访问全局变量(函数外部定义的变量)
局部作用域: 函数内部(内部作用域): 只能访问局部变量(函数内部定义的变量)</p>

<p>局部作用域访问全局变量: $GLOBALS超全局预定义变量, global引入全局变量
全局访问局部变量: 利用global关键在全局变量不存在的情况下会创建全局变量</p>

<p>静态变量: 初始化一次,定义的时候就初始化(编译): 调用的时候直接访问而跳过static定义静态变量的行.</p>

<p>匿名函数
匿名函数: 没有名字的函数</p>

<p>函数调用: 通过函数名进行调用---&gt;通过函数名找到函数所在的内存地址,将函数的内部结构(代码)取出来一一执行.</p>

<p>匿名函数使用
定义匿名函数: 因为函数 没有名字(不能通过名字去找到函数): 需要通过变量保存函数的内存地址.</p>

<p>$变量名 = function(参数列表){
函数体;
返回值;
};  //本质是一条赋值语句: 需要语句结束符分号</p>

<p>调用匿名函数: 变量可以找到函数的内存地址 + 让系统将取出来的内容当做函数解析(系统只要碰到()就会当做函数处理)
$变量名(参数列表);</p>

<p>匿名函数意义
匿名函数的意义有两个: 回调函数和闭包.</p>

<p>回调函数: 有时候函数的参数需要的不止是一个具体的变量,而可能是对数据的一种加工方式(函数)</p>

<p>闭包: 在函数内部有可能需要再定义一个函数: 函数需要使用外部函数的局部变量</p>

<p>可变函数
可变函数: 一个变量的值刚好是一个函数的名字, 通过变量来找到函数的地址 + 加上括号让系统当做一个函数来识别.</p>

<p>可变函数的应用: 回调函数</p>

<p>伪类型
伪类型: 告诉大家如何在查看操作手册的时候, 进行相应的参数传递和返回值的应用.
为了让大家能够更好的去认识系统函数,使用系统函数.</p>

<p>伪类型: 伪装或者假的数据类型, 在PHP中不存在的数据类型: 修饰参数的类型或者函数的返回值</p>

<p>Mixed: 混合的, 可以是多种PHP的数据类型</p>

<p>Number: 数值型的. 整型,浮点型或者数值型字符串
Callback: 回调函数, 必须是一个用户知道的已经在内存中存在的函数的名字字符串</p>

<p>Void: 空,不需要</p>

<p>数据类型验证
在PHP中,凡是用户外来的数据(用户通过表单或者URL)提交的数据: 都需要进行验证
系统提供了对于所有数据类型的验证函数: 所有函数返回的结果都是布尔类型: 如果是对应的类型返回true,否则返回false</p>

<p>is_bool: 判断布尔类型
is_float: 判断浮点型
is_integer: 判断整型
is_object: 对象类型
is_array: 数组类型
is_string: 字符串类型
is_resource: 资源类型
is_scalar: 标量类型(整型,浮点型,布尔型和字符串型)
is_null: 为空
is_numeric: 数值型: 整型,浮点型和数值型字符串</p>

<p>Gettype: 获取数据的数据类型,返回的是字符串描述</p>

<p>Settype: 修改数据的数据类型,直接改变原数据类型</p>

<p>数据类型转换
将数据类型进行指定目标类型的转换. </p>

<p>数据类型转换分为两种: 自动转换和强制转换</p>

<p>自动转换
系统根据变量所在位置所需要的数据类型,将不合理的数据(类型不符合条件)进行自动的转换.</p>

<p>大部分的时候PHP都是自动转换(不需要人工参与)</p>

<p>如:
 if判断的时候,需要的条件是布尔类型: 当把一个非布尔类型的结果给if进行判断的时候,系统会自动进行转换</p>

<p>当系统进行某些运算的时候,系统会根据运算符进行自动的数据类型转换</p>

<p>字符串转数值条件
1.  若果字符串以字母或者下划线(非数值或者小数点)开始, 那么转换成数值0
‘.abc123’ ==&gt; 0
2.  如果字符串以数字开头: 直接读取直到遇到非数值(第一个小数点除外)
‘123abc’ ==&gt; 123
3.  如果字符串中有小数点,那么系统自动保留一个小数点
‘1.2.3abc’ ==&gt; 1.2
‘.123abc’  ==&gt;.123 </p>

<p>强制转换
程序猿通过代码对数据进行指定类型的转换</p>

<p>语法: (目标类型)$变量; 强制转换不像settype, 只会对数据的备份进行操作
Int: 整型
Integer: 整型
Bool: 布尔
Boolean: 布尔
Float: 浮点
String: 字符串
Array: 数组
Object: 对象</p>

<p>文件包含
在一个脚本中, 将一个脚本加入到当前脚本: 实现另外一个脚本内的内容可以在当前脚本被使用.</p>

<p>文件包含作用</p>

<p>作用有两种: 
代码复用: 直接使用另外一个脚本中已经存在的代码(功能)
界面布局: 通常一个网站都会有相同的UI: 头部基本一样, 底部基本一样: 将整站中相同的部分的代码单独分离出来形成文件: 在每个网页需要该内容的地方引入.
优点: 代码复用, 便于维护</p>

<p>文件包含
PHP提供了四种方式引入文件(包含文件) : include和include_once, require和require_once
四种方式的语法都是一样:
Include ‘文件路径’;     //文件包含必须要指定路径
Require(‘文件路径’);</p>

<p>文件包含原理
文件包含是在执行阶段发生的: 编译阶段不会执行;
文件包含是独立编译的: 文件里面的内容可以运行但是属于当前文件本身(在文件加载的位置将另外一个文件的代码放到该位置)</p>

<p>文件包含应用
文件包含有两种应用方式: 向上包含和向下包含</p>

<p>向上包含: 先包含文件: 为了使用被包含文件内部的内容(通常是php文件: 应用php文件中的结构:函数和类)</p>

<p>向下包含: 后包含文件: 为了自己的内容被被包含文件使用(通常是html文件: 需要在html显示数据)</p>

<p>原理分析</p>

<p>Include与require的区别
Include与require以及各自的_once都是可以实现包含文件的功能(没有任何区别)</p>

<p>Include与require的区别: 彼此进行文件包含时,如果被包含文件不存在,处理的方式不一样
Include包含不存在的文件</p>

<p>Require包含不存在的文件</p>

<p>Include与include_once的区别: include会无限价值,include_once会记忆性加载(如果文件已经加载过不会加载)
Include会一直加载</p>

<p>Include_once会记忆性加载</p>

<p>四种加载方式的选择: 大部分的时候使用include_once</p>

<p>文件路径</p>

<p>PHP进行文件包含: 通过路径找到路径下对应的与名字(本身是字符集)匹配的文件</p>

<p>路径分为两种
绝对路径: 
磁盘绝对路径: 从盘符开始: C:/windows/system32/etc/hosts
网络绝对路径: 指定的URL: <a href="http://www.baidu.com/index.php">http://www.baidu.com/index.php</a>
相对路径: 相对当前运行的脚本文件所在目录的路径
./: 当前目录
../: 当前目录的上级目录
/: 网站的根目录
默认的就是当前目录(什么都没有)</p>

<p>文件包含的时候,绝对路径和相对路径都可以实现文件包含</p>

<p>绝对路径和相对路径的区别
绝对路径不变: 一定可以找到
相对路径可变: 相对路径效率高
绝对路径包含文件</p>

<p>相对路径包含文件</p>

<p>相对路径: ./和../本质是每个文件夹下都有对应的两个文件夹: 一个叫. 和另外一个叫..
随着文件被包含,那么其对应的./和../会发生变化.</p>

<p>如果在文件包含的过程中使用了嵌套包含:A包含B,B包含C, B的相对路径(./和../)就会因为A的包含而变成A的相对路径(./和../): 所以通常使用绝对路径进行文件包含(尽量避免嵌套包含)</p>

<p>脚本终止
在某些特定情况下(如脚本数据判断失败)需要脚本不要再继续向下执行, 需要人为的让脚本停止执行.</p>

<p>让脚本停止执行有三种方式</p>

<p>Exit:直接让脚本停止执行
Die: die与exit一样
Exit; / exit(‘提示信息’);</p>

<p>Return: return在函数中表示返回到函数的调用处, 如果用在脚本中: 表示结束,返回给文件包含处.</p>

<p>Return返回数据给文件包含处</p>

<p>正是利用return能够返回一个脚本中的某些数据的功能: 利用return实现项目的配置文件</p>

<p>通常在进行脚本错误调试的时候: 都会在调试过程中使用exit/die</p>

<p>系统函数</p>

<p>不可能将PHP的所有函数讲完: PHP有5000多内置函数, 很多函数根本没有使用过.
常见的一些系统函数进行了分类: 字符串函数,时间日期函数和数学函数</p>

<p>字符串函数
Strlen: 字符串长度(字节)</p>

<p>Substr: 字符串截取函数: 从目标字符串的指定位置开始,截取指定长度的目标字符串(字节)</p>

<p>Strtolower: 将字符串全部小写
Strtoupper: 将字符串全部大写(针对英文字母)
Ucfirst: upper case首字母</p>

<p>Strrev: reverse翻转的意思,将字符串掉头(中文没有办法掉头)</p>

<p>Strpos: position位置的,获取目标字符串在字符串中的位置(从0开始)
Strrpos: right从右边开始匹配</p>

<p>Strchr: 字符串截取,从指定位置截取到最后
strrchr（获取文件后缀名）: 从右边开始匹配: 截取到最后</p>

<p>作业: 使用三种方式从给定的url中获取文件的后缀名
<a href="http://www.itcast.cn/gz/php/index.php">http://www.itcast.cn/gz/php/index.php</a>
<a href="http://www.itcast.cn/gz/php/index.php?name=123">http://www.itcast.cn/gz/php/index.php?name=123</a></p>

<p>Trim: 去除字符串两边的空格(默认), 也可以去除两边的指定的内容</p>

<p>Str_repeat: 在某个指定的位置输出重复次数某一些内容</p>

<p>Str_replace: 替换,从目标字符串中的目标位置替换某些内容</p>

<p>时间日期函数
PHP的时间日期函数很强大</p>

<p>Time: 获取当前时间的时间戳: 从格林威治时间开始的秒数</p>

<p>Date: 将时间戳转换成指定格式的时间日期:格式符号</p>

<p>使用</p>

<p>Strtotime: 将合理的字符串变成时间戳: 只要是正确的英文时间描述</p>

<p>Microtime: 获取”时间戳”,精确级别是微秒</p>

<p>数学函数
Abs: 绝对值
Floor: 向下取整: 取得比当前数值小的最大整数
Ceil: 向上取整: 取得比当前数值大的最小整数</p>

<p>Round: 四舍五入
Rand: 取得指定区间的随机数(整数)</p>

<p>mt_rand: 与rand一样,比rand效率高</p>

<p>数组
假设: 描述一个人的信息: 姓名,性别,年龄,体重等
$name = ‘孙悟空’;
$age = 500;
$gender = ‘石猴’;
$weight = 50;</p>

<p>当PHP去描述一个实体的时候,往往需要有多个信息: 一个变量只能保存一个信息</p>

<p>数组: 数据的组合, 将多个数据捆绑到一起由一个变量来指向这部分数据.</p>

<p>定义数组
PHP提供了多种方式定义数组</p>

<p>方案1: 使用array(): 将数组元素放到array后面的括号中,使用逗号分隔</p>

<p>方案2: 使用中括号将数据进行包裹</p>

<p>方案3: 通过变量+[],从外部放入元素(数组添加元素的方式)</p>

<p>PHP数组特点
1.  PHP的数组元素可以是任意数据类型
2.  PHP数组的长度是没有限制
3.  PHP数组元素是由下标(键名)和值(键值)组成的键值对
4.  PHP中数组元素的下标可以是数字也可以是字符串</p>

<p>数组分类
PHP根据数组中元素的下标的类型进行分类:分成三类</p>

<p>索引数组: 所有的下标都是数字: 默认的所有的数组都是索引数组: 系统自动分配下标:从0开始,依次递增1</p>

<p>关联数组: 所有的下标都是字符串: 需要程序猿手动分配</p>

<p>混合数组: 下标有数字也有字符串</p>

<p>数组元素的下标具有唯一性: 数组的下标是区分大小写.</p>

<p>访问数组元素
数据内部有多个元素: 通过数组下标(键名): $数组变量[‘下标’];</p>

<p>遍历数组
数组的访问本质还是通过下标: 获取到所有的下标, 通过下标取出对应的元素值.</p>

<p>For循环遍历: 数组必须是索引数组,而且下标必须连续从0开始</p>

<p>注意: 索引数组 &amp;&amp; 下标从0开始 &amp;&amp; 下标必须是连续的</p>

<p>Foreach遍历数组: foreach是PHP提供的一种专门用来遍历数组的一种循环方式
Foreach(数组变量 as [下标变量 =&gt;] 值变量){
//通过下标变量和值变量得到数组元素
}</p>

<p>Foreach原理
从内存的角度分析数组: 所有的数组内部都有一个”数组指针”, 指向数组的元素: 指针指向哪个元素就可以通过指针获取对应元素的数据(下标和值)</p>

<p>数组最后一次遍历之后,对应的键名和值的变量保存了最后一个元素的数据</p>

<p>二维数组
理论上的二维数组: 在内存中的确存在一个行和列的对应关系(二维表)
PHP中的二维数组: PHP本身没有数组, 在php的数组元素值中,刚好又是一个数组就形成了所谓的二维数组.</p>

<p>访问元素: 依然通过下标: 两层下标: 一层获取到一维数组元素值(数组),再通过一层获取到二维数组的元素值</p>

<p>遍历二维数组: 二维数组的遍历通常只要遍历一维: 第二维使用下标进行访问</p>

<p>Each函数
Each: 通过数组指针来获取数组的元素, 将数组指针下移一位: 如果数组指针不是指向一个有效的元素: 返回false: 其他时候获取到元素(下标和值),返回一个数组(四个元素: 2个索引+2个关联元素)</p>

<p>证明指针下移:再次获取</p>

<p>证明获取不到的时候返回false</p>

<p>List结构
List结构: 能够自动批量的对变量进行赋值: 从数组中去获取对应的索引下标对应的元素,将其值取出来赋值给变量.
List(变量1,变量2...) = 数组变量;
//从数组中将索引下标为0的元素的值赋值变量1,将索引为1的元素的值赋值给变量2...</p>

<p>如果目标数组中没有对应的元素,那么就会失败</p>

<p>通常list是搭配each: each获取的数组中一定会有0和1对应的下标元素</p>

<p>List搭配each可以遍历数组</p>

<p>数组比较
数组比较是比较以下内容
1.  数组长度(元素个数)
2.  比较元素的下标
3.  比较元素的值(全等比较类型)
4.  比较元素在数组中出现的顺序</p>

<p>==比较: 比较数据的值</p>

<p>===比较: 不单比元素值,还要比类型</p>

<p>数组运算
对数组进行操作: + 和合并(+的本质也是数组合并)</p>

<p>+运算: 以第一个数组(最左边)位基础, 如果第二个数组上有与第一个数组相同下标的元素: 忽略; 如果是没有的下标对应的元素: 加进来</p>

<p>Array_merge: 合并运算: 同样以左边的数组为基础: 如果后面的数组的下标有相同的(关联数组): 用后面覆盖前面. 所有的索引元素(不管是自己的还是别人的)都会重置索引保留元素.</p>

<p>回顾（第6天）
匿名函数: 回调函数和闭包
变量 = 函数定义;
变量();
可变函数: 通过变量保存函数的名字, 变量();(回调函数使用)</p>

<p>数据类型判断: is_开头,返回结果都是布尔类型: gettype和settype(会改变原来数据类型)
数据类型转换: 自动转换和强制转换:(数据类型)变量;</p>

<p>文件包含: 实现代码的复用和布局(HTML)
包含语法: include和include_once,require和require_once
包含原理: 在包含语句处去执行: 独立编译被包含文件: 执行被包含文件中的所有代码;执行完回到文件包含处.
包含形式: 向上包含(使用被包含文件中的内容)和向下包含(为了让被包含文件使用当前脚本中的内容)
B脚本: 向上包含脚本A: A中有变量和函数
B脚本: 向下包含脚本C: C中能否使用A中的变量和函数? : 可以
文件路径: 绝对路径和相对路径(./, ../和/)</p>

<p>终止脚本: exit/die, return(返回给文件包含处): 做项目配置文件</p>

<p>系统函数: 字符串, 时间日期和数学相关函数</p>

<p>数组: 数组定义,数组访问(下标),二维数组
数组遍历: for(索引数组), foreach(键值对), while(each): foreach内存原理(数组指针)
List + each: 循环
数组比较: ==和===, 比较:数组长度, 下标, 值(类型)
数组运算: + 和array_merge</p>

<p>数组
数组相关函数
Key: 获取数组当前指针所在位置的元素的键名, 如果指针位置无效,返回NULL</p>

<p>Current: 取得当前指针所在位置的元素的值,没有就返回false</p>

<p>Next: 获取当前指针所在元素的下一个元素的值, 将数组元素的指针下移一位.</p>

<p>Prev: previous前面的,与next相反</p>

<p>Prev和next: 如果指针已经移出数组(数组的末尾): 使用prev和next是没有办法将指针回到有效元素位置的.</p>

<p>End: 将指针移到数组最末尾的元素, 返回最后一个元素的值 
Reset: 将指针移到数组的第一个元素位置,返回第一个元素的值</p>

<p>array_keys: 获取所有键名,使用数组保存(索引数组: 所有的键名变成数组的值)</p>

<p>array_values: 获取所有键值,使用数组保存(索引数组)</p>

<p>使用array_keys和for循环遍历关联数组</p>

<p>数据结构模拟
数据结构: 数据存储的方式
常见的数据结构: 栈, 堆, 队列, 散列,二叉树等</p>

<p>栈: 先进后出的数据结构(First In Last Out)
队列: 先进县出的数据结构(First In First Out)</p>

<p>PHP本身不需要数据结构: PHP数据的存储都是由底层的C语言设定好的
PHP可以使用数组模拟</p>

<p>array_shift: 从数组的前边(左边),将数组元素弹出去
array_unshift: 从数组的前边添加元素
array_push: 从数组的后边(右边)将元素加入到数组
array_pop: 从数组的后面弹出元素</p>

<p>四个函数都是对原数组进行操作: 数组会因为加入元素而变长, 弹出元素而变短</p>

<p>模拟栈: 先进后出: 模拟从右边进,从右边出</p>

<p>队列模拟: 先进先出:(右边进队,左边出队)</p>

<p>字符串数组函数</p>

<p>数组是一种复合数据结构: 互联网之间或者文件内部都不能处理数组, 只能处理字符串</p>

<p>因为数组不能在互联网之间传递: 需要将数组转换成字符串
同样的: 互联网之间只能传递字符串: PHP需要处理数组</p>

<p>需要字符串和数组之间能够进行转换
Explode: 爆炸,将字符串按照某个指定的规则进行拆分,然后拆分出来的每个片段都加入一个数组中,形成一个数组</p>

<p>Implode:    粘合, 将分散的各个部分(数组元素) ,按照某个指定的规则进行拼接: 形成一个字符串</p>

<p>验证码函数
验证码: captcha, 随机组合的字符串(验证码的本质是图片)
验证码的目的: 不是为了为难用户: 为难计算机</p>

<p>如何通过数组生成验证码图片内部的随机字符串: 大写字母,小写字母和数字</p>

<ol>
<li><p>生成一个拥有全部元素(大小写+数字)的数组
通过range函数: 实现生成一个连续的数组元素:a-z, 基于ASCII码表</p></li>
<li><p>随机取出四个元素: PHP没有提供随机取元素的函数
a)  随机取出元素下标的数组: array_rand</p></li>
</ol>

<p>b)  通过下标取出值</p>

<ol>
<li> 因为array_rand会自动的排序里面的数值: 取得的随机的内容被排序: 将顺序打乱
Shuffle(): 将数组里面元素的顺序打乱,重新生成下标</li>
</ol>

<p>算法
算法: 就是通过逻辑实现数据处理的代码
算法 + 数据结构 = 程序</p>

<p>算法: 解决问题的方法(代码)</p>

<p>常见的排序算法: 对数据元素进行排序的算法: 冒泡算法, 插入算法, 选择算法, 快速排序</p>

<p>冒泡排序
 bubble sort</p>

<p>冒泡排序原理: 当一群泡(使用数组: 数据), 数据大就是大泡, 小的就是小泡: 将两个相邻的泡进行比较: 如果左边的大于右边: 交换; 否则继续下一轮比较: 一组比完之后只能出现一个大泡:  连续进行多轮(数组长度- 1轮)</p>

<p>冒泡算法代码实现</p>

<p>表单传值
表单传值意义
动态网站: 服务器与浏览器有交互(数据)</p>

<p>表单传值: 需要收集用户所输入的数据,传递给服务器(PHP)</p>

<p>表单传值方式
浏览器采用什么样的方式才能把数据传递给服务器.
数据传输: 基于HTTP协议.</p>

<p>HTTP协议提供了理论上有四种形式: GET, POST, PUT和DELETE
GET: 获取的意思, 主要是用户查询
POST: 提供数据, 增加和修改
PUT: 输入的意思, 新增和修改
DELETE: 删除的意思</p>

<p>在web2.0中几乎没有使用PUT和DELETE,使用GET和POST就已经可以实现基本的增删改查.</p>

<p>GET传值
使用get方式将数据传递给服务器</p>

<p>GET传值的理论: 是将数据绑定到URL之后,使用?与URL本身进行隔离
方案1: 直接URL: 在URL之后直接绑定数据
<a href="%E2%80%9Dwww.itcast.cn/gz/php/index.php?name=mark&amp;age=30%E2%80%9D"></a></p>

<p>方案2: 使用form表单: method使用get</p>






<p>浏览器会自动在提交的时候: <a href="http://www.itcast.cn/gz/php/index.php?name=%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5&amp;age=%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">www.itcast.cn/gz/php/index.php?name=用户输入&amp;age=用户输入</a></p>

<p>注意: 通常如果使用GET方式,不会真正提交用户输入的数据</p>

<p>POST传值
POST传值: 浏览器将数据打包进HTTP协议的包体(协议向: Content)
使用POST提交数据必须通过form表单</p>




 

<p>GET和POST区别
从理论上: GET本质是用来查询数据, POST是用来修改的数据
理论上: GET和POST本质没有区别,都可以提交数据. 上面是设计的初衷.
GET可以传值: 理论上不是为了改变服务器的数据
POST可以传值: 理论上是为了修改服务器的数据</p>

<p>从理论上讲: GET与POST从数据传递方面来讲: 没有任何区别.
1.  GET形式传参是在URL之后, 让用户可以直接看到数据(所谓不安全)
2.  GET形式传参之后会被浏览器地址栏给记住(所谓不安全)</p>

<p>服务器在后续的发展中: 有些限定了URL的长度(IE), URL越长,服务器解析越耗资源.
3.  URL长度限制为2Kb = 2048byte = 2048字符(一个字符 = 一个字节): 仅IE有
4.  POST传参没有数据大小限制: 服务器有限制大小(PHP: 8M)</p>

<p>服务器接收数据
Apache不能接收数据: 能接收URL请求
但是PHP可以: 浏览器使用GET和POST形式传递数据给服务器.</p>

<p>PHP提供了两种形式接收数据: 都是系统帮着使用不需要用户再次接收数据
$_GET: 接收所有的get方式传递的数据: 数据传输必须是键值对: name=value</p>

<p>$_POST: 接收所有的post方式传递的数据: 键值对name=value</p>

<p>服务器额外的提供一种接收数据的方式: $_REQUEST, 这是一种混合数据的方式: 自动接收所有的GET数据和POST数据
$_REQUEST接收POST数据\</p>

<p>$_REQUEST接收GET数据</p>

<p>$_REQUEST本质不接受数据: 数据是从$_GET和$_POST中取过来: 如果GET和POST都有同名数据, 数据进入到$_REQUEST就会被覆盖: 数组的下标具有唯一性</p>

<p>数据接收判断
PHP在接收浏览器提交的数据之后: 一般程序代码都会自己新建变量将数据从$_GET或者$_POST中取出来
$age = $_POST[‘age’];   //自定义变量处理数据: $_POST是数组效率低</p>

<p>如果POST数据没有age属性,那么接收就会出现代码的错误.
在获取数据之前需要判断数据是否存在.</p>

<p>判断一个内容是否存在: 存在不需要有有效数据(可以为空或者任意类型)
Isset($_POST[‘age’]): 为了保证代码的健壮性( 有可能请求是被恶意模拟的)</p>

<p>判断内容是否为空: 为空的数据没有意义
Empty(‘’): empty无法判断出空格</p>

<p>复选框提交数据
复选框: 只有被选中的复选框才会被提交</p>

<p>复选框: 通常如果是一类数据通常其name属性是一样的: 在PHP端进行数据接收的时候,因为名字一样,导致最终提交的多个数据在PHP里面只能保存一个</p>

<p>如何解决PHP接收到的数据被覆盖问题? 让PHP在接收内容发现下标是不一样(checkbox的name属性的值不应该一样)
PHP有一个特性: 只要在字符串后面碰到中括号[]: 系统就会自动的解析成数组[0],第二个就会自动[1]====&gt;数组: 在checkbox的name属性中每一个都增加一个中括号: 浏览器对[]不敏感.</p>

<p>$_POST[hobby[]] =&gt;自动变成$_POST[hobby][]二维数组, 第二维没有值: 自从从0开始使用值$_POST[hobby][0]</p>

<p>Checkbox提交的数据PHP需要保存到数据库: 数据库如何设计保存?
通常checkbox都是使用一个字段来进行保存: 将所有的checkbox选项一并保存到一个字段中</p>

<p>数据的存储是为了以后的查询: 爱好查询出来的结果是字符串</p>

<p>具体被选中的checkbox: (在数据库有存储的)给勾上,否则留空)
如何让checkbox被选中: 在checkbox中增加checked=”checked”
如何让数据库存储的对应的checkbox有checked=”checked”属性
In_array: 判断一个元素在目标数组中是否存在</p>

<p>文件上传
文件上传: 将本地的数据(文件) 上传到服务器(其他电脑)</p>

<p>文件上传条件</p>

<p>服务器条件:  服务器必须允许文件上传</p>

<p>浏览器条件: 能够上传文件(文件表单域)
 名字与文件名没有半点关系
必须使用form表单,且方式只能是post</p>

<p>文件是二进制格式: Post默认提交的数据只能是普通字符串(文件根本无法提交)
文件上传到服务器之后还是以文件形式保存: 为了方便查看上传的文件,修改文件上传的临时目录</p>

<p>默认的服务器只能接收到表单数据: 而没有接收到文件(文件根本没有上传): 文件是二进制(POST不能直接提交)</p>

<p>要实现浏览器可以提交数据: 必须告诉浏览器: 表单中包含二进制数据: form增加一个属性: enctype=”multipart/form-data”: POST可以提交字符数据和二进制数据</p>

<p>效果: 文件没有”上传”,POST也接收不到文件数据了</p>

<p>实现文件上传
默认的只要满足了文件上传的条件之后是可以实现文件上传的: 文件上传接收的动作默认是操作系统完成的(服务器的操作系统接收了文件): 都是以临时文件形式保存: 为了保证安全.</p>

<p>但是文件默认是需要PHP进行接收操作: 需要对文件进行处理,否则系统一定会在脚本执行结束之后删除临时文件: PHP应该在系统删除临时文件之前要处理文件.</p>

<p>PHP接收上传文件: 接收文件的临时信息有五个: $_FILES
文件名: name: 文件在浏览器端计算机上的原来的名字
临时路径:tmp_name: 文件上传到服务器上所在的目录的临时名字
类型: type:  MIME类型(多功能邮件扩展): text/html, image/png, image/jpg...
大小: size:  文件的大小,单位是字节
错误代码: error: 文件在上传过程中有可能不满足服务器的要求,0表示没有错误</p>

<p>因为操作系统会删除临时文件: 必须脚本执行结束之前将文件移动到某个特定的目录(文件上传目录)</p>

<p>封装上传函数
1.  单独创建一个文件: 实现文件上传的功能(函数)</p>

<ol>
<li><p>判断文件信息是否合理: 数组 + 5个元素</p></li>
<li><p>如果没有走if,说明文件合法: 不一定上传成功: 判断error属性,记录了文件的错误信息</p></li>
</ol>

<p>排除问题</p>

<ol>
<li><p>要进行文件类型限制</p></li>
<li><p>移动到指定目录</p></li>
<li><p>重命名文件: 必然要做的操作</p></li>
<li><p>在进行文件移动之前: 获取新的名字</p></li>
<li><p>测试:引用文件上传功能</p></li>
</ol>

<p>回顾(第7天)
数组函数
指针操作函数: key,current,next,prev,end,reset,array_keys,array_values
数据结构模拟: 栈(先进后出)和队列(先进先出): array_shift,array_unshift,array_push,array_pop
字符串数组转换: explode(字符串转数组), implode(数组转字符串)</p>

<p>冒泡算法
每轮冒出一个泡(最大的): 到最后: 挨个进行比较和交换(数组长度-1轮)</p>

<p>表单传值: GET(URL)和POST(包体)
接收表单: $_GET和$_POST: $_REQUEST自动包含$_GET和$_POST
Checkbox复选框
没有被选中不会被浏览器提交
一类复选框是同名: 服务器PHP接收时候会覆盖(只保留一个): 给表单名加[]
数据库如何存储: 一类复选框结果存入一个字段</p>

<p>文件上传
条件: 你情我愿: 服务器必须允许文件上传; 浏览器(POST提交, 文件表单域, form表单增加enctype=”multipart/form-data”属性)
服务器接收:  $_FILES<a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%B4%E6%97%B6%E6%8E%A5%E6%94%B6">‘文件表单域的name属性值’</a>
PHP获取到文件信息: 五要素(name,tmp_name,type,size, error)
移动临时文件: move_uploade_file(文件所在位置,移动到目标位置)</p>

<p>封装上传函数:
参数: 上传的文件信息, 文件上传路径, 文件类型限制,错误信息(引用传值)
函数体
安全检查(文件是一个合理有效的文件信息)
系统错误检查($_FILES[‘userfile’][‘error’]
文件类型检查
移动文件(文件重命名)</p>

<p>文件操作
文件操作是指广义的文件操作
广义文件: 计算机中用户所看到的的任何图标所代表的数据.(包括文件夹: 是一类特殊的文件: 保存文件的文件)
狭义文件: 保存数据内容的文件</p>

<p>文件操作的意义: PHP有时候需要从文件中获取内容或者将内容写入到文件中</p>

<p>文件夹操作
文件夹操作也称之为路径操作
文件夹读取: 读取文件夹内部的文件名
文件夹写: 增(创建文件夹),删(删除文件夹),改(重命名文件夹)</p>

<p>读取路径
文件夹的操作是一种资源操作</p>

<ol>
<li><p>得到路径资源
Opendir(有效路径): 打开一个指定的路径, 得到一个资源: 有所有当前文件夹下的文件名字(字符串)</p></li>
<li><p>读取资源数据: 读取文件名: 一次只能读取一个
Readdir(打开的路径资源): 每次读到文件名,如果读到最后会返回false(资源指针读完之后下移)</p></li>
<li><p>关闭资源
Closedir(打开的路径资源)</p></li>
</ol>

<p>遍历路径
将一个路径资源内的所有的文件名都读出来</p>

<p>在所有的资源都被读取结束之后: 指针移动到最末尾(不能读内容): 重置指针才能重新读取
Rewinddir(打开的文件资源): 将资源指针移动到首位</p>

<p>系统提供了一个简单的方式: 能够直接从路径中读取所有的文件信息,返回一个数组
Array Scandir(有效路径);</p>

<p>自定义函数实现scandir的功能</p>

<ol>
<li><p>定义一个函数: scandir功能: 给定一个路径,返回一个数组</p></li>
<li><p>得到路径内部的所有文件名: 通过资源操作</p></li>
</ol>

<p>路径操作
系统已经将操作进行了封装: 只要调用系统函数就可以实现响应的功能
file_exists: 判断文件是否存在(路径和文件都可以判断)</p>

<p>is_dir: 判断一个路径是否有效(路径)
is_file: 判断一个文件是否有效(文件)</p>

<p>Mkdir: make dir, 创建目录</p>

<p>路径如果已经存在:那么再次创建就会保存</p>

<p>Rmdir: remove dir: 删除路径</p>

<p>Getcwd: current work directory,获取当前工作目录: 当前运行的脚本所属的路径</p>

<p>Chdir: change dir: 修改当前工作目录(相对路径可以被修改)</p>

<p>Rename: 重命名</p>

<p>面试问题: 给定一个路径,遍历其目录及其子目录所有文件?
文件上传按日期分类管理</p>

<p>文件操作
对文件的读和写操作</p>

<p>PHP随着版本的变革, 提供了多种进行文件操作的方式: 两种
PHP5以后: 主要是将内容全部读入到内存
PHP5以前: 以资源形式操作</p>

<p>PHP5操作
读操作
将一个文件的所有内容一次性全部读入到内存, 得到的结果是一个字符串
String File_get_contents(文件路径);</p>

<p>File_get_contents很强大: 还可以从指定的url进行执行
File_get_contents(‘<a href="http://www.itcast.cn/gz/php/index.php%E2%80%99">http://www.itcast.cn/gz/php/index.php’</a>);</p>

<p>File()自动将读取的结果内容:按照行进行分离,返回一个数组:可以用file()函数解析</p>

<p>写操作
同样的: PHP5将写操作已经融入到一个函数里面
File_put_contents(文件路径,内容[,写入方式]);</p>

<p>默认的file_put_contents是对文件内容进行覆盖: 如果已经有内容,会先被清空,后写入新的内容: file_put_contents的第三个函数来进行控制
FILE_USE_INCLUDE_PATH: 先将文件内容清空后追加(默认操作)
FILE_APPEND: 在文件内容后面追加</p>

<p>PHP4操作
PHP4操作: 以资源形式进行操作</p>

<p>读取操作
1.  获取文件资源
资源 Fopen(文件路径,打开模式): 打开模式指即将对文件的操作形式</p>

<p>打开文件资源</p>

<ol>
<li> 读取内容
Fgetc: C代表character,一次获取一个字符,指针下移</li>
</ol>

<p>Fgets: s代表字符串,一次获取指定长度的字符串或者一行(最多获取一行)</p>

<p>Fread: 读取指定长度的数据</p>

<ol>
<li> 释放资源
Fclose(文件资源)</li>
</ol>

<p>写操作</p>

<ol>
<li> 打开一个资源: fopen(路径,写模式(r+,w,w+,a,a+))
R模式不能打开一个不存在的文件</li>
</ol>

<p>W模式可以创建一个不存在的文件:即便是文件存在,一定为会清空文件</p>

<ol>
<li><p>写入内容
Fputs/fwrite(文件资源,要写入的内容):</p></li>
<li><p>W+模式可以读取数据
W+模式在写入内容之后,指针是在最末尾,如果直接读是读不到任何内容: 将指针移动
Fseek(资源,位置):</p></li>
<li><p>关闭资源</p></li>
</ol>

<p>文件操作相关函数
Copy(原文件路径,新文件路径): 复制,产生一个新文件</p>

<p>Unlink: 断开文件标志与磁盘的地址(删除文件)</p>

<p>Filemtime: m代表modify修改的意思: 获取文件最后的修改时间</p>

<p>Filesize: 获取文件大小(字节单位)</p>

<p>Fileperms: permission权限的意思,获取文件的操作权限(windows下).</p>

<p>文件下载</p>

<p>文件要实现下载有两种方式: a链接和PHP文件下载</p>

<p>A链接下载
将文件绑定到a链接上的href之后, 用户一点击就会下载</p>

<p>前提: 文件的格式浏览器不认识(html,txt)</p>

<p>A链接下载的缺点
1.  文件格式有要求: 浏览器不能识别
2.  会暴露文件所在的真实路径(不安全)
3.  文件的真实名字也会暴露</p>

<p>PHP文件下载
文件下载的本质: 服务器将文件读入到内存, 然后发送给用户(浏览器): 用户接收所有内容之后,按照指定的格式进行文件命名: 然后寻找操作系统的相关的软件进行打开.</p>

<p>PHP实现下载的原理: 读取文件内容,直接输出给浏览器</p>

<p>为实现下载: PHP要做两件事情
1.  告诉浏览器当前给的内容是流式文件(数据),不需要浏览器解析
Header(“Content-type: application/octet-stream”);
2.  告诉浏览器: 对内容拿到之后应该以附件形式进行处理,建议使用指定名字
Header(“Content-Disposition: attachment; filename=建议的名字”);</p>

<p>PHP下载优点
1.  任意类型的文件都可以实现下载
2.  不会暴露文件在服务器的真实路径(避免外部的攻击)
3.  可以随意对文件进行命名: 掩盖文件的真实性</p>

<p>作业: 做一个站点统计器
1.  每一个用户访问的时候: 提示: 当前网页一共有多少用户访问过?当前用户是第几个用户?当前用户一共访问了多少次?
2.  提示: 每一个用户的每次访问都存放到文件: 独占一行(file)</p>

<p>递归
迭代: 循环
递归: 函数自己在内部调用自己.</p>

<p>递归本质: 当一个函数去解决一个大问题(遍历文件夹), 在执行过程中发现,有子问题(子文件夹),规模大问题小: 小问题称之为子问题与父问题本质一样, 解决父问题的方法(函数)能够用来解决子问题: 在函数的内部调用函数自己称之为递归.</p>

<p>递归有两个要素
递归点: 如果碰到子问题, 子问题称之为递归点(遍历出来的文件是文件夹)
递归出口: 如果函数不再进行调用: 递归出口(不是文件夹: 整个文件夹遍历完都没有文件夹)</p>

<p>遍历文件夹及其子目录</p>

<ol>
<li><p>写一个函数: 遍历出当前指定文件夹内的所有文件: 文件夹使用绿色,文件使用红色</p></li>
<li><p>如果碰到的是文件夹: 应该调用一个能够遍历出一个文件夹下的所有文件的函数来执行</p></li>
</ol>

<p>作业: 递归遍历文件夹及其子目录的时候: 实现子目录的所有内容(文件夹和文件)有缩进(递归缩进)</p>

<p>回顾（第8天）
文件操作: 路径操作和文件操作
路径读操作: 获得资源opendir; 读取资源readdir; 关闭资源closedir
路径写操作: 创建文件夹(mkdir), 删除路径(rmdir) 和修改(rename)
遍历文件夹: while循环, scandir
遍历文件夹及其子目录
1.  遍历出当前指定目录中的所有元素
2.  遍历出的文件中有可能是文件夹(.和..除外): 内部有子文件: 调用自己
递归: 函数内部调用自己
递归点: 在处理的过程中发现子问题跟父问题一致(规模较小): 函数调用自己
递归出口: 保证函数不是永无止境的调用自己: 有的情况下会让函数结束</p>

<p>文件操作
PHP5操作: file_get_contents(获取数据),file_put_contents(写入数据),file(读取数据)
PHP4操作: 打开资源(fopen: 打开模式), 写入数据(fwrite/fputs)/读取数据(fgetc/fgets/fread), 关闭资源(fclose)
文件相关操作: 复制(copy), 删除(unlink), 文件最后修改时间(filemtime)
文件下载: 本质将文件已字符串形式发送给浏览器,让浏览器用指定格式进行保存(PHP直接读取文件并且输出)
不让解析: header(‘Content-type:octet-stream’)
附件处理: header(‘Content-disposition:attachment;filename=建议文件名’);
中文在计算机本地是ANSI(GBK), 脚本是UTF-8: 读进来之后进行转换(iconv)</p>

<p>数据库课程体系
PHP学习阶段: 将数据库学习分为三个阶段
数据库基础知识: SQL的基本操作, SQL编程(函数,触发器,存储过程等), 高级SQL操作(视图, 连接查询,子查询等): 5(SQL编程) + 1(PHP+mysql编程) + 1(PDO)
数据库高级部分: 数据库优化(分表, 分词,索引等)
数据库部署阶段: 搭建企业级数据库(负载均衡等)</p>

<p>数据库基本知识
1.  什么是数据库?
广义数据库: 存储数据的仓库, 如电话簿, excel, 买东西的清单等
狭义数据库: 高效的存储和处理数据的介质(存储数据的媒介: 磁盘和内存)
数据库名词: database</p>

<ol>
<li><p>数据库分类? 关系型数据库和非关系型数据库
关系型数据库: 数据存储在磁盘的数据库肯定是关系型数据库
非关系型数据库: 数据存储在内存介质</p></li>
<li><p>关系型数据库: (Relationship Database)
关系型数据库: 是一种建立在关系模型上的数据库.
关系模型: 数学上一套存储数据的数学模型. 关系模型拥有三个部分
数据结构: 数据的存储方式(二维表)
操作指令集合: SQL, 每一次想让数据库执行相关操作,都是一条指令
完整性约束: 数据内部,数据与数据之间都有关联关系
常见的关系型数据库:
中型: mysql(AB-&gt;Sun-&gt;甲骨文),Sql-server(微软)
大型: Oracle(甲骨文),DB2(IBM)
小型: Access(微软)</p></li>
<li><p>非关系型数据库: 所有不是关系型数据库的数据库都是非关系型数据库
常见的非关系型数据库: Memcached, mongodb,redis(大型: 有数据类型区分)
菲关系型数据库在内存的存储状态: 键值对(非常类似js操作)</p></li>
<li><p>关系型数据库和菲关系型数据库的对比
a)  运行介质不一样: 关系型(磁盘),非关系型(内存)
b)  效率区别: 非关系型数据库效率要高(高得多)
c)  安全性区别: 关系型数据库安全: 有的非关系型数据库也安全(同步到磁盘)</p></li>
<li><p>关系型数据库相关关键字
数据库: database
数据: data
数据库系统: DBS(database system), 是一个总称,实际不是一个系统
DBS = DBMS + DB = Database Management System(数据库管理系统) + database(数据库)
数据库管理员:DBA(Database Administrator)
行/记录: row/record: 行是从结构入手, 记录是从数据角度入手
列/字段:column/field: 列从结构入手, 字段是从数据入手</p></li>
</ol>

<p>关系型数据库
关系型数据库: 维护的实体内部的关系, 实体与实体之间的关系.
关系型数据库数据结构: 二维表存储
实体: 自然界中能够描述的自然存在的事务</p>

<p>以教学为例进行示范: 教学系统中有以下实体
老师: 负责教学: 姓名,性别,身高,体重, 年龄, 工资等
学生: 负责学习: 姓名,性别,学号等
班级: 负责提供空间: 班级名字,教室编号等 </p>

<p>二维表本身有行和列: 一行代表一个完整数据, 一列代表以类型数据(实体内部的关系)
班级表
班级ID    班级名称    教室编号
1   Php0710 B-a203
2   Php0810 A-203</p>

<p>学生表
学生id    学号  姓名  性别  年龄
1   000001  蒋景岚   女 18
2   000002  李志豪   女 23
3   000003  罗格  女 18
4   000004  李慧泉   男 22</p>

<p>自然界中,往往实体都不是单独存在的, 与其他的实体有关联: 关联关系称之为实体与实体之间的关系
学生与班级之间存在关系: 在学生表增加一个字段用来描述该学生属于哪个班级(字段存储能够唯一区分班级的字段信息)</p>

<p>学生表
学生id    学号  姓名  性别  年龄  班级ID
1   000001  蒋景岚   女 18  1
2   000002  李志豪   女 23  1
3   000003  罗格  女 18  2
4   000004  李慧泉   男 22  2
5   000005  王鹏          1</p>

<p>二维表特点: 即便对应的位置没有数据, 也依然需要保留空间: 关系型数据库比较浪费磁盘空间.
SQL
SQL: Structured Query Language: 结构化查询语言(通称: 针对所有的关系型数据库)
SQL分为三个部分
DDL: Data Definition Language,数据定义语言: 定义结构(数据库,数据表,视图,函数等: create/drop/alter)
DML: Data Manipulation Language,数据操作语言: 数据操作(增删改查: insert/delete/update/select): 在DML中因为使用的最多的查询: DQL(Data Query language:数据查询语言: select)
DCL: data Control Language,数据控制语言: 权限控制(用户管理, 权限分配: grant/revoke)</p>

<p>SQL是针对关系型数据库,而不是针对某个具体的数据库产品: SQL本身有很多规定, 但是没有一种是明确规定必须怎么设计的(如W3C)
SQL也是一种非强制的规范: 在不同的数据库产品里, 对应的SQL指令会有一些小小的区别(但是整体是一样).</p>

<p>Mysql数据库
Mysql是一种关系型数据库: 以mysql为载体讲SQL指令.</p>

<p>Mysql是一种c/s结构软件: 必须安装客户端和服务端. 客户端去操作服务端(客户端和服务端可以不在同一台电脑上: 本机模拟分开)
SQL指令是在服务端上执行的.</p>

<p>客户端操作服务端的流程
1.  连接认证
a)  连接: IP寻找(主机地址), 端口(软件)
b)  认证: 权限判断(用户名和密码)
客户端软件mysql.exe  -hhost  -Pport  -uusername  -ppassword</p>

<p>客户端软件需要在cmd控制台下运行(已经配置过环境变量)</p>

<ol>
<li> 客户端发送SQL指令: 给服务器</li>
<li> 服务器接收SQL指令: 进行编译,执行SQL指令</li>
<li> 服务器返回执行结果</li>
<li><p>客户端接收执行结果: 显示结果</p></li>
<li><p>断开连接
Exit/quit/\q</p></li>
</ol>

<p>Mysql服务器对象
没有办法查看服务器内部到底是什么结构, 但是可以知道内部是由四层对象构成
DBMS ---&gt; DB  ---&gt; Table ---&gt; Field</p>

<p>服务器管理(windows下): 开启自启动(mysql当做windows下的一个服务管理)</p>

<p>停止/开启服务器: 找到服务, 手动关闭</p>

<p>停止/开启服务器: 使用windows提供的服务管理命令: net start/stop 服务名(CMD操作)</p>

<p>关闭服务器: 更霸道的方式: 关闭进程</p>

<p>SQL基本操作
基本操作分为三种: 库操作, 表操作(字段), 数据操作
基本操作都是对对象的增删改查
CRUD
C: create, 新增
R: retrive/read: 查询(读取)
U: update,更新(修改)
D: delete,删除</p>

<p>SQL操作基本语法: SQL是一条一条的指令, 每条指令以语句结束符结束: “;” /” \g” /” \G” 
“;”与”\g”本质效果是一样; “\G”将结果纵向显示
SQL中也有不少注释:
-- : 两个中划线 + 空格 + 注释内容(单行注释)</p>

<h1>
<a id="-单行注释" class="anchor" href="#-%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A" aria-hidden="true"><span class="octicon octicon-link"></span></a>: 单行注释</h1>

<p>/**/: 块注释
库操作
对数据库进行增删改查.</p>

<p>查看数据库
基本语法1: show databases;  -- 查看所有的数据库</p>

<p>查看语法2: show databases like ‘pattern’; -- 模糊匹配
单字符匹配: _, 匹配指定位置的一个字符
多字符匹配:%, 匹配指定位置的多个字符</p>

<p>查看语法3: 查看数据库的创建语句
Show create database 数据库名字;</p>

<p>新增数据库
创建数据库基本语法
Create database 数据库名字 [库选项];</p>

<p>库选项: 数据库的其他特性: 主要是两种
Charset 字符集: 设定数据库内部的数据存储的字符集
Collate 校对集: 设定数据库内部的数据的比较方式</p>

<p>这条语句的执行会发生什么呢?
1.  会在数据库空间中产生一个叫做mydatabase的数据库
2.  凡是创建的实体数据库都会在mysql的数据文件夹产生一个对应名字的数据库文件夹:data</p>

<ol>
<li> 在对应的数据库里面(文件夹内部)还会产生一个db.opt文件,保存了库选项: 校对集是依赖字符集存在</li>
</ol>

<p>数据库的命名规范
1.  字母,下划线和数字构成, 不能以数字开头
2.  若要使用关键字(系统已经使用)或者保留字(系统将要使用), 必须对关键字名字加上反引号(ESC键下的~对应的英文状态下的输出: `)</p>

<ol>
<li> 理论上,数据库名字支持中文: 但是需要设定字符集</li>
</ol>

<p>中文数据库建立的文件夹会是额外编码(utf8--&gt;GBK)</p>

<p>修改数据库
数据库是不能修改名字的: 只能修改数据库的库选项(字符集和校对集)
Alter database 数据库名字 新的字符集 新的校对集;</p>

<p>删除数据库
删除数据库是一种结构操作: drop
Drop database 数据库名字;  -- 一次只能删除一个数据库</p>

<p>数据库删除到底发生了什么?
1.  在库结构空间中会自动删除mydatabase数据库
2.  在数据库存储数据的文件夹下(data)将数据库对应的文件夹整体删掉: 内部的所有内容全部都被删除</p>

<p>注意: 数据库不要轻易使用drop</p>

<p>表操作
表与字段是相辅相成的, 彼此都不能单独存在: 表操作包含字段操作.</p>

<p>新增数据表
基本语法
Create table 表名(
-- 所有的字段必须要有字段类型: 限制数据的格式
字段名 字段类型(数据类型),
字段名 字段类型  -- 最后一个不需要逗号分隔
) [表选项];</p>

<p>表选项: 增加表的限制
字符集: charset 具体字符集
校对集: collate 具体的校对集
存储引擎: engine 具体的存储引擎(innodb默认的和myisam)</p>

<p>表是属于数据库的: 创建表的时候必须指定表所属数据库.
方案1: 显示的指定数据库: 在表名之前增加要指定的数据库名字.表名</p>

<p>方案2: 隐式的指定数据库: 首先进入到数据库环境: use 数据库名字;</p>

<p>方案3: 从已有表可以直接创建表: 可以省去字段的麻烦(获取结构: 不会获取数据)
Create table 表名 like 数据库.表名; -- 创建一张表象指定数据库里面的某张表</p>

<p>备份或者进行数据库迁移的时候有可能用到.</p>

<p>创建数据表的语句执行之后会发生什么呢?
1.  会在数据库环境下增加对应的数据表
2.  会在对应的数据库文件夹下创建对应的数据表结构文件</p>

<p>查看数据表
数据库的查看方式,数据表都有</p>

<p>方案1: 查看所有表: show tables;</p>

<p>方案2: 模糊匹配: show tables like ‘pattern’;</p>

<p>方案3: 查看数据表的创建语句: show create table 表名;</p>

<p>方案4: 查看表结构: desc/describe/show columns from 表名</p>

<p>修改数据表
表有自己的内容: 表名和表选项; 表还有额外的内容(字段)</p>

<p>维护表自身: 表名和表选项
修改表名: 可以修改
Rename table 旧表名 to 新表名;</p>

<p>修改表选项: 字符集,校对集或者存储引擎
Alter table 表名 [charset 字符集] [collate 校对集] [engine = 存储引擎];</p>

<p>维护字段: 字段的增删改
字段的细节操作很多
Alter table 表名 add/drop/change/modify 字段 字段类型 [位置];
位置分为两种: first和after 字段名</p>

<p>增加字段</p>

<p>修改字段: 修改字段本身(名字),修改字段的数据类型
修改字段名: change 旧名字 新名字 字段类型 [位置];</p>

<p>修改字段的数据类型: modify 字段名 字段类型 [位置];</p>

<p>删除字段: 不要字段
Alter table 表名 drop 字段名;</p>

<p>删除数据表
基本语法: drop table 表名1[,表名2...];</p>

<p>删除语句执行后到底发生了什么?
1.  数据库空间会删除对应的表;
2.  数据库文件夹对应的表结构文件(如果是myisam表会删除三个文件)</p>

<p>注: 正是因为数据表的删除会一次性的将表结构, 数据以及对应的索引全部删除: 如果是误删, 找不回来. 需要特别谨慎操作: 先备份后操作.</p>

<p>数据操作</p>

<p>新增数据
Insert into 表名 [(字段列表)] values(值列表)[,(值列表)...];</p>

<p>前提条件
1.  如果没有指定字段列表,那么值列表里面的数据的顺序必须完全按照字段的定义顺序存放</p>

<ol>
<li>凡是字符串数据都必须使用引号将值进行包裹: 单引号(所有的数据都可以使用单引号)</li>
</ol>

<ol>
<li> 如果有指定字段列表: 字段列表里面的字段顺序与定义表的时候的顺序无关: 但是要求值的顺序也要跟指定的字段的顺序一致</li>
</ol>

<p>查看数据
基本语法
Select 字段列表/* from 表名 where 条件判断;
条件判断: 是针对记录数
字段列表: 是针对字段数</p>

<p>指定字段列表: 顺序与定义的字段顺序无关</p>

<p>限制数据: where条件判断(where对每一条记录都进行条件匹配,匹配成功保留,失败就不获取)</p>

<p>修改数据
修改指定记录中的某个字段的数据
Update 表名 set 字段名=新的值[,字段名=新的值] [where条件];
如果不使用where条件限定: 修改所有数据.</p>

<p>注: 修改数据是一种不可逆的操作, 更新需谨慎(一定要带where条件限定)</p>

<p>删除数据
删除基本语法
Delete from 表名 [where条件]; -- 如果没有指定条件: 全表删除</p>

<p>注: 删除数据是不可逆的, 需要谨慎操作.(备份)</p>

<p>字符集问题
字符集基础知识
数据在计算机的最终存储一定是二进制: 但是计算机内部的存储都是字节为基本单位: 最小单位是位(bit)只有两个状态0或者1. 但是表示的数据太少, 计算机都是以字节为操作单位.</p>

<p>字符集: 字符的集合, 用户在计算机中所能看到的任何一个不可被拆分的符号.
计算机不能存储图形符号: 只能使用二进制来代表图形符号.</p>

<p>计算机的存储数据的基本单位字节: 一个字节 = 8位(bits) = 2 ^ 8种状态 = 256种</p>

<p>英文环境下: 达不到256中符号: 美国制定了一套规则: 规定了一个字节存储的二进制转换成十进制之后对应的是什么符号: ASCII: 维护了字符(英文)与二进制的一个对应关系.</p>

<p>中国以汉字为符号: 常用的汉字有5K多, 一个字节不够存储: 中国定制了一个规则: 使用2个字节来表示中文字符: 2字节 = 16位 = 256 * 256 = 65536种状态(GBK==&gt;GB2312===&gt;big5)</p>

<p>世界范围内: 除了汉字还有很多其他国家的符号, 全世界的符号加起来超过了65536种, 使用三个字节(unicode ===&gt; utf-8: 可能是2-4个字节)</p>

<p>Mysql的字符集
Mysql是c/s结构软件: 客户端----&gt; 服务端(数据)</p>

<p>数据是由客户端进入到服务端   ---&gt; 服务端将数据显示给客户端
如果客户端的数据进入到服务端的时候,两端的字符集不一样: 数据没有办法被正常理解(操作中断)</p>

<p>原因: 客户端的数据的字符集是GBK(一个汉字两个字节), 但是服务器端一定不是GBK</p>

<p>查看服务器所支持的所有字符集: show character set;</p>

<p>查看mysql服务器默认的接收数据的字符集: show variables like ‘character_set%’;</p>

<p>客户端不能插入中文数据的原因: 客户端是GBK, 服务端认为的客户端是utf8:
客户端是不能改变(固定是GBK): 修改服务端认为的客户端的字符集(服务端支持很多字符集)
Set character_set_client = GBK;</p>

<p>再次插入中文数据</p>

<p>查看数据</p>

<p>原因: 客户端是GBK,而服务端认为客户端可以解析的字符集utf8: character_set_results
修改服务端认为的客户端的解析字符集为GBK
Set character_set_results = GBK;</p>

<p>凡是使用set character_set_client%修改都是临时的(会话级别): 当前用户当次连接有效(关闭连接就失效)</p>

<p>有一种快捷方式能够直接一次性修改多个服务器端的默认的外部字符集
Set names 字符集;</p>

<p>校对集
校对: 本身的比较的意思: 校对集是一种比较的集合: 当数据进行比较的时候,会自动使用校对集来进行验证,从而实现比较效果.</p>

<p>查看所有校对集: 一个字符集会有多个校对集
Show collation;</p>

<p>校对集分为三种
_bin: binary, 二进制比较, 区分大小写
_cs: case sensitive, 大小写敏感(区分大小写)
_ci: case insensitive,大小写不敏感(不区分大小写)</p>

<p>比较: 两张表一张使用_bin一张使用_ci</p>

<p>插入数据</p>

<p>比较数据: 使用order by对字段进行排序: 比较的过程(校对集)
Order by 字段名 [asc|desc]; asc是默认的: 升序; desc是降序</p>

<p>校对集必须在表一开始的时候就设置好: 后期修改无效(如果表中已经有数据)</p>

<p>存储引擎
存储引擎: 数据在数据库存储的方式</p>

<p>Mysql提供了五种存储引擎: 其中myisam和innodb(免费); 另外三种收费</p>

<p>Innodb和myisam对比
1.  Innodb会将数据和索引统一存储到ibdata1文件; myisam会自有表数据</p>

<p>Myisam会创建三个文件: innodb只有一个文件</p>

<ol>
<li> Myisam的备份非常简单: 直接将三个文件移动到指定的数据库文件夹即可; innodb必须还要将ibdata1文件同时带走</li>
</ol>

<p>存储引擎的选择: 默认(innodb)
在oracle接收mysql之后已经停止了对myisam的支持: 只继续支持innodb.</p>

<p>乱码问题
乱码问题产生的原因: 不同的软件之间使用的字符集不一样, 解析方式不一样. </p>

<p>解决乱码问题: 将字符集统一(几乎不可能)</p>

<p>Web: 浏览器 ---&gt; 服务器(PHP) -----&gt; 数据库   解决乱码问题: 三码合一</p>

<p>站点统计功能
需求: 每访问一个,记录一次; 显示: 访问总次数, 当前用户的访问次数, 当前用户第几次访问.</p>

<p>记录: 文件(操作文件: file_put_contents,file_get_contents: file)
总访问次数: 每个用户的访问记录独占一行: 多少就代表多少访问次数
用户区别: ip地址: $_SERVER[‘REMOTE_ADDR’]</p>

<ol>
<li><p>获取用户ip信息, 写入到文件</p></li>
<li><p>统计,取出数据: file</p></li>
<li><p>统计总访问记录数</p></li>
<li>
<p>开始统计其他信息: 将用户的IP当做一个新的统计数组的下标</p>

<ol>
<li>统计当前用户的访问次数</li>
</ol>
</li>
<li><p>统计总用户数</p></li>
<li><p>当前用户是第几个</p></li>
</ol>

<p>作业: 使用递归实现阶乘</p>

<p>回顾(第9天)</p>

<p>数据库基本知识: 数据库,数据库类型(关系型和非关系型)
关系型数据库: 建立在关系模型上的数据库(关系模型: 数据结构(二维表), 数据操作指令集合(SQL), 完整性约束(字段类型))
SQL: 结构化查询语言(DDL, DML[DQL],DCL)</p>

<p>Mysql数据库(关系型数据库): c/s结构软件, 客户端访问服务端(连接认证: hPup), SQL指令永远是服务器执行(客户端发送), 客户端显示结果.</p>

<p>服务器对象: DBMS ---&gt; DB ---&gt; Table ---&gt; Field(字段内部是存储数据)</p>

<p>SQL基本操作: 库操作, 表操作(字段), 数据操作: 基本的增删改查</p>

<p>字符集问题: 数据的编码格式不一致
客户端: CMD,编码是GBK(不能改)
服务器: DBMS认为外界数据的UTF8(character_set_client): 服务器改变UTF8 -&gt; GBK</p>

<p>客户端: CMD,编码是GBK(不能改)
服务器: DBMS认为外界需要的数据是UTF8(character_set_results): 改变UTF8-&gt;GBK</p>

<p>校对集: 字符进行什么方式的比较(校对): 二进制(bin:区分大小写), 大小写敏感(cs),大小写不敏感(ci): 表后期修改校对集无效(一开始指定)</p>

<p>存储引擎: 数据的存储方式: innodb[结构文件: 数据和索引存在ibdata1]和myisam(结构,数据和索引文件)</p>

<p>乱码问题: 浏览器, 服务器(PHP), 数据库和操作系统(文件) : 都是PHP在进行管理
PHP可以指导浏览器: header和
PHP可以指定数据库: set names
PHP不能指导操作系统: 自己改变内容(iconv)</p>

<p>操作系统(ANSI:GBK): 中国.txt ---&gt; 四个字节存储: $file = ‘中国.txt’
PHP脚本(UTF-8): 读进来之后是4个字节:解析不了$file = iconv(‘GBK’,’utf-8’,$file) ---&gt;6个字节</p>

<p>字段类型
字段类型又称之为列类型和数据类型.</p>

<p>Mysql中SQL并不是一种完全的强类型语言: 但是在某些时候(表中维护字段数据的时候)可以理解为是强类型语言: 不是同类型的数据不能存入.</p>

<p>Mysql字段类型分为三大类: 数值型, 字符串型和时间日期型</p>

<p>数值型
只能存放数值数据</p>

<p>在计算机中,会严格区分整数和小数: 数值型分为两种: 整型和小数型</p>

<p>整型
用来存储整数(指定范围内的整数)
SQL中根据整数的具体应用分为了5类整数
Tinyint: 迷你整型,使用1个字节存储, 最多能存储256个数据
Smallint: 小整型,使用2个字节存储, 最多存储65536个数据
Mediumint: 中整型,使用3个字节存储
Int: 标准整型,使用4个字节进行存储
Bigint: 大整型, 使用8个字节进行存储</p>

<p>为什么要有如此多的整型呢?
根本原因: 关系型数据使用二维表存储数据, 如果某个字段没有值, 系统依然需要分配磁盘空间(关系型数据库比较浪费空间)
因为自然界的真实数据中,有很多是在某个指定的区间内部的: 如人的年龄一个字节够存; 中国的人数使用标准整型即可; 全球人数使用大整型.</p>

<p>插入数据: 数据不能达到预期的效果: tinyint: 0-255</p>

<p>在SQL中: 所有的数值类型都是有符号类型: 有正负</p>

<p>有的数据不需要负数: 无符号: 在数据类型之后使用unsigned</p>

<p>数据插入: 只能放正数,不能放负数(0-255)</p>

<p>每一种正数的数据类型之后都有一个(), 里面有一个数字: 数据长度: 默认的如果数据没有达到指定的长度的时候,系统会想办法变成对应的长度的数据, 但是又不改变数据的大小: 加前导0: zerofill: 显示长度不限定数据本身的大小(如果数据超过显示长度不管)</p>

<p>Zerofill只能针对无符号整型(正数): 不能针对负数</p>

<p>效果</p>

<p>如何选择整型数据类型?
根据需求: 具体的业务对应的数据的边界值是多少.</p>

<p>小数型
小数型: 带小数点, 小数型包含两种: 浮点型和定点型</p>

<p>浮点型
浮点型数据又称之为精度数据: 只能保证一定的数据精度(有效数字位数), 精度之外会丢失, 但是能够表示很大的数据.</p>

<p>浮点型分为两种: 单精度和双精度
单精度: float, 使用4个字节进行存储,有效数字大概为7位左右
双精度: double,使用8个字节存储,有效数字大概为15位左右</p>

<p>创建浮点数表: 精度是可以指定
Float: 表示浮点数, 没有小数的浮点数
Float(M,D): 表示总长度为M(位数), D表示小数部分的长度, 整数部分的长度(M-D)</p>

<p>插入数据: 只要在范围之内都可以</p>

<p>如果浮点数限定长度: 整数部分绝对不能超出长度,但是小数部分可以: 小数会自动进行四舍五入</p>

<p>注意: 如果是系统自动进位导致整数部分超出长度: 系统允许</p>

<p>浮点数支持使用科学计数法插入数据</p>

<p>浮点型也是默认的有符号类型.</p>

<p>定点型
定点型: 小数点是固定, 可以保证精度不丢失(整数部分)
Decimal(M,D): M表示总长度,D表示小数长度: 整数部分永远不会丢失精度, 但是小数部分有可能</p>

<p>创建表</p>

<p>插入数据</p>

<p>定点数的小数部分, 允许超出长度: 自动进行四舍五入</p>

<p>整数部分不允许超出长度: 如果是系统进位导致整数部分超出长度: 那么也不允许</p>

<p>定点数的使用: 需要精度,但是又不确定长度的数据: 如银行存款, 价格(跟钱有关)</p>

<p>时间日期型
存储时间日期信息: mysql提供了很多存储时间日期的数据类型,而且很强大.</p>

<p>Datetime: 时间日期
Timestamp: 时间戳, 表示从1970年格林威治时间开始,使用的格式不是真实时间戳,而是与datetime格式一致
Date: 天,就是datetime的date部分
Time: 既可以表示时间, 又可以表示时间段, 过去的某段时间或者将来的某段时间
Year: 年,分为两种格式: year(4)标准4位年, 1901-2155, year(2)表示从1970-2069</p>

<p>插入数据</p>

<p>Time表示是时间段: 所以可以使用时间段数据插入</p>

<p>Year字段会自动根据数据进行处理(2位年处理)</p>

<p>从PHP角度出发: 时间日期的格式具有非常大的灵活性(date函数可以任意转换), 但是mysql中的时间日期几乎都是固定: 如果从PHP角度出发, 很少使用mysql提供的时间日期类型, 几乎都是使用时间戳(整型)</p>

<p>字符串类型
保存字符串数据</p>

<p>Mysql中提供了6中字符串数据类型: char,varchar,text,blob,enum,set
Char: 定长字符
Varchar: 变长字符
Text: 文本字符
Blob: 二进制文本字符
Enum: 枚举字符
Set: 集合字符</p>

<p>定长字符串
Char(M): 会给数据分配固定的存储空间, M代表字符数, M不能超过255</p>

<p>变长字符串
Varchar(L): 给数据分配的存储空间不固定, 根据数据本身的长度来定: L表示字符数, L的理论值可以达到65536个. 但是一般认为超过255就不再使用varchar(使用text代替).
变长的varchar一定会产生一个或者两个多余的字节来保存数据原始长度</p>

<p>Char与varchar的存储对比(字符集为utf8: 一个字符 = 3个字节)
存储数据    Char(4) Varchar(4)  Char所占用空间(字节) Varchar所占用空间(字节)
Abc Abc Abc 4字符 = 3 * 4 = 12字节  3字符 = 3 * 3 = 9字节(1) = 10
Abcd    Abcd    Abcd    4字符 = 3 * 4 = 12字节  4字符 = 4 * 3 = 12字节(1) = 13</p>

<p>定长(char)与变长(varchar)区别
1.  Char所占用的空间一定是固定,一开始在分配的时候就固定, 不需要计算
2.  Varchar所占用的空间不固定, 是在数据插入的时候才会固定: 需要计算
3.  Char的效率要高
a)  数据存储时不需要计算, varchar要计算
b)  数据读取时不需要考虑长度问题(读取全部), varchar也要计算
4.  Varchar的空间使用效率更高: 不会浪费空间</p>

<p>如何选择char和varchar?
1.  如果数据长度是固定,那么一定选char: 效率问题, 如:身份证(18位), 电话号码(11位), 银行卡号等
2.  如果数据长度变化比较大, 使用varchar: 节省空间, 如:姓名, 家庭地址
3.  如果数据超过255个字符: 都不会使用char或者varchar: 使用text</p>

<p>文本类型
文本类型分为两种: 字符型和二进制型</p>

<p>字符型字符串: text
二进制型字符串: blob</p>

<p>文本类型都是用来存储较大的数据: 用户都只需指定一个类型即可: 系统会自动根据数据的长度,选择合适的文本类型.</p>

<p>实际使用中: 通常不会使用blob类型: 二进制数据通常不会存储到数据库(如图片)</p>

<p>枚举类型
枚举: 事先将可能出现的数据定义好: 以后存放的数据必须是指定的数据里面某一个数据. </p>

<p>枚举: enum(数据1,数据2,数据3...);</p>

<p>插入数据: 每个记录对应的枚举字段只能是其中定义好的某个值</p>

<p>枚举作用1: 数据规范, 规定之外的数据是不能存放到枚举字段中. 
枚举作用2: 节省空间: 枚举本身存储并不是真正的字符串,而是数字</p>

<p>Mysql中允许自动转换: 碰到相关符号的时候,数据会自动转换
只要数据是有返回值的表达式, 那么都可以使用select
‘a’ + 1 = 0 + 1 = 1;</p>

<p>证明: 枚举字段中存储的实际内容不是字符串,是数字: 将字段查出来之后 + 0操作(系统会自动转换)</p>

<p>数字占用的空间比字符要少</p>

<p>枚举的原理: 在定义的时候,会将枚举对应的字符串进行数字编号: 从左向右,依次从1开始(类似php是一个索引数组). 然后在日志表中维护一个数字与字符串对应关系的表(类似数组)。
当用户从数据库查询数据的时候： 系统先将值取出（数字），然后进入到日志中进行转换，变成对应的字符串
当用户向数据表插入数据的时候：系统会经过日志文件，找到字符串对应的数字索引，然后再插入到数据表对应的字段。</p>

<p>因为枚举字段中存储的数值，而不是字符串： 所以可以直接向表中插入数字数据</p>

<p>集合类型
集合类型是一种多选： 最原始最优解决的是复选框的问题。</p>

<p>集合：set
Set(元素1,元素2元素3...);</p>

<p>数据存放: 集合是多选数据,可以一个字段选择多个元素: 元素之间使用逗号”,”分隔
数据元素的顺序没有关系</p>

<p>集合作用1: 规范数据, 只有事先定义的元素才能存放进去.
集合作用2: 节省空间: 内部存储的又是数字而不是对应的字符串</p>

<p>实时: 数据存储是按照二进制位存储,而不是十进制数值: 原理图</p>

<p>既然存储的真实内容是数值: 同样可以直接插入数值</p>

<p>集合的范围: 最多有64个元素</p>

<p>从PHP的管理角度出发: 集合或者枚举都会存在数据操作的不确定性(数值操作), 不利于PHP对数据进行管理: PHP做网站的过程中, 很少使用这两种类型.</p>

<p>列属性
列属性: 在数据类型之外用来限制数据的一些额外的内容.</p>

<p>Mysql中的列属性有: comment(注释),NULL/NOT NULL(数据是否允许为空),Default(默认值), Primary key(主键), Unique key(唯一键), Auto_increment(自增长)</p>

<p>所有的属性描述都是在字段之后,可以有多个属性.</p>

<p>描述
描述: comment,是一种用来描述定义规则的, 给人看的</p>

<p>建议: 以后创建表的时候, 只要是非大众(id)就使用comment进行描述.</p>

<p>空
空: NULL/NOT NULL, 主要是用来限制数据(字段)是否允许为空.</p>

<p>几乎所有的字段定义之初, 默认都是允许为空的: 数据是业务产生, 如果数据为空通常没有任何意义. 在以后的设计表中尽量的让数据字段不允许为空.</p>

<p>NULL与NOT NULL能够限制数据</p>

<p>建议: 最开始尽量使用不能为空NOT NULL</p>

<p>默认值
默认值: default, 当某个字段没有进行字段数据插入的时候, 系统自动的选择一个一开始定义好的数据作为初始值(大部分的默认值都是NULL)</p>

<p>如何让默认值生效呢?
方案1: 在插入数据的时候排除当前有默认值的字段</p>

<p>方案2:在想使用默认值的字段值位置,使用default关键字</p>

<p>主键
主键: primary key, 主要的键(索引), 用来唯一的标志一条记录 ,不允许出现重复.</p>

<p>主键是一类非常特殊的索引: mysql提供了最高规格的”待遇”, 一张表只能有一个主键
增加主键
主键增加有三种方式</p>

<p>方案1: 直接在字段之后,使用primary key,让字段变成主键</p>

<p>方案2: 可以在所有字段之后,指定主键
Primary key(字段列表); </p>

<p>复合主键</p>

<p>方案3: 在表创建好之后,再增加主键
Alter table 表名 add primary key(主键列表);</p>

<p>主键作用
主键: 保证字段具有唯一性,不能为空</p>

<p>主键具有唯一性: 唯一约束</p>

<p>主键不能为空</p>

<p>复合主键: 必须多个字段都相同才重复</p>

<p>删除主键
主键不能被修改,只能先删除,在增加.
Alter table 表名 drop primary key;</p>

<p>如果是在表后期增加主键: 注意前提是保证里面对应主键的字段的数据必须没有重复的.</p>

<p>主键分为两种称呼: 业务主键和逻辑主键
业务主键: 主键字段对应的数据是有业务含义的(学号)
逻辑主键: 主键字段没有业务意义(id): 通常使用的是逻辑主键, 逻辑主键使用的字段类型通常是整型(int: 方便自增长)</p>

<p>自增长
自增长: auto_increment, 指某个字段的数据在没有或者给NULL的时候, 会自动的从以后的内容的最大值自动+1变成新值: 自增长字段对应的数据类型必须是整型.</p>

<p>自增长字段: 字段本身必须是一个索引(保证效率): 通常自增长搭配逻辑主键</p>

<p>插入数据: 自增长数据如果用户给定数据, 系统自增长不会起作用</p>

<p>自增长是从最大值+1: 自增长其实在数据插入之前就已经生成好: show create table 表名;</p>

<p>如果使用自动增长 : 下一个的值是11</p>

<p>自增长会上升到表选项: 一张表只能有一个自增长字段: 可以通过修改表选项来实现自增长值的修改: 只能比当前已有数据大不能小(小不会生效)</p>

<p>删除自增长: 自增长是字段的属性: modify,在修改字段的时候,不再保留auto_increment属性</p>

<p>自增长的初始值为什么是1? 自增长的步长为什么是1? 系统内部有变量在进行控制
Auto_increment_offset = 1;  -- 初始值
Auto_increment_increment = 1; -- 每次增加1
Show variables like ‘auto_increment%’;</p>

<p>可以修改自增长的控制: 修改都是会话级别(当前客户端当次连接有效)
Set auto_increment_increment = 5;</p>

<p>验证自增长</p>

<p>唯一键
唯一键: unique key 与主键相似: 用来保证数据的唯一性.
唯一键: 允许为空(不统计为空的数据), 唯一键可以在一张表中有多个</p>

<p>增加唯一键
与主键的增加几乎完全一致: 三种方式</p>

<p>方案1: 在字段之后直接增加唯一键: unique[ key];</p>

<p>方案2: 在所有字段之后增加唯一键
Unique key(字段列表); -- 可以有复合唯一键</p>

<p>方案3:在表创建结束之后增加唯一键
Alter table 表名 add unique key(字段列表);</p>

<p>唯一键作用
查看唯一键效果: 数据必须唯一</p>

<p>唯一键允许字段为空: 只要是为空的字段,唯一键都不进行比较.</p>

<p>删除唯一键
唯一键不可以被修改,只能被删除,后增加.
Alter table 表名 drop unique key; -- 语法错误: 不存在</p>

<p>唯一键在系统中没有逐渐的地位高: 没有特殊”待遇”, 唯一键被当成一个普通索引(index)
Alter table 表名 drop index 索引名字;</p>

<p>Mysql记录长度
Mysql规定: 一条记录最长只能是65535个字节: 所有字段的空间长度之和.</p>

<p>使用不同的字符集验证:varchar的最大长度(GBK和UTF8)</p>

<p>求出最大字符</p>

<p>Varchar的最大实现值是65533 + 2(varchar): 使用latin1: 一个字符 = 一个字节</p>

<p>NULL占用空间: 一个记录中如果有一个字段允许为空,那么NULL必须占用一个字节进行存储(多个为空: 一个字节)</p>

<p>Text文本不占用记录长度: text字段本身占用10个字节</p>

<p>回顾(第10天)
字段类型(数据类型): 三大类: 数值型, 字符串型,时间日期型
数值型: 整型(tinyint,smallint,mediumint,int,bigint)和小数型(浮点:单精度,双精度和定点:decimal)
Mysql数值默认都是有符号类型: 无符号unsigned
显示宽度: 为了让数据达到指定的宽度(不改变数据大小,不会限制长度): zerofill零填充
时间日期型: datetime,date,time,timestamp,year
字符串类型:char,varchar,text,blob, enum(十进制),set(二进制位)</p>

<p>列属性
注释描述: comment
空: NULL/NOT NULL, 默认几乎都是NULL,数据不建议为NULL(NOT NULL)
默认值: default, 不给字段提供数据;给字段使用default关键字
主键: primary key(增删改): 一张表只能一个主键, 主键不能为空: 业务主键和逻辑主键
自增长: auto_increment: 字段必须有索引, 必须是整型, 一张表一个自增长
修改自增长: 初始值,步长(系统变量); 设定自增长的下一个值(表选项); 删除自增长(字段属性)
唯一键: unique key: 可以为空, 一张表可以有多个; 有三种增加方式; 删除唯一键(普通索引: drop index 索引名字)</p>

<p>Mysql记录长度: 规定记录最长为65535个字节
Varchar的理论最大值: GBK(32766)和UTF8(21844)
NULL空间占用: 一个字节(除非没有一个允许为空的: 释放占用的一个字节)
Text: 数据不占空间(字段本身占10个字节)</p>

<p>关系
关系型数据库维护: 实体内部的联系 以及 实体与实体之间的联系</p>

<p>根据自然界的实体之间的联系: 将关联关系分为了三类: 一对一,一对多/多对一, 多对多
如何在数据表(mysql)中维护三种关系</p>

<p>一对一
一对一关系: 的确是描述实体与实体之间的关系, 认为应该是实体内部的某个具体的数据(记录)与另外一个实体内部的记录有一对一的关系.</p>

<p>学生表
Id  学号  姓名  性别  年龄  体重  籍贯  婚姻状况    家庭住址    紧急联系人
1   0001    伍千昂   男 27  130 湖南  已婚  常德  媳妇儿
2   0002    徐佳誉   女 18  80  广东  未婚  深圳  男朋友</p>

<p>大部分的时候都是访问学生的基本信息,而非不常用的信息: 将学生表进行水平分表: 从某个字段开始, 进行拆分,将不同的数据放到不同的表中
学生表(常用)
Id  学号  姓名  性别  年龄  体重
1   0001    伍千昂   男 27  130
2   0002    徐佳誉   女 18  80</p>

<p>学生表(不常用)
Id  籍贯  婚姻状况    家庭住址    紧急联系人
1   湖南  已婚  常德  媳妇儿
2   广东  未婚  深圳  男朋友</p>

<p>在学生表(常用)中的任意一条记录,在学生表(不常用)表中只能最多匹配到一条记录(反过来也一样): 这种维护的方式称之为一对一关系维护.(通常: 两张表中维护关系的字段都具有唯一性: 主键)</p>

<p>一对多
一对多: 一张表中的一条记录可以在另外一张表中找到多个匹配: 返过来: 一张表的一条记录只能在另外一张表匹配一个记录.</p>

<p>班级表
班级id    班级名字    教室
1   PHP0710 B-A203
2   PHP0810 A205</p>

<p>学生表
Id  学号  姓名  性别  年龄
1   00001   曹毅  男 23
2   00002   李正帆   男 22
3   00003   林少盈   女 18
4   00004   李桐枝   女 18</p>

<p>学生与班级存在关系: 一个班级有多个学生,一个学生属于一个班级: 是一种典型的一对多(多对一)关系</p>

<p>解决方案: 需要在一张表增加一个字段维护另外一张表的对应关系
班级表中维护学生信息(id): 会违背数据库设计的基本范式: 一个字段通常不允许拆分
学生表中维护班级信息(班级id): 在”多”表中(学生表)增加一个字段,能够指向”一”表中的唯一记录(主键: 班级id)</p>

<p>学生表
Id  学号  姓名  性别  年龄  班级id
1   00001   曹毅  男 23  1
2   00002   李正帆   男 22  1
3   00003   林少盈   女 18  1
4   00004   李桐枝   女 18  2</p>

<p>多对多
多对多: 一张表中的一条记录对应另外一张表的多条记录; 反过来一样.</p>

<p>班级表
班级id    班级名字    教室
1   PHP0710 B-A203
2   PHP0810 A205
3   PHP0912 B203</p>

<p>讲师表
讲师id    名字  性别
1   岳麓山   男
2   李莫愁   女</p>

<p>一个班级可能由多个讲师上过课, 同样的,一个老师可能给多个班级上过课(多对多)</p>

<p>解决方案: 增加一个中间表, 维护两张表之间的关系</p>

<p>中间表
Id  班级id    讲师id
1   1(PHP0710)  1(岳麓山)
2   1(PHP0710)  2(李莫愁)
3   2(PHP0810)  1(岳麓山)
4   3(PHP0912)  1(岳麓山)</p>

<p>中间表与班级表的关系: 班级表与中间表形成一个: 一对多的关系
中间表与讲师表的关系: 讲师表与中间表形成一个: 一对多的关系</p>

<p>通过中间表: 将一个多对多的关系, 变成了两个一对多的关系: 可以在多表中维护一个字段保存一表的主键字段.</p>

<p>作业1: 要求搭建一个学生管理系统数据库: 学生,老师,班级
作业2: 将基础班的项目翻新(HTML可以重用): HTML(显示数据)与PHP(业务逻辑处理)进行分离</p>

<p>范式
范式: 规范方式(表达式), Normal Format(NF), 是离散数学中一套数据的管理模式: 主要的目标是为了去除数据冗余, 实现数据的查询.</p>

<p>关系型数据库: 高效的存储和处理数据, 关系型数据库比较浪费空间.
所以关系型数据库引入了范式的概念: 能够尽可能的提升空间的利用率.</p>

<p>范式: 是一种类似W3C的一种既定规范, 但是不是强制要求.</p>

<p>范式: 就目前来说一共有6层: 从第一层到第六层,逐层严格: 若要满足下一层,必须满足上一层(想要满足第二层: 前提是第一层满足)</p>

<p>数据库中只需要遵循3层范式即可: 不需要严格到6层(效率相当低)</p>

<p>第一范式
第一范式: 1NF: 如果一张表的某个字段的数据, 在从表中取出来之后还需要进行额外的加工(查分)才能使用的话: 说明当前数据的存储不合理, 应该进行拆分后再分别存储. 将这种数据需要拆分才能使用的设计方式, 违背了第一范式: 数据字段必须具有原子性(不可再分)</p>

<p>讲师带课表</p>

<p>以上设计: 假设需要知道一个讲师的代课起始时间: 需要将代课时间字段数据取出来再进行拆分才能使用: 违背了第一范式</p>

<p>解决方案: 将代课时间进行拆分: 拆成开始和结束两个部分</p>

<p>第二范式
第二范式: 2NF, 如果一张表存在复合主键(多个字段构成), 但是表中的其他字段并不是完全依赖整个主键, 而只是依赖主键的部分(某个字段) , 这种时候, 该字段对主键的依赖就存在了部分依赖: 第二范式: 取消部分依赖.</p>

<p>讲师带课表</p>

<p>其中: 两个带P的组成了主键(复合主键)
但是: 性别不依赖主键, 只受讲师限制(只依赖讲师); 同样的教室依赖班级: 以上两种, 有字段依赖复合主键中的部分字段, 形成了部分依赖: 不满足第二范式.</p>

<p>解决方案: 取消复合主键, 就不再满足第二范式的基本需求, 不再可能出现部分依赖. 增加逻辑主键解决. </p>

<p>第三范式
第三范式: 3NF, 如果一张表中有一个字段,是依赖主键的, 但是又有另外一个字段不是直接依赖主键, 而是通过某个非主键字段依赖主键: 把这种通过非主键字段依赖主键的形式称之为传递依赖. 第三范式: 取消传递依赖.</p>

<p>讲师带课表</p>

<p>以上表中: 讲师和班级,代课时间,开始和结束时间都依赖主键ID(ID代表的是讲师和班级的复合主键): 性别是通过讲师依赖id, 教室是通过班级依赖id: 形成了传递依赖.</p>

<p>解决方案: 将这种存在传递依赖的字段全部单独取出形成一个新表,然后在需要使用的地方,使用新表的主键字段.</p>

<p>如果在考虑磁盘空间使用的情况下还要去保证效率: 有时候会为了选择效率, 而故意增加磁盘数据冗余.
逆规范化
逆规范化: 明明知道数据可以被查出来, 但是还是不采用查询方式,而是直接将数据写入到对应的表中.</p>

<p>在需要通过id进行查询的位置: 不使用ID而是直接使用对应的需要的字段数据(讲师名字)</p>

<p>虽然存储空间多了(数据冗余), 但是查询的时候可以直接查一张表就可以(效率提高)</p>

<p>数据库的合理设计: 在进行一效率和空间使用率的博弈.</p>

<p>外键
外键也称之为外键约束: foreign key
外键: 外面的键, 一张表的一个字段(非主键)指向另外一个表的主键, 那么该字段就称之为外键.</p>

<p>外键所在的表称之为子表(附表); 外键所指向的主键所在的表称之为父表(主表)</p>

<p>增加外键
将一个表的字段与另外一张表的主键进行关联(实体与实体之间的联系)</p>

<p>增加外键有两种形式</p>

<p>方案1: 在创建表的时候就增加外键: 在表字段之后使用foreign key
Foreign key(外键字段) references 主表(主键);</p>

<p>方案2: 在创建表之后增加外键: 指定外键名字
Alter table 表名 add constraint 外键名 foreign key(外键字段) references 父表(主键字段)</p>

<p>查看指定的外键名</p>

<p>外键增加的基础条件: 外键字段必须与引用表(父表主键)的数据类型严格保持一致</p>

<p>删除外键
外键不能被修改,只能先删除后新增.
Alter table 表名 drop foreign key 外键名;</p>

<p>外键作用
外键也称之为外键约束: 主要作用在于对数据进行约束.</p>

<p>约束1: 外键对子表的数据写操作约束: (增加和更新): 如果子表中插入的数据所对应的外键在父表不存在: 不能成功.</p>

<p>约束2: 外键对父表也有数据约束: 当父表操作一个记录,但是该记录被子表所引用的时候,那么父表的操作将会被限制(更新: 主键和删除)</p>

<p>外键约束
外键约束: 可以通过在建立外键的时候, 对外键进行约束控制.</p>

<p>约束控制有三种模式
严格模式: district(默认的)
置空模式: set null,对子表的限制: 当父表删除一个被子表引用的记录的时候,会自动的将子表中对应的父表引用(外键)设置成NULL
级联模式: cascade, 级联操作: 当父表对一个被子表引用的数据进行操作的时候,会自动的连带更新子表对应的数据.(更新操作)</p>

<p>模式设定语法: 在外键增加之后(foreign key(外键字段) references 父表(主键)),增加on关键字, 指定操作方式和约束模式. 一个常用的约束模式如下
On update cascade   -- 级联操作: 父表更新,子表跟着变
On delete set null;  -- 父表删除, 子表置空 </p>

<p>更新父表主键</p>

<p>删除父表记录</p>

<p>外键要增加成功的前提条件
1.  子表的外键字段的数据类型必须与父表的主键的字段类型要一致
2.  如果想要在父表进行数据删除的时候, 子表对应的模式为置空: set null,前提是子表对应的外键字段允许为空
3.  如果是在表创建之后增加外键: 一定要考虑表中的数据是否满足外键条件</p>

<p>数据高级操作
所谓的高级操作: 无外乎就是增删改查.</p>

<p>新增数据
新增操作除了普通操作之外: 还有两个额外的操作: 主键冲突和蠕虫复制.</p>

<p>主键冲突
主键冲突: 当插入一条新的数据的时候,表中已经存在一条主键与当前数据的主键相同的内容.</p>

<p>解决方案有两种: 一种是更新,另外一种是替换(先删除,后增加)</p>

<p>主键冲突更新操作
Insert into 表名 values(主键值,其他字段值) on duplicate key update 其他字段 = 其他字段值;</p>

<p>主键冲突替换
Replace into 表名 values(主键值,其他字段值);</p>

<p>蠕虫复制
蠕虫: 是一种能够靠分裂繁殖的一种小虫: 一分为二
蠕虫复制: 数据成倍的增加
基本语法
Insert into 表名[(字段列表)] select */字段列表 from 表名;</p>

<p>作用1: Create table like从已有表复制结构: 但是没有数据, 就可以使用蠕虫复制将数据复制过来
作用2: 蠕虫复制可以快速的表中的数据达到指数级(数据量很大): 数据本身没有意义,在于可以测试数据表的压力, 性能测试(使用索引提升性能).</p>

<p>蠕虫复制注意事项: 如果蠕虫复制表本身有主键, 那么必须在复制的过程中剔除主键: 使用字段列表.</p>

<p>修改数据
修改数据的标准语句
Update 表名 set 字段名 = 值 [where条件];</p>

<p>高级数据的更新语句
Update 表名 set 字段名 = 值 [where条件] [limit语句];
Limit: 限制更新的记录数: limit 数字; 数字代表限制的记录数</p>

<p>删除数据
标准删除语句
Delete from 表名 [where条件];</p>

<p>高级删除
Delete from 表名 [where 条件] limit 记录数;</p>

<p>Delete删除数据: 不会修改数据表的自增长和索引</p>

<p>如果想要让自增长重置: truncate
Truncate 表名; -- 先删除表(drop), 再创建(create)</p>

<p>高级查询
标准查询
Select */字段列表 from 表名 [where条件];</p>

<p>完整查询
Select [select选项] */字段列表[字段别名] from 数据源 [where子句] [group by子句] [having子句] [order by子句] [limit子句];</p>

<p>Select选项
Select选项: 用来控制数据的重复性
All: 保存所有数据,重复的也无关(所有字段都重复), 默认的
Distinct: 去重,去掉重复记录(所有字段都重复)</p>

<p>字段别名
字段在不同的表中很有可能同名, 同名之后外部的操作就可能无法进行区分数据: 需要对字段进行重命名给外部使用.(别名是在字段数据被取出到内存之后才拥有, 不会改变磁盘本身的字段名字)</p>

<p>别名语法
字段名 as 别名;    -- as关键字
字段名 别名;   -- as关键字可以省略</p>

<p>数据源
数据源: 数据的来源: 只要能够提供一张二维表</p>

<p>普通数据源: from 表名;</p>

<p>数据源可以是一张表,也可以是多张表
From 表名1,表名2...</p>

<p>逻辑: 从左边的一张表取出一条记录与右边表中的所有记录进行匹配: 都保留; 字段数都直接左边的放左边,右边的在后面追加(右边): 这种计算方式得到的结果: 笛卡尔积</p>

<p>笛卡尔积: 是一种无效连接操作, 没有意义: 应该尽量避免笛卡尔积出现.</p>

<p>来源不是表: 而是select语句产生的临时结果: 子查询
From (select语句) as 别名; -- from只认表: 必须给结果绑定一个表名</p>

<p>Where子句
Where子句: 是一种判断: 最终where返回的结果永远是0或者1: 0代表false, 1代表true</p>

<p>Where后面的条件才是最终的判断: 
比较运算: &gt;, &lt; ,&gt;= , &lt;= , !=, &lt;&gt;, =, in, between and
逻辑运算: and&amp;&amp;, or||, not</p>

<p>In操作: (附带逻辑运算)</p>

<p>Between 左边数据 and右边数据: 操作
1.  左边数据必须小于右边数据
2.  左边数据和右边数据是闭区间</p>

<p>Where原理: 从磁盘一条一条的取出数据: 取出之后在内存真正保留之前,将记录中的某个字段取出(where条件限制) 与条件进行比较: 返回结果为1就保留到内存; 否则就放弃.</p>

<p>Where之前的操作都是在磁盘进行操作: where之后的所有操作都是在内存.(where不能操作字段别名: 字段别名是在where之后才会生成)</p>

<p>Group by子句
Group是分组的意思: group by 字段: 通过字段进行分组
分组的本意是为了统计.</p>

<p>语法规则: select * from 表名 group by 字段名;</p>

<p>分组统计: 每组只能返回一条记录(第一条记录)</p>

<p>分组的结果是为了统计: 统计函数
Count(*/字段): 统计记录数(条数)
Max(字段): 统计每组中最大的数据
Min(字段): 最小结果
Avg(字段): 分组平均值
Sum(字段): 求和</p>

<p>分组统计原理: 在系统中模拟划分多块内存(如果分组字段不一样,存放到不同的内存中), 最后统计数据的时候在不同的分组中统计,统计完结构,分别提交(汇总)</p>

<p>Count()函数统计字段的时候,只能统计不为空的字段数据</p>

<p>分组排序: 分组会自动根据group by对应的字段进行升序排序
Group by 字段 [asc|desc];</p>

<p>多字段分组: 先根据某个字段进行分组, 然后在对已经分组的数据再次进行另外的分组
Group by 字段1 [排序], 字段2 [排序];</p>

<p>回溯统计: 当每个被分的组最后统计的时候, 会向上一层根据分组字段进行一次新的统计
With rollup;</p>

<p>回顾（第11天）
关系: 数据表的设计如何体现自然界中的关联关系
一对一: 一张表中的记录在另外一张表中只能找到一条对应,返回来一样: 两张表中使用同样的主键
一对多: 一张表中的记录在另外一张表中能匹配到多个记录, 但是返回过来只是一对一: 在多表中设计一个字段指向对应的一表中的唯一性字段
多对多: 一张表中的记录在另外一张表中能匹配多个记录,反过来也一样: 利用中间表维护两张表的关联关系: 形成多个一对多的关系: 基表与中间表的关系</p>

<p>范式: Normal Format(如何设计表去除数据冗余)
1NF: 字段设计符合原子性(不可拆分)
2NF: 表中字段不存在部分依赖: 使用逻辑主键代替复合主键
3NF: 表中字段不存在传递依赖: 跟实体相关的字段应该设计一张单独的表来保存数据
逆规范化: 为了效率浪费空间</p>

<p>外键: foreign key: 一张表的字段指向另外一张表的主键</p>

<p>外键约束: 对父表或者子表的操作的时候,会有限定条件
严格模式: district
置空模式: set null
级联模式: cascade 
子表在数据插入或者更新时: 前提是父表已经存在对应的外键引用值
三种模式理论都是针对父表操作</p>

<p>高级数据操作
新增操作: 主键冲突(On duplicate key update和replace)和蠕虫复制(从已有数据产生新数据)
更新操作: 限制更新记录数(limit 数量)
删除操作: 限制删除记录数(limit)和清空表(truncate)
查询操作: 查询选项(all和distinct), 字段别名(as), 数据源(单表,多表[笛卡尔积]和子查询), where子句(比较运算,逻辑运算,like ‘固定字符串%/_’), groupby子句(分组统计,统计函数,统计排序, 多字段分组, 回溯统计)</p>

<p>高级数据操作
完整语句
Select select选项 字段列表[字段别名]/* from数据源 where子句 groupby子句 having子句 orderby子句 limit子句.</p>

<p>Having子句
Having就是与where一致: 用于做条件判断: 因为groupby会进行数据的统计分析, 那么统计分析的结果有可能不是所需结果: 需要对结果筛选.</p>

<p>几乎所有where能做的事情,having都可以做.</p>

<p>不是所有的数据都有必要进入到内存: where在进入内存之前就进行数据筛选; having是针对内存数据进行筛选: 是针对where之后的分组统计(groupby)的结果进行筛选.</p>

<p>Having主要针对是groupby操作: 凡是groupby的操作结果(统计函数),where都不能用,但是having能用.</p>

<p>字段别名是在where之后数据进入到内存的时候才有的,所以where不能使用字段别名,但是having可以</p>

<p>Order by子句
Order by: 对字段进行排序
Order by 字段 [asc|desc]; -- asc默认升序, desc是降序</p>

<p>降序: NULL永远按照最小的数据进行运算</p>

<p>多字段排序: order by 字段1 [asc|desc], 字段2 [asc|desc]...;</p>

<p>Limit子句
Limit: 限制记录数</p>

<p>用法1: 限制数量: limit 记录数</p>

<p>用法2: 限制数据同时限制起始位置: limit offset,length
Offset: 起始位置: 从查询出的多条数据中的某一条位置开始(默认第一条记录是0)
Length: 长度,从起始位置开始向后获取指定长度的记录数(如果不够不影响)</p>

<p>使用最多的地方就是分页: 每页显示的数据量是固定长度(length是固定)
Length = 2;
Offset = (Page - 1) * length
Page = 1,2,3</p>

<p>总页数 = ceil(总记录数 / 每页显示数量)</p>

<p>联合查询
联合查询: 将多个查询的结果进行合并: 记录合并(字段不会增加)</p>

<p>语法
Select语句 union [union选项] select语句 ...; -- 可以有多个union</p>

<p>要求: union前边的select语句的字段数 必须严格等于右边的select语句的字段数</p>

<p>Union选项
All: 保留所有的记录
Distinct: 去重(默认的)</p>

<p>联合查询使用order by
需求: 将所有学生按照班级分开: 两个班级: 1班按照年龄升序排序, 2班使用年龄降序排序</p>

<p>解决方案: 按照需求解决
Select * from student where c_id = 1 order by age
Union 
Select * from student where c_id = 2 order by age desc;</p>

<p>解决1: 要在union中使用order by必须将select语句进行括号包裹: ()</p>

<p>解决2: 若要order by生效,必须配合limit语句</p>

<p>联合查询意义
哪些地方会用到联合查询呢?
1.  在查询过程中,需要根据不同的条件进行查询, 将所有查询结果进行合并
2.  在数据库优化之后: 会将数据表进行分表操作(一张表存储的数据量不会太大: 太大影响效率): 最终统计的时候,需要将所有表的结果合并.</p>

<p>联合查询只要求字段数一致即可,不需要数据类型对应: 字段名都是第一条SQL语句中的字段名</p>

<p>连接查询
连接查询: 将多个表进行连接(基于字段的: 基于条件), 将符合条件的所有结果进行保留(字段一定会增加,但是记录数未必)</p>

<p>连接查询分类: 内连接, 外连接, 交叉连接和自然连接
连接关键字: join, 一定至少由两张表构成: 示例: 表1 join 表2
左表: join关键字左边的表 , 表1
右表: join关键字右边的表 , 表2</p>

<p>连接的基本原理: 从一张表中一次取出所有记录(每次取一条), 去另外一张表中进行挨个匹配: 匹配成功的就保留,失败就不要.</p>

<p>交叉连接
交叉连接: cross join: 左表的记录与右边的记录进行连接之后,全部保留: 导致的结果是: 
记录数 = 左表记录数 * 右表记录数
字段数: = 左表字段数 + 右表字段数</p>

<p>交叉连接的结果: 笛卡尔积(尽量避免)
交叉连接的存在的意义: 因为要保证结构的完整性</p>

<p>内连接
内连接: inner join, 从左表的每一条记录去匹配右边的每一条记录: 但是只有条件满足的情况下记录才会被保留, 否则不保留.</p>

<p>基本语法: 左表 [inner]  join 右表 on 左表.字段 = 右表.字段;</p>

<p>如果内连接不使用on条件: 没有条件就会变成交叉连接(笛卡尔积)</p>

<p>内连接可以使用where代替on</p>

<p>连接查询中可能因为每个都有同名字段: 查询结果中会同名: 通常需要对字段使用别名(为了简便,还会对表使用别名);</p>

<p>外连接
外连接: outer join,与内连接相似, 从左表(主表)找出每一条记录与右表(从表)中的每一条记录进行匹配: 匹配成功则保留, 匹配不成功也保留(从表对应的字段全部置空)</p>

<p>外连接分为两种: 左外连接(left join)和右外连接(right join)
左右外连接: 左表或者右表是主表(外连接记录数肯定不会少于主表记录数)</p>

<p>左外连接: left join</p>

<p>右外连接</p>

<p>右连接转换成左连接</p>

<p>不管是左连接还是右连接: 左表的数据字段一定在左边,右表的在右边</p>

<p>外连接必须使用on作为条件: 而且不能使用where替代.</p>

<p>自然连接
自然连接: natural join, 是一种自动匹配条件的连接</p>

<p>自动匹配条件: 找两张表同名字段
自然连接包含自然内连接和自然外连接</p>

<p>自然内连接
左表 natural join 右表;</p>

<p>自然连接匹配字段之后会自动合并字段</p>

<p>自然外连接
左表 natural left/right join 右表;</p>

<p>内连接和外连接完全可以模拟自然连接: 使用关键字using作为连接条件
左表 inner join 右边 using(字段列表); -- 字段列表就是两张表的同名字段</p>

<p>正是因为内连接和外连接都可以使用using关键字代替on作为连接条件: 完全可以模拟自然连接: 因此真正使用的只有内连接和外连接.</p>

<p>多表连接: A join B on 条件 left join C on 条件...</p>

<p>子查询
在一条查询语句(select) 中又出现了另外一条查询语句(嵌套出现): 把这种查询语句的内部也出现了查询语句叫做子查询.</p>

<p>子查询分类
位置分类: 根据子查询所在select语句中出现的位置
From子查询: 子查询语句跟在from之后
Where子查询: 子查询在where条件内部
Exists子查询: 子查询出现在exists里面
子查询返回结果分类: 根据子查询得到的结果进行分类
标量子查询: 子查询返回的结果是一行一列
列子查询: 子查询返回的结果是一列多行
行子查询: 子查询返回的结果是一行多列(多行)
表子查询: 子查询返回的结果是多行多列</p>

<p>标量子查询
需求: 知道班级名字(PHP0710),找出所有该班学生
1.  从学生表查询数据
Select * from student where c_id = ?;
2.  求出班级id
Select id from class where c_name = ‘PHP0710’;</p>

<p>解决方案: 将两个步骤合并: 问号占位符就是需要下面select语句的执行结果.</p>

<p>列子查询
需求: 求出所有已经在读的学生(已经分配到班级在上课的)
1.  获取学生数据
Select * from student where c_id in ?;
2.  获取所有的班级id
Select id from class; -- 一列多行</p>

<p>In表示在某个指定的集合中: any,some,all
Any: = any, 表示数据等于any集合中的任意一个即可.
Some: some与any完全一样
All: 表示全部</p>

<p>Not in, not any, not some,not all的区别</p>

<p>行子查询
需求: 找出所有学生中年龄最大,且身高最高的学生.
1.  确定数据源
Select * from student where (age,height) = ?;
2.  求出最大的年龄和最大的身高
Select max(age),max(height) from student;</p>

<p>行子查询: 需要构造行元素: 由多个字段构成的元素, 上面的age和height就构成了一个行元素(age,height) = 值(两个内容构成)</p>

<p>表子查询
需求: 找出每个班的年龄最大一个学生
1.  确定数据源
Select * from student group by c_id order by age desc;
问题相当明显: 先分组,取出每组的第一个, 取出所有结果之后按照年龄排序</p>

<p>解决方案: 在group by先排序
1.  先将数据源排序:
Select * from student order by age desc;
2.  对已经排序的数据进行group by操作
Select * from ? Group by c_id;</p>

<p>Exists子查询
判断一个内容是否存在: 本身返回的结果是0或者1, exists都是接where</p>

<p>Where exists(子查询);</p>

<p>视图
视图: view, 是一种不存在的虚拟表: 类似表但是不是表
类似表: 视图有表结构
不是表: 没有数据, 视图的数据来源都是基表</p>

<p>创建视图
视图是一种结构: create
Create view 视图名字 as select语句; -- 视图的本质是一条查询语句(查询语句中的数据源(基表)</p>

<p>视图根据基表的数量分为两种
单表视图: 基表只有一个</p>

<p>多表视图: 基表至少两个以上</p>

<p>执行了视图的创建语句之后: 到底发生了什么?
1.  会在对应的数据库的表空间中产生一个视图(表)
2.  会在数据库对应存储文件夹下产生一个结构文件</p>

<p>查看视图
视图是虚拟表: 有类似的表结构: 凡是表的查看结构所能用的都可以用在视图上面</p>

<ol>
<li><p>像表一样查看: show tables</p></li>
<li><p>查看视图结构: desc 视图名字;</p></li>
<li><p>查看创建语句</p></li>
<li><p>还可以使用view关键字</p></li>
</ol>

<p>修改视图
视图的修改与创建类似: 视图结构是从其他表获取过来: 修改的是视图的获取方式.
Alter view 视图名 as 新的select语句;</p>

<p>删除视图
Drop view 视图名字;</p>

<p>删除视图发生了什么?
1.  数据库没有视图结构
2.  数据库文件夹下也不存在对应的视图结构文件</p>

<p>使用视图
视图的使用: 与表一样的使用(主要用于查询数据)</p>

<p>视图自身没有数据: 所有的数据来源都是基于原视图内部的查询语句.</p>

<p>视图数据操作
通过视图进行数据的写操作(增删改)</p>

<ol>
<li> 多表视图(基表来源两个以上)不能插入数据, 也不能删除数据: 但是可以修改数据
插入数据</li>
</ol>

<p>删除数据</p>

<p>修改数据: 本身就是对基表进行操作</p>

<ol>
<li> 单表视图操作: 可以进行增删改, 但是要实现新增: 前提是视图必须包含基表的所有不能为空的字段
插入数据: 视图包含所有基表不为空的字段</li>
</ol>

<p>插入数据: 视图不包含全部的基表不为空的字段</p>

<p>几乎不可能通过视图对表进行数据新增操作</p>

<p>视图更新限制: with check option
当视图原本可以查看到的数据,在经过视图修改的时候,如果修改之后,视图不能查出来: 更新失败</p>

<p>视图修改: 效果验证</p>

<p>视图算法
理论上: 每一个视图都有算法</p>

<p>视图算法有三种:
Undefined: 未定义的,默认的: 但是该算法不是真正算法: 真正的执行算法只有temptable和merge: undefined是指交给系统自动选择(系统优先选择merge: 效率高)
Temptable: 临时表,表示视图对应的select语句单独执行(先)
Merge: 合并算法: 表示视图的对应的select语句不是单独执行, 而是与外部的select语句先进行合并, 后进行执行.</p>

<p>视图: create view v1 as select语句;
查询视图: select * from v1; -- select * from (select 语句) 别名;</p>

<p>需求: 求出每个班年龄最大的一个学生.</p>

<p>大部分的时候都会使用视图的默认算法: 但是如果涉及到视图与外部的select语句中有些五子句的关系顺序的时候: 一般使用temptable</p>

<p>视图意义</p>

<ol>
<li> 视图可以将复杂的SQL查询语句进行了封装: 简化了SQL语句: 从而提升了带宽的使用效率和网络间的传输效率</li>
<li> 视图的存在: 主要是为了对外提供数据支持(外部系统)
a)  隐藏基表字段(隐私)
b)  保证了数据库的数据安全(保护数据库内部的数据结构)
c)  可以灵活的控制对外的数据: 保证针对每个接口都有一个单独的数据支持: 增强了用户友好性.</li>
<li> 视图利于权限控制: 有助于数据库对权限进行管理.</li>
</ol>

<p>备份
备份: 将已有的数据或者结构进行复制保存: 以防数据或者结构出现问题: 可以从备份的数据中进行还原.</p>

<p>Mysql提供了很多中备份的方式: 文件备份, 单表数据备份, SQL备份, 增量备份(日志备份)</p>

<p>文件备份
文本备份: 直接将表对应的文件进行复制保存
Innodb: 不单要备份结构文件,还要备份整个数据文件ibdata1
Myisam: 直接三个文件(跟其他表没有任何管理)</p>

<p>还原文件的
Myisam: 直接将三个文件放到对应的数据库下即可(可以)
Innodb: 将结构文件放到数据库, 但是还要替换ibdata1文件(几乎不可行)</p>

<p>文件备份: 数据量很大</p>

<p>单表数据备份
单表数据备份: 只能一次针对一张表进行备份, 只能备份数据(结构不行)</p>

<p>备份
从表里面将数据按照规则取出来, 存储到外部文件(outfile)中</p>

<p>基本语法: 前提是外部文件不能存在(必须是自己创建)
Select 字段列表/* into outfile 文件路径 from 表名 [where条件]; </p>

<p>以上备份方式都是按照默认的方式进行处理: 可以自动选择处理方式
Select 字段列表/* into outfile 文件路径 [字段处理] [行处理] from 表名 [where条件]; 
字段处理: fields
Terminated by: 以什么结尾, 默认是”\t”
Enclosed by: 以什么进行包裹, 默认是””, 没有包裹
Escaped by:特殊字符用什么方式转义, 默认是”\”
行处理: lines
Starting by: 每行以什么开头,默认是””
Terminated by: 行以什么结尾, 默认是”\r\n”</p>

<p>还原
还原: 从文件中将数据取出塞到表里面
Load data infile 文件路径 into table 表名[(字段列表)] [字段处理] [行处理];</p>

<p>SQL备份
SQL备份: 将数据表以及数据都通过sql语句进行备份: 以后不管表存不存在都可以进行还原.</p>

<p>SQL备份不是通过mysql客户端内部执行SQL指令: 通过mysqldump.exe备份客户端</p>

<p>备份
Mysqldump.exe 连接认证(hPup) 数据库 [数据表1 数据表2...] &gt; 外部备份文件所在路径(.sql)</p>

<p>单表备份</p>

<p>多表备份: 表与表之间使用空格分隔</p>

<p>整库备份: 指定数据库名字即可</p>

<p>还原
可以将备份的SQL语句复制全部,进入到mysql数据库之后执行即可.</p>

<p>还原操作1: 使用mysql客户端进行还原
Mysql -hPup 数据库 &lt; sql备份文件</p>

<p>还原操作2: 通过SQL指令实现
Source sql文件;</p>

<p>以上几种方式备份都比较浪费空间(尤其是SQL备份)</p>

<p>增量备份
只对改变的东西进行备份: 是针对mysql的系统日志进行备份,指定备份的起始点到终点</p>

<p>数据备份: 尽量找一个用户访问量相当少的时候进行备份.</p>

<p>数据库对齐：
Mysql --default-character_set=latin1 -uroot -p</p>

<p>mysql --default-character_set=latin1 -uroot -p</p>

<p>回顾(第12天)
高级查询操作: having子句, order by子句(校对集), limit子句
联合查询: union, union选项[all和distinct], order by(括号+limit), 作用(多表查询)
连接查询: 将字段进行拼接
内连接: inner join, 两个表的记录必须匹配
外连接: left/right join, 主表的记录一定保留, 从表不存在置空
自然连接: natural [left/right] join, 自动寻找连接条件(同名字段)
交叉连接: cross join,笛卡尔积
Using关键字: 合并字段</p>

<p>子查询: select语句中出现了select
位置分类: from子查询, where子查询,exists子查询
子查询返回结构: 标量子查询, 列子查询,行子查询,表子查询</p>

<p>视图: 结构的增删改查, 数据操作(读和写), 视图算法(undefined, temptable, merge)</p>

<p>备份: 文件备份(myisam), 单表数据备份(字段处理,行处理),SQL备份(mysqldump.exe: 单表,多表,整库), 增量备份(日志备份)</p>

<p>事务操作
事务: 有多个连续操作, 是一个整体: 要么所有的操作都成功, 要么所有的操作都失败.</p>

<p>事务实现: 有两种方式
手动实现: 用户自定义事务区间, 自己对事务进行整体把握, 自己对事务进行最终处理(通过SQL指令实现)
自动实现: 用户不管事务处理, 直接执行SQL指令(操作), 系统自动帮助用户进行处理</p>

<p>事务原理
SQL指令的操作(写), 并不是直接写入到数据表: 先将操作的结果缓存起来, 到系统日志文件中, 没有同步到数据表: 然后等待所有的操作都执行完执行, 等待一条执行的指令: 选择性的将所有的结果要么都同步到数据表, 要么都清空.</p>

<p>自动事务
当用户执行完一个SQL操作,系统会自动将结果同步到数据表中.</p>

<p>Mysql服务器认为用户的操作应该简化: 不应该每次做一个操作,还需要一个额外的操作去配合: 系统将这个额外的操作给自己做(commit操作).</p>

<p>自动提交: 系统在内部通过变量进行控制
Show variables like ‘autocommit’;</p>

<p>关闭自动提交:
Set autocommit = OFF;</p>

<p>自动提交关闭之后: 系统就不会讲结果自动同步到数据表</p>

<p>自动提交被关闭之后: 需要手动提交
Commit: 提交, 将日志文件中的结果同步数据表</p>

<p>Rollback: 回滚, 清空日志文件中的结果(没有同步)</p>

<p>系统自动提交都会保留: 如果真要处理事务(多个操作连贯),会使用手动事务(SQL指令控制)</p>

<p>手动事务
手动事务: 当需要进行事务操作的时候, 发送指令告诉服务器,之后的所有操作不要直接自动提交, 一直等到客户端发送执行指令的时候才进行事务的提交(同步).</p>

<ol>
<li><p>开启事务: 告诉系统以后的操作不要同步到数据表
Start transaction;</p></li>
<li><p>事务操作: 就是对SQL指令进行执行</p></li>
<li><p>事务提交
a)  提交数据: 同步到数据表: commit
b)  回滚数据: 清空日志内容:rollback</p></li>
</ol>

<p>回滚点
事务在操作过程中,也许有很多步骤: 但是当某些步骤实现之后(都正确), 后续的操作可能容易出错, 可以选择在某些成功的操作之后设置一个回滚点: 以后操作失败了,可以回到该点继续下一步.</p>

<p>设置回滚点: savepoint 回滚点名字;</p>

<p>回滚到回滚点: rollback to 回滚点名字;</p>

<p>事务特性
事务一共有四大特性: ACID</p>

<p>A: 原子性(Atomic). 事务是一个整体, 不可拆分: 要么都成功,要么都失败.
C: 一致性(Consistency). 在事务操作的前后,对应的数据会一次性改变
I: 隔离性(Isolation). 事务的操作是独立的, 不受影响.
D:持久性(Durability). 事务的操作,一旦提交,数据就会永久性的写入到数据表, 不能回滚</p>

<p>事务一旦操作过程中,会涉及到锁机制: 一旦事务在操作的过程中,操作了某一行,那么在其他事务中,就不能对该行进行操作.</p>

<p>Innodb表的锁机制默认是行锁: 但是会因为查询条件没有索引而导致行锁升级为表锁.</p>

<p>事务条件</p>

<p>事务的应用
1.  需要多个操作连贯完整(要么都成功,要么都失败)
2.  事务的引用通常都是使用手动事务</p>

<p>事务的条件
1.  要支持事务,必须使用innodb存储引擎</p>

<p>变量
变量: 临时存储数据</p>

<p>变量分为两种: 系统变量和自定义变量</p>

<p>系统变量
系统内部已经定义好的变量: 用户只需要直接访问(使用)</p>

<p>系统提供了很多变量: 服务器对任何内容的处理(表现的任何特性)都是由变量所保存的值来确定
是否自动提交: autocommit
自增长步长: auto_increment_increment
...</p>

<p>查看所有变量: show variables;</p>

<p>在mysql中: 系统变量又分为了两类: session变量(会话级别),global变量(全局级别)
Show session variables;
Show global variables;</p>

<p>Session变量: 用户在客户端连上服务端之后才有的变量: 客户端断开,变量消失
Global变量: 只要服务器运行就会产生的变量(跟客户端没有关系).</p>

<p>查看系统变量: select @@变量名;</p>

<p>修改系统变量: 会话级别和全局级别</p>

<p>会话级别修改
Set 变量名 = 值; -- 会话级别
Set session 变量名 = 值;</p>

<p>全局级别修改
Set global 变量名 = 值;
Set @<a href="https://github.com/global" class="user-mention">@global</a>.变量名 = 值;</p>

<p>全局级别的修改不会对已经连上服务器的客户端产生作用: 客户端必须重连</p>

<p>自定义变量
用户定义的变量</p>

<p>定义规则: 在变量名字之前使用一个@符号
Set @自定义变量名 = 值;</p>

<p>访问变量: select @变量名;</p>

<p>因为在mysql中”=”通常是认为是比较运算符,而不是赋值运算符(事实可以): 为了解决这一的矛盾: mysql开发团队定义了新的赋值符号:  :=(冒号 + 等号)</p>

<p>在mysql中,可以访问任意一个不存在的变量: 这种变量的值都是null</p>

<p>数据表获取变量</p>

<p>有两种方式能够从数据表中获取数据</p>

<p>语法1: select @变量名 := 字段名... From 表名 where条件; -- 从表中取出对应的字段的值,赋值给变量</p>

<p>以上方案特别注意: 只能使用专门的赋值符号:= 不能使用=(变成比较)</p>

<p>语法2: 专门从数据表中取出数据赋值给变量(不会显示数据)</p>

<p>特别注意: 该方式是纯粹赋值,所以必须保证select查到的记录数是1条</p>

<p>变量作用域
Mysql中变量本质分为两种: 全局变量和局部变量
对应的作用范围也分为两种: 全局作用域和局部作用域</p>

<p>全局作用域: 结构之外(函数,触发器,存储过程)
局部作用域: 结构之内</p>

<p>全局变量: 使用set 关键字 + @变量名定义的变量都是全局变量
在任何地方都可以使用
局部变量: 在结构内部定义的变量: 同时要求使用的是declare进行声明,而不是使用set @变量名)
只能在定义的结构内部使用</p>

<p>需求: 电子商务系统,有两张表: 商品表(id,名字,价格,货号,库存等), 订单表(id,订单号,商品id,时间,购买数量等)
当用户下单成功, 订单生成(商品id,商品的数量): 商品库存必须减少.</p>

<p>触发器
触发器: 事先写好一段代码, 自动的监听某些要发生的操作事件(增删改), 当某些事件发生的时候,会自动触发写好的代码.</p>

<p>触发器要素: 监听对象(表: 中的数据行), 事件类型(增删改), 事件时间(前后), 触发器名字(自定义)</p>

<p>创建触发器
事先将一段需要执行的代码维护好
一个表中只能有一个对应时间,对应类型的触发器: 一张表最多有6个触发器</p>

<p>触发时间: before和after
事件类型: insert, update 和delete</p>

<p>基本语法
Create trigger 触发器名字 事件时间 事件类型 on 表名 for each row
Begin -- 代表开始大括号{
-- 触发器的内部代码;
-- 每一条语句都得有语句结束符分号: 要不然无法正常执行
End -- 代表结束大括号}</p>

<p>在触发器构造结构的过程中: 因为触发器内部会有语句结束符,所以会中断触发器结构: 需要临时的在创建触发器的时候, 修改语句结束符(不再是分号)
Delimiter 自定义语句结束符
在创建完触发器之后: 使用自定义的语句结束符结束,再修改回来
Delimiter  ; -- 改回来</p>

<p>触发器的创建可以使用最简触发器: 触发器内部只有一条语句: 可以省略”大括号”: begin和end, 这时候也不需要修改临时语句结束符.</p>

<p>查看触发器
查看触发器的结构</p>

<p>查看所有触发器或者部分触发器: show trigger like ‘pattern’;</p>

<p>触发器存在于表中: information_schema.triggers</p>

<p>使用触发器
触发器是在定义的时候就已经为表进行绑定的: 不是手动,是当被绑定的表中发生了指定时间内的指定事件的时候, 会自动触发.</p>

<p>触发器: after insert on t_order: 在订单被插入到数据表(t_order)的时候会自动触发.</p>

<p>删除触发器
触发器不能被修改,只能先删除,后增加.
Drop trigger 触发器名字;</p>

<p>触发器记录
触发器记录: 当触发器绑定表(t_order),上面的记录发生修改时(增删改), 系统会在修改之前, 模拟将要发生之后和发生之前的结果.</p>

<p>系统提供了两个关键字来保存模拟的结果: old和new
Old: 代表的是数据要发生操作之前的结果: 插入操作没有old
New: 代表是数据要发生操作之后的结果: 删除操作没有new</p>

<p>Old和new都是在触发器的内部使用: old/new.字段名: old.num代表原订单的商品数量, new.num代表更改之后的订单的对应商品数量.</p>

<p>插入订单看商品数据</p>

<p>触发器对应的事件的操作与被绑定表的记录是同时生效的: 要么都成功,要么都失败.</p>

<p>如何通过触发器阻止不合理的数据的操作的发生呢?暴力</p>

<p>函数
Mysql中函数有两种: 系统函数和自定义函数
在mysql中,函数必须有返回值: 所以凡是有结果的内容都是由select去访问</p>

<p>函数调用: select 函数名(参数列表);</p>

<p>系统函数
在mysql中所有的字符串操作单位基本都是字符</p>

<p>Substring: 子字符串截取</p>

<p>char_length: 字符长度
Length: 字节长度</p>

<p>Instr: 在什么里面</p>

<p>Lpad: 左填充: 将字符串填充到指定长度(字符数)</p>

<p>Insert: 字符串替换</p>

<p>Strcmp: 比较字符串</p>

<p>时间日期函数: now(), unix_timestamp()</p>

<p>自定义函数
用户自己定义函数</p>

<p>函数要素: 关键字(function), 函数名, 参数列表(形参和实参), 返回值, 函数体</p>

<p>定义函数</p>

<p>定义语法
Create Function 函数名([形参列表]) returns 返回值的数据类型
Begin
-- 函数体
-- return 返回值
End</p>

<p>查看函数
函数不能像表一样查看: 但是可以查看函数创建语句: show create function 函数名;</p>

<p>函数有另外一种方式查看所有函数: show function status  like ‘pattern’;</p>

<p>删除函数
Drop function 函数名;</p>

<p>调用函数
与调用系统函数一样</p>

<p>虚拟表: dual,为了保证select的语法结构性而存在的一个虚拟表
Select 1+ 1 from dual;</p>

<p>Mysql的布尔类型: mysql没有bool类型,但是有bool关键字(通过0和1来实现)</p>

<p>函数参数
函数的参数: 在mysql中,对函数参数的要求可以理解为强类型语言: 必须在定义函数参数(形参)指定其数据类型, 可以有多个形参
Create function test(int_1 float ,int_2 int...)</p>

<p>要求在调用函数的时候,必须传入对应的实际参数: 个数与类型都必须完全一致
Mysql函数中函数的参数,不存在引用传递(都是值传递), 也没有默认值(每个形参都必须传入实参)</p>

<p>调用函数</p>

<p>函数返回值
函数内部(函数体) 的具体返回数据,必须与结构上指定的类型相同(returns)</p>

<p>函数体
函数体没有什么特殊说明: 就是外部执行功能某一些代码进行封装.</p>

<p>局部变量: 在局部作用域定义的变量(结构内部)
Declare 变量名 数据类型 [其他属性]; -- 一个结构内部若要声明局部变量: 必须是在所有代码的最前面.</p>

<p>全局变量可以全局访问, 局部变量只能是函数内部访问.</p>

<p>作用域: 全局作用域是在任何地方可以直接访问, 局部只能在内部访问</p>

<p>代码结构
代码结构: 顺序结构, 分支结构和循环结构</p>

<p>分支结构
If分支: 根据条件进行判断</p>

<p>If语法</p>

<p>If 条件判断 then -- then表示如果满足条件
-- 满足条件所有执行的事情
Else
-- 可以再使用if进行条件判断: 有多少个if,一定有多少个end if;
-- 不满足条件所有做的事情
End if;</p>

<p>函数: 比较三个数的大小</p>

<p>注意: 如果使用比较判断的话: 没有”==”,只有”=”</p>

<p>循环结构
为了代码的重复执行.</p>

<p>While循环
While 条件判断 do
-- 循环体
-- 循环条件变更
End while;</p>

<p>需求: 求1到10之间的和</p>

<p>循环控制: mysql中没有continue和break, 取而代之的是iterate和leave
循环名字:while 条件 do
Iterate/leave 循环名字;
End while;</p>

<p>求1到指定数之间的和,但是凡是5的倍数都不要</p>

<p>存储过程
存储过程: procedure也叫做过程,是一种没有返回值的函数</p>

<p>函数是为了解决数据操作, 返回结果的话; 存储过程就是为了解决数据操作, 但是没有结果.</p>

<p>使用过程</p>

<p>定义语法
Create procedure 过程名([参数列表])
Begin
-- 过程体: 与函数体完全一样(局部变量,全局变量,if分支,while循环)
End</p>

<p>存储过程没有返回值, 如果想显示数据,在内部使用select</p>

<p>使用过程: 过程没有返回值: select不能使用</p>

<p>过程调用: 有一个专门的关键字: call</p>

<p>维护过程
查看过程: 查看所有过程:show procedure status;</p>

<p>查看过程的创建语句: show create procedure 过程名;</p>

<p>存储过程不能修改: 只能删除
Drop procedure 过程名;</p>

<p>过程参数
存储过程的参数不单有数据类型,而且还有自己的类型
In: 传进去, 外部(实参)将数据传递给存储过程内部使用(内部可以使用): 但是对外部变量没有影响(值传递)
Out: 传出去, 外部只需要对内部提供一个变量名, 内部会自动事先清空变量 = null, 然后内部对变量进行操作, 最后反应到外部的变量身上.(会内部事先清空变量引用传递)
Inout: 传进去又可以传出去(典型引用传值)</p>

<p>语法: create procedure 过程名(过程参数类型 参数名 数据类型,....)</p>

<p>Out类型和inout类型都是类似引用传值: 意味着实参不能使用值常量,必须使用变量</p>

<p>正常调用: 三个都传入变量</p>

<p>全局变量没有访问限制: 过程内部可以访问全局变量</p>

<p>触发器作业
给一张表增加6个触发器
Insert into 表名 values on duplicate key; 会触发多少个触发器?
1、没有主键冲突：2种：before insert和after insert
2、有主键冲突：3种</p>

<p>Replace into又会触发多少个出发器? 
1、没有主键冲突：2种 before insert 和after insert
2、有主键冲突：4种</p>

<p>建议: 创建一个表,有六个字段: before_insert,after_insert,before_update,after_update,before_delete,after_delete
每一个触发器对应一个字段的操作: 一旦触发,值设为1,没有触发就是0;</p>

<p>存储过程作业
要求生成随机的名字: 插入到数据表中
姓氏来源: 百家姓中取前10个(天干: 甲乙丙丁戊己庚辛壬癸)
名字来源: 地支(子丑寅卯辰巳午未申酉戌亥)
Rand(), substring(),concat(),char_length()</p>

<p>回顾（第13天）
事务操作: 一连串的操作: 要求要么全部成功,要么全部失败.
事务原理: 操作不会立即同步数据表, 存储在事务日志文件
自动事务(系统帮助提交)和手动事务(手动开启,事务处理,手动提交)
回滚点: 事务回滚的位置
事务特性: A(原子性),C(一致性),I(隔离性),D(持久性)
事务条件: 存储引擎必须为innodb</p>

<p>变量: 
系统变量: 使用(select @@变量名)和修改(会话级别: set 变量名/set session变量名和全局级别: set global 变量名/set @<a href="https://github.com/global" class="user-mention">@global</a>.变量名)
自定义变量: set @变量名 = 值, 赋值符号(:=)
从数据表获取数据插入到变量中(:=)
作用域: 全局作用域(结构外部)和局部作用域(结构内部)
全局变量(set @变量名)和局部变量(declare 变量名)</p>

<p>触发器: 监听对象(表中行), 触发时间(before和after), 事件类型(insert,update和delete)
Insert on duplicate key会触发多少个触发器?
没有主键冲突: 两个(before insert和after insert)
有主键冲突: 三个(before insert, before update和after update)
Replace into会触发多少个触发器?
没有主键冲突: 两个(before insert和after insert)
有主键冲突: 四个(before delete, after delete,before insert和after insert)</p>

<p>函数
系统函数: 使用(字符串函数操作基本单位是字符)
自定义函数: 函数名, 参数(形参和实参), 返回值 ,函数体
参数: 形参必须有数据类型, 实参必须与形参个数和数据类型都一致
返回值: 函数定义的时候必须指定返回值的类型,后面必须返回指定类型的数据
执行结构: if分支结构和while循环结构
If  条件判断 then
-- 条件成立要做的事情
Else
-- 条件不成立
End if;
循环控制: iterate和leave(接循环名字)</p>

<p>存储过程: 没有返回值的函数
参数类型: in,out和inout</p>

<p>用户管理
默认的,mysql服务器提供都是root用户(超级用户): 拥有所有权限</p>

<p>超级用户的优缺点
优点: 权限足够, 可以实现任何操作
缺点: 权限太足, 操作不安全</p>

<p>为了项目安全: 通常会创建用户分配权限(用户权限有限)</p>

<ol>
<li> 创建用户
Create user 用户名[@作用范围] identified by ‘密码’;    -- 密码是明文(系统内部会加密: sha1)
用户名: 用户登录的名字, root
作用范围: 没有的话,表示所有的客户端都可以访问, 如有只允许指定范围的客户端访问
Localhost: 只有本机可以访问
192.168.31.%: 允许局域网内部访问
%: 允许所有客户端访问</li>
</ol>

<p>所有的用户都会保存到: mysql数据库下user表中: 主要信息: user,host,password</p>

<p>当用户创建完成之后就可以实现用户登录</p>

<ol>
<li> 给用户分配权限
Grant 权限列表/all privileges  on 数据库.数据表  to 用户(用户名@作用范围) ;</li>
</ol>

<p>验证权限可用</p>

<p>其他权限根本不可用</p>

<p>权限列表分类</p>

<ol>
<li> 回收权限
Revoke 权限列表 on 数据库.表(*) from 用户(用户名@作用范围);</li>
</ol>

<p>验证权限结果</p>

<ol>
<li> 删除用户
Drop user 用户(用户名@作用范围);</li>
</ol>

<p>删除: 需要客户端重启才能生效</p>

<p>Root密码找回
Root密码忘记: 重装数据库</p>

<ol>
<li><p>关闭服务器: net stop mysql</p></li>
<li><p>重启服务器: 使用权限跳过命令: mysqld.exe --skip-grant-tables</p></li>
<li><p>新开客户端,使用mysql.exe直接进入</p></li>
<li><p>修改root用户的密码
Update user set password=password(‘新密码’) where user=’root’ and host=’localhost’;</p></li>
<li><p>退出系统: 关闭mysql服务器,重启服务器(进程管理)</p></li>
<li><p>正常启动服务器: net start mysql</p></li>
<li><p>使用新的root密码进入</p></li>
</ol>

<p>注意: 修改root用户密码是件非常危险的事情, 在使用跳过权限验证开启服务器的情况下,任何客户端都可以无用户登录.</p>

<p>PHP操作mysql
Mysql有很多种扩展允许操作mysql服务器: mysql, mysqli和PDO
Mysql: 面向过程(函数)
Mysqli: 面向过程(函数) + 面向对象(类)
PDO: 面向对象(类)</p>

<p>PHP本身不能操作mysql: 必须借助mysql的扩展来实现(底层:socket编程)</p>

<p>加载扩展
扩展加载分为两步</p>

<ol>
<li> 开启扩展(php.ini)
Extension = php_mysql.dll</li>
<li> 指定扩展路径
Extension_dir = ‘D:/server/php/ext’;</li>
<li> 重启服务器</li>
</ol>

<p>证明: 
1.  phpinfo()中查看mysql扩展</p>

<ol>
<li> 直接使用mysql扩展函数访问: mysql_connect</li>
</ol>

<p>PHP操作mysql
PHP充当的角色是mysql客户端.</p>

<ol>
<li> 连接认证: 连接和认证
Resource  Mysql_connect(‘主机地址:端口号’, ‘用户名’,’密码’);</li>
</ol>

<p>默认的: mysql连接永远返回一个资源(不管连接多少次都是一个资源: 节省资源,提高并发量)</p>

<p>但是: 可以使用多个连接: 使用mysql_connect的第四个参数,true</p>

<ol>
<li> 设置字符集, 选择数据库: 发送SQL指令
Mysql_query(sql指令[, 连接资源]): 连接资源可以省略: mysql会自动向上寻找连接资源(连接资源没有作用域的限制)</li>
<li> 获取mysql服务器的执行结果: mysql_query
a)  布尔结果: mysql_query发送的SQL指令没有结果返回(没有数据)
True: 只能代表当前SQL语句执行过程中没有出错</li>
</ol>

<p>False: 代表SQL语句有错误</p>

<p>b)  结果集: mysql_query发送的SQL指令有结果返回(show,desc,select)</p>

<p>结果集需要解析成PHP所能使用的东西: mysql_fetch系列
Mysql_fetch_array(): 默认返回一个数组(混合数组: 有索引下标也有字段名关联下标)</p>

<p>Mysql_fetch_array还可以返回关联或者索引数组: 通过第二个参数控制
MYSQL_ASSOC: 返回关联数组</p>

<p>MYSQL_ROW:返回索引数组</p>

<p>Mysql_fetch_assoc():只是获取关联数组</p>

<p>Mysql_fetch_row(): 只获取索引数组</p>

<ol>
<li> 关闭数据库资源(结果集资源和数据库连接资源)
结果集资源释放: mysql_free_result(结果集资源);</li>
</ol>

<p>释放连接资源: mysql_close(连接资源)</p>

<p>PHP操作mysql增删改查
增删改查是从用户对数据的操作而已, 就系统只有两个操作: 读和写</p>

<p>写操作: 将错误信息给处理
Mysql_errno(): 获取错误编码
Mysql_error():获取错误信息</p>

<p>任何SQL指令的执行之前: SQL指令都有可能保存: 为了不让用户看到一堆专业的错误: 将错误信息进行转换: 封装错误处理函数</p>

<p>新增操作: 获取自增长id
Mysql_insert_id(): 自动获取上次的新增操作的自增长id, 如果没有自增长id返回0.</p>

<p>更新或者删除操作: 获取受影响的行数
Mysql_affected_rows(): 获取上次的操作(增删改)受影响的行数</p>

<p>读操作: 本质一样,只是需要解析结果集
查询操作的时候,通常是需要对结果进行遍历: 遍历结果集, 将结果保存到数组(结果本身是数组)</p>

<p>数据显示</p>

<p>项目</p>

<p>功能: 学生管理系统: 用户必须登录之后才能查看学生信息(分页)</p>

<p>项目的出发点: 用户会干什么?</p>

<p>项目功能: 登录功能, 首页查看功能, 分页功能</p>

<p>登录功能
1.  用户输入URL访问网站: 任何时候都不请求html(只请求PHP)</p>

<ol>
<li><p>获取登录表单: html, 创建登录表单</p></li>
<li><p>在login.php中加载表单给用户</p></li>
<li><p>下一步,用户会输入用户信息,提交: 确定提交对象, 修改表单</p></li>
<li><p>获取登录表单需要login.php做, 提交用户信息进行验证也是login.php做: login.php要做两件事情,是分开做: 需要分析当前用户的请求目的: 根据用户是否提交数据来确定</p></li>
<li><p>接收用户提交的数据: submit</p></li>
<li><p>合法性验证: 判断数据是否合法(符合数据条件)
a)  用户名不能为空
b)  密码不能为空</p></li>
<li><p>在中文使用过程中出现乱码: 使用header解决</p></li>
<li><p>合理性验证: 数据是否在数据库存在: 需要进行数据库初始化操作: 整个项目都需要使用,应该将数据库的连接认证, 字符集设置, 数据库选择单独形成一个文件.</p></li>
<li><p>在需要使用数据库的地方加载数据库初始化文件: login.php</p></li>
<li><p>搭建数据库环境</p></li>
<li><p>通过用户名和密码进行用户验证</p></li>
<li><p>登录成功去往系统首页: 查看学生信息</p></li>
<li><p>发现每一次判断业务逻辑, 都有可能要条件,而跳转变化的内容只有三个: 提示信息, 等待时间,和跳转目标: 封装成跳转函数</p></li>
<li><p>凡是需要跳转的地方加载public.php,使用里面的redirect函数</p></li>
</ol>

<p>首页功能
1.  显示学生信息: 增加学生显示的HTML</p>

<ol>
<li><p>在首页PHP中加载模板显示数据</p></li>
<li><p>获取所有的学生数据: 初始化数据库连接</p></li>
<li><p>组织SQL语句查询数据库信息</p></li>
<li><p>搭建数据库环境: 学生表和班级表</p></li>
<li><p>在模板中显示所有的学生信息即可</p></li>
</ol>

<p>分页功能
分页功能: 用户能够进行上一页,下一页点击</p>

<ol>
<li><p>在显示数据的html中,增加一些分页点击功能.</p></li>
<li><p>确定点击按钮的url: index.php</p></li>
<li><p>给URL增加页码信息: page</p></li>
<li><p>在index.php求出对应的页码数据</p></li>
<li><p>在分页链接中使用求出来的页码信息</p></li>
<li><p>使用limit实现数据的分页</p></li>
</ol>

<p>回顾（第14天）</p>

<p>用户管理: 创建用户, 分配权限(grant to), 回收权限(revoke from), 删除用户
Root密码找回: 服务器启动(无权限验证启动: --skip-grant-tables</p>

<p>PHP操作mysql
PHP不能操作mysql: 借助mysql扩展: 加载扩展
PHP操作mysql
PHP是客户端: 连接认证(mysql_connect)
PHP发送SQL指令: mysql_query: 错误处理(mysql_errno()和mysql_error())
PHP接收结果: mysql_query(布尔结果和结果集资源)
PHP解析结果集资源: mysql_fetch系列
释放资源(结果集资源,连接资源)</p>

<p>项目: 利用PHP操作mysql实现了: 登录, 显示数据,分页功能
技术: HTML, CSS, PHP(服务器, 变量, 运算符, 函数(参数, 返回值,作用域), 执行结果(分支,循环), 数组, 文件包含(向上,向下)), mysql(SQL的基本操作)</p>

<p>万能密码: ‘ or 1 = 1#
Select * from pro_user where username = ‘’or 1=1#’ and password = ‘md5’;</p>

<p>SQL注入: 通过植入SQL语句的部分来改变原来的SQL语句的执行轨迹.
select * from pro_user where username=''or 1#' and password='992516908c1dffe8a6b8447764fbb291'</p>

<p>SQL注入的解决方案: 将用户输入的数据进行引用处理: 转义
Addslashes: 添加斜杠,对引号进行转义</p>

<p>HTTP协议
协议: Protocol, 双方必须在操作过程中互相约束的内容
HTTP: Hypertext Transfer Protocol, 超文本传输协议: 规范超文本在互联网之间传输数据的方式.</p>

<p>网络之间传输数据: 都是以数据包的形式传递, 系统经过网络OSI七层协议,转换成对应的数据包(一个字符串 = 多个数据包) =======&gt; 接收所有的数据包,整理成字符串</p>

<p>HTML: Hypertext Markable Language,超文本标记语言: 规范数据显示的结构(保证一个数据在不同的计算机上能看到相同的效果)</p>

<p>HTTP协议分为两个部分: HTTP请求和HTTP响应
HTTP请求: 规定浏览器向服务器发起请求的时候应该遵循的协议
HTTP响应: 规定服务器向浏览器响应数据的时候应该遵循的协议</p>

<p>URL: <a href="http://www.itcast.cn/gz/php/index.php">http://www.itcast.cn/gz/php/index.php</a>
http:// : 表示当前请求遵循HTTP协议
<a href="http://www.itcast.cn:80">www.itcast.cn:80</a> : 主机地址
/gz/php/index.php: URI, 寻找主机上对应的文件</p>

<p>Web访问原理</p>

<p>HTTP协议特点
支持客户/服务器模式: HTTP协议默认是给web使用, 浏览器与服务器之间的协议, HTTP协议其实没有规定必须是浏览器发起: 只要有内容(客户端)能够发起类似HTTP协议的规范的内容,那么就可以被服务器接收为HTTP请求; 服务器也可以通过HTTP响应来处理和返回结果. 如可以使用telnet,php</p>

<p>简单快速[只需请求方法和路径]: 理论上来讲只要有请求方法和路径就可以找到对应的服务器处理数据: 请求行(包含请求方法,URI), 请求头(HOST)</p>

<p>灵活[任意数据]:  通过HTTP协议可以将任何数据在互联网之间进行传递</p>

<p>无连接[每次连接只处理一个请求]: 任何一个请求都只能得到一个响应, 一旦结束连接断开.</p>

<p>无状态[事务处理没有记忆能力]: 基于无连接,导致服务器没有办法识别同一个浏览器(浏览器发起多次请求, 服务器不认识)</p>

<p>HTTP请求
HTTP请求分为四个部分: 请求行, 请求头, 空行, 请求数据(所有内容都是独占一行)
例: <a href="http://www.itcast.cn/gz/php/index.php">http://www.itcast.cn/gz/php/index.php</a></p>

<p>请求行: 又分为三个部分, 整体占一行, 彼此使用空格分隔
请求方式    URI                 协议版本\r\n
GET         /gz/php/index.php       HTTP/1.1</p>

<p>请求头: 完整的协议规范, 每一项协议占一行 ,可以有多项协议
协议名字: 协议内容\r\n
常见的HTTP请求协议项
Host: 主机地址, 规定到底要获取服务器哪个虚拟主机下的内容
HOST: <a href="http://www.itcast.cn(%E4%B8%80%E5%AE%9A%E5%BE%97%E6%9C%89)">www.itcast.cn(一定得有)</a>
accept-encoding: 浏览器能够接收服务器上面格式的编码(不是字符集), gzip,gflate等
Referer: 引用, 当前的浏览器发起的请求,是从上一个界面过来(上一个界面的URL)
Connection: 保持连接, 浏览器与服务器的请求过程是一次性的: 浏览器发起一次请求只能获得一次响应, connection表示在一次请求过程中,不要立即断开(keep-alive)
accept-language: 可以接收的语言, 中文zh-cn,英文等
Cookie: cookie本身是一种服务器将数据存储在浏览器上的一种技术, 基于HTTP协议中的cookie技术: 将服务器原来存储在浏览器上的数据携带给服务器
user-agent: 用户代理, 代表当前浏览器所在客户端的一些基本信息
Accept: 接收的类型, text/html, image/png等
content-length（post）: 内容长度, 只有POST提交数据的时候才会有
if-modified-since（get）: 当浏览器缓存了服务器已经被请求过的文件, 浏览器又再次发起请求: 发送的内容是上次缓存文件的时间
content-type（post））: 内容类型, post数据提交的时候需要对数据进行转码才能提交: application/x-urlencoded</p>

<p>空行: 告诉服务器请求头结束了,后面的内容是请求数据</p>

<p>请求数据: 数据的隐藏提交(数据表): 表单名字=值&amp;表单名字=值</p>

<p>查看简单的HTTP请求: httpwatch(专门查看HTTP协议), firebug</p>

<p>Telnet模拟HTTP请求
Telnet是windows下提供的一款远程访问的软件
使用方式: 在cmd控制台下,输入telnet命令即可.</p>

<p>默认的,有些机器的telnet是没有开启: 需要开启telnet
1.  打开控制面板</p>

<ol>
<li><p>打开”卸载程序”</p></li>
<li><p>点击左侧”打开或关闭windows功能”</p></li>
<li><p>勾选”telnet客户端”,确定即可</p></li>
<li> 需要重新打开一个新的cmd控制台才行(才能使用telnet)</li>
</ol>

<p>Telnet模拟http请求
1.  打开cmd, 输入telnet  主机地址  端口</p>

<ol>
<li><p>回车,telnet会自动连接主机地址</p></li>
<li><p>Telnet进入之后,默认是不能显示数据: 回显数据: 同时按住ctrl + 右中括号</p></li>
<li><p>再次敲”enter”回车, 然后就可以实现数据的回显</p></li>
<li><p>开始默认HTTP请求
a)  请求行(只能模拟get请求): 回车</p></li>
</ol>

<p>b)  请求头: 至少输入一个请求头(host:localhost), 然后回车</p>

<p>c)  空格: 回车</p>

<p>之所以没有成功: 手速太慢: 一次telnet只能模拟一次请求(http请求无连接)</p>

<p>HTTP响应
HTTP响应是服务器发出的.</p>

<p>HTTP响应也分为四个部分: 状态行(响应行), 响应头,空行, 响应体</p>

<p>状态行: 分为三个部分
协议版本    状态码     状态描述
HTTP/1.1     200        OK</p>

<p>响应头: 与请求完全一致,只是协议内容不一样(一个协议独占一行)
常见的响应头有
Server: 服务器信息
Date: 当前的响应时间(系统时间)
last-modified: 最后修改时间,对应请求中的if-modified-since
content-length: 响应数据的长度
content-type: 数据类型
Location: 重定向: 告诉浏览器立即重新发起请求
Refresh: 重定向: 告诉浏览器在指定时间之后重新发起请求
content-encodeing: 对应请求头中的access-encodeing,编码格式: gzip,deflate等
cache-control: 缓存控制,告诉浏览器是否需要混村数据: no-cached不要缓存</p>

<p>空行: 告诉浏览器响应头结束:以下内容是响应体</p>

<p>响应体: HTML代码(最终的数据)</p>

<p>普通的响应头</p>

<p>状态码
状态码: 协议规定服务器在做完处理之后, 需要通过一系列编码告诉浏览器处理的结果是什么样的</p>

<p>状态码分为5类:
1XX: 表示服务器正在处理,还没有处理完(接收,处理)
2XX: 服务器已经正常处理完毕
3XX: 重定向, 当前处理需要浏览器再次配合
4XX: 浏览器错误: 服务器对浏览器的请求不予配合
5XX: 服务器错误: 服务器不能正常处理请求</p>

<p>常见的状态码
200: OK, 请求成功, 服务器已经正确处理完毕
302: Found, 当前请求的URL(文件)已经转移
303: See Other, 当前请求的文件被转移
304: Not Modified, 服务器没有修改, 浏览器访问本地缓存(if-modified-since)
400: Bad Request,错误的请求
403: Forbidden,没有访问权限
404: Not Found, 请求的脚本不存在
502: Bad Gateway, 网关错误, 服务器需要从其他服务器获取结果: 没有获取到</p>

<p>PHP修改响应头
PHP中提供了很多方式都可以修改响应头: header, setcookie,session_start, output_buffering</p>

<p>跳转功能
跳转功能:  当浏览器解析到对应的响应头(http协议项), 如果碰到跳转提示,那么会直接跳转: 后面的协议有可能还没有解析完(数据不可能解析): 直接跳转,没有输出
Location: 重定向, 直接重定向(不需要等待缓冲,浏览器立马发起新的请求)</p>

<p>Header(‘location:重定向目标’);</p>

<p>界面刷新
刷新: 当浏览器得到请求响应之后,在等待时间后自动实现重新请求</p>

<p>Refresh: 刷新,在查看了部分之后,持续刷新
与location的区别: 同样属于重定向, location是浏览器直接跳转; refresh是浏览器在解析之后才等待跳转: location不能输出数据, 但是refresh可以.</p>

<p>Header(‘refresh:刷新等待时间;url=跳转的目标’);</p>

<p>输出图片
图片是一种二进制数据, 浏览器默认解析数据是按照html文本解析</p>

<p>服务器在输出图片之前: 必须告诉浏览器,以后的所有内容不是文本,应该当做一张图片: 必须要告诉浏览器指定图片的格式.
Content-type: 格式(MIME类型格式)
Header(‘Content-type: image/gif, image/png, image/jpg, image/jpeg’);</p>

<p>任何时候若要输出图片: 必须输出的仅有图片内容, 不能有任何别的内容</p>

<p>下载内容</p>

<p>下载的本质: 阻止浏览器解析, 当做附件处理
Content-type: application/octet-stream; 流处理
Content-dispositon:attachment;filename=建议名字</p>

<p>协议修改注意事项
修改协议前: 不能有任何输出: 系统一旦碰到输出, 就会认为协议已经组织结束: 所有后面的内容全部都是数据.</p>

<p>证明: 将程序缓存关闭: PHP就会代码解析一句就给apache返回一句: apache一旦检测到内容不是协议: 就会将后续的所有内容都当做数据.
Output_buffering</p>

<p>将程序缓存变成0: 不缓存</p>

<p>效果</p>

<p>PHP模拟HTTP请求</p>

<p>模拟GET请求</p>

<ol>
<li><p>使用PHP与服务器建立连接
Fsockopen: 与服务器建立连接, 成功返回一个连接资源,失败返回false</p></li>
<li><p>发送HTTP请求协议: 请求行,请求头,空行,请求数据(GET没有)
Fputs/fwrite: 向资源写入数据</p></li>
<li><p>从资源中解析响应结果(读取结果)
Fgetc/fgets/fread: 读取资源中内容</p></li>
<li><p>释放资源
Fclose</p></li>
</ol>

<p>模拟POST请求
POST比GET请求多了几个协议: 数据, 数据长度, 数据编码</p>

<ol>
<li><p>建立连接</p></li>
<li><p>准备HTTP请求</p></li>
<li><p>发送HTTP请求</p></li>
<li><p>解析响应</p></li>
<li><p>关闭资源</p></li>
</ol>

<p>要实现攻击: 不断的发送请求</p>

<p>让脚本可以执行不受时间限制: 在脚本执行之前加一个执行周期控制
Set_time_limit(0): 0代表永远执行</p>

<p>算法
快速排序算法
快速排序: 效率比较高, 使用空间换时间(递归)</p>

<p>原理: 从一个数组中,随机取出一个元素: 以该元素为基准,将数组中剩余的其他元素挨个的与当前元素进行比较: 比元素小的存放到一个数组, 比元素大的也存放到一个数组. 当所有的元素都比较完之后: 一定会确定中间元素(取出的元素)的位置.
两边的数组依然需要排序: 利用上述解决问题的方式解决子问题(递归点),直到数组元素个数为1, 再返回(递归出口), 返回的结果与上述的结果进行合并.</p>

<p>代码实现
1.  定义函数</p>

<ol>
<li><p>取出第一个中间元素</p></li>
<li><p>从第二个元素开始进行遍历比较</p></li>
<li><p>合并数组返回</p></li>
<li><p>找到递归点: 左右两边的数组没有排好序(需要排序): 刚好函数所要做的事情就是排序数组: 对数组进行排序(递归调用)</p></li>
<li><p>递归出口: 什么时候函数不再自己调用自己: 数组元素的个数不能小于1</p></li>
</ol>

<p>二分查找算法
二分法又称之为折半算法: 是指针对一个已经排好序的数组中去找到对应的元素的位置</p>

<p>原理: 将数组折半,找到中间元素: 将中间元素与要找的元素进行比较: 如果一样,返回位置(找到了);如果比元素小, 将后半部分再查找; 如果比元素大, 将前半部分进行查找;</p>

<p>代码实现
1.  定义待排序数组</p>

<ol>
<li><p>求出数组的长度</p></li>
<li><p>求出当前要求的内容所在数组的哪个区间</p></li>
<li><p>找出当前的第一个中间位置下标</p></li>
<li><p>开始查找: 目标值是3</p></li>
<li><p>重新计算middle的位置</p></li>
<li><p>考虑到边界值的问题: 发展的最终有可能是左边 == 右边: 修改循环条件</p></li>
</ol>

<p>回顾（第15天）</p>

<p>HTTP协议: web互联网之间数据传输的基本协议
HTTP请求:
请求行: 请求方式   URI   协议版本(HTTP/1.1)
请求头: 具体的协议项( 协议名字: 协议内容)
空行: 请求头的结束, 后面是请求数据
请求数据: 只有POST才有请求数据
HTTP响应:
状态行: 协议版本(HTTP/1.1)   状态码   状态描述
响应头: 与请求头完全一样(内容有所不同)
空行: 分离响应头和响应体
响应体: 超文本内容</p>

<p>Telnet模拟HTTP请求
Telnet  主机地址  端口
Ctrl + ] ------&gt; Enter  回显数据
请求行(三部分)
请求头(Host)</p>

<p>PHP修改HTTP响应: header(跳转, 刷新, 输出图片,下载)
PHP利用socket编程: 模拟HTTP请求(GET和POST: Content-type, Content-length)</p>

<p>算法: 快速排序和二分法查找</p>

<p>需求: 假设大家是一个团队, 要帮助传智播客做一个电子商务网站: 用户进入系统(网站)-&gt;选择某件商品(查看商品详情) -&gt;加入到购物车-&gt;结算(生成订单)-&gt; 支付 -&gt; 发货-&gt; 物流(收货)</p>

<p>方案1: 将PHP代码插入到对应的HTML文件中: 从数据库获取数据进行显示</p>

<p>面向过程编程
方案2: 将PHP代码与HTML进行分离: 将整个购物流程进行拆分, 拆分成一个个不可再分的小功能: 每个功能使用函数实现, 最后应用的时候只要调用相关的函数按顺序加载调用即可.</p>

<p>以上方案
1.  能够实现代码的复用(函数)
2.  模块化编程思想: 一个函数实现一个功能
3.  将一个过程(购物)分解成一个个最小的功能单元, 最后只需要将功能单元进行串联即可实现: 将这种过程拆分成函数实现的思想称之为面向过程编程.</p>

<p>面向过程编程: 这是一种编程的思想,不是技术
将一个整体的过程,拆分成具体的实现单位, 然后使用函数的形式将最小的实现单位进行封装(形成一个个小模块)</p>

<p>纯面向过程思想: 所有的代码都在函数内部
如C语言中: 入口函数main(), 系统会自动找到这个函数进行执行</p>

<p>面向对象编程
在生活当中,任何一件事情的操作,都一定是有一个操作的主体
方案3: 在方案2的基础上, 为每个操作增加一个操作主体(更加贴近生活事实)</p>

<p>以上方案
1.  代码的复用(函数)
2.  模块化编程思想
3.  有事务操作主体(符合人的操作逻辑)
4.  将这种操作流程细分成函数, 但是还要向上追溯函数的操作对象的编程方式称之为面向对象编程.</p>

<p>面向对象编程: 不是一种技术,而是一种思想: 一种一定要指定事务操作的主体的思想.
OOP: Object Oriented Programming: 在基于面向过程的基础上, 增加事务操作的主体.</p>

<p>面向对象基本概念
类, 对象和实例化</p>

<p>类: class, 分类的意思, 将一类具有相同特性,相同能力的事务主体归到一起.
类就是事务的操作主体
对象: object,是一类数据类型: 对象是类的具体的实体(实例)</p>

<p>对象: 是类的具象
类: 是对象的抽象</p>

<p>实例化: new, 从类产生对象的过程</p>

<p>基本实现
现实生活中,是先有活生生的实体, 才会对其就行命名和抽象(对象-&gt;类): 在程序的世界里: 却是通过抽象去匹配实体(类-&gt;对象).</p>

<p>定义类: 形成一个抽象概念
Class 类名{
//类成员
}</p>

<p>类是一种结构: 不会自动执行</p>

<p>对象: 从类形成对象, 实例化: new
New 类名/类名();</p>

<p>因为对象产生之后: 是保存在内存的堆区(程序只能操作栈区),如果堆区内存没有被指向的话,会被自动系统回收: 需要通过变量来指向生成的对象的内存空间(不要被回收)</p>

<p>类成员
类成员: 在类的结构中,可以直接存在的成员
类成员只有三种: 属性,方法和类常量</p>

<p>属性
 定义在类中的变量</p>

<p>要定义在类中,就需要有特殊的规范: 使用访问修饰限定符限制
Public: 公有的,表示修饰的成员既可以在类内部访问(类的大括号之内),又可以在类外部访问
Protected: 受保护的, 表示只有类内部可以访问(继承)
Private: 私有的, 表示只有自己类内部可以访问
Var:兼容性访问修饰限定符(PHP4以前),代表的就是public(公有的)</p>

<p>方法
定义在类中的函数</p>

<p>方法也有访问修饰限定符限制: 默认的不使用代表public</p>

<p>类常量
定义在类中的常量: 只能使用const关键字定义,不能使用define函数</p>

<p>类成员访问
类成员中的所有属性和方法都是由对象来访问, 而类常量不是由对象访问,而是由类访问.</p>

<p>对象访问属性
$对象变量-&gt;属性的名字 = 值; // 可以查就可以改</p>

<p>对象访问方法
$对象变量-&gt;方法名字();</p>

<p>对象访问类常量
对象不能访问类常量:假设可以访问: $对象变量-&gt;常量名; // 然后系统会当做属性处理</p>

<p>常量的访问方式:使用类访问
类名::常量名; // :: 范围解析操作符</p>

<p>私有成员访问
私有(private): 规定只能在类的内部访问, 类内部只能有类成员(属性,方法和类常量)
方法内部(本质函数)内部不限制任何代码: 私有成员的访问就是在类定义的方法中进行访问.</p>

<p>方法内部不能直接访问属性名字: 系统会当做局部变量</p>

<p>属性和访问都只能由对象来访问: 即便是在类的内部也必须用对象访问.</p>

<p>私有方法也是通过在方法内部引入对象,然后再进行对方访问访问</p>

<p>上述方式虽然可以实现访问私有成员: 但是固定了死了外部的对象的名字, 但是事实是不可以固定: 对象的名字是用户自定义的,而且有可能有多个.</p>

<p>要是在方法内部: 有一个东西能够抓到当前使用该方法的对象就好了.
$this关键字
$this是一种能够在对象调用方法的时候,会自动抓取对象的内存地址,然后赋值给$this, 然后就可以使用$this代表对象本身进行成员的访问.</p>

<p>私有成员就可以在类的内部使用$this进行访问</p>

<p>内存分析
类是一种结构:不会自动执行, 存在于代码段
对象是一种数据类型: 存放到堆区</p>

<p>魔术方法
魔术方法: 系统内部已经定义好的(规范好名字)的方法, 这种方法默认是用户没有显示定义,但是用户一旦在类中定义了指定的方法名字: 这些方法就会在某些特殊地方自动的被调用.
所有的魔术方法都是以双下划线开始后接方法名字.</p>

<p>构造方法
方法名字: __construct(), 类在形成对象的过程中(实例化),之后会被形成的对象自动调用的方法: 构造对象.</p>

<p>构造方法的作用: 构造对象, 为了初始化属性</p>

<p>构造方法的属性初始化的值往往从外部进行传入的:参数(构造方法形参)</p>

<p>在很多语言中: 构造方法的方法名字不叫__construct而是与类名同名</p>

<p>注意: 在高版本中已经不使用,有时候为了做兼容,会做两个构造方法</p>

<p>析构方法
析构方法: __destruct(), 当对象被销毁之前,对象会自动调用的方法.
作用: 释放所有的资源.(PHP中自动释放资源: 很少使用析构方法)</p>

<p>手动释放对象
1.  让保存对象的变量指向新的内存地址
2.  释放变量:unset
3.  将变量置空</p>

<p>对象赋值
对象用变量保存, 变量可以赋值给另外的变量: 实际上就是对象的赋值.
对象赋值是引用传递</p>

<p>对象比较
1.  对象是否属于同一个类</p>

<ol>
<li><p>比较属性的个数</p></li>
<li><p>比较属性的值</p></li>
<li><p>全等比较: 只有同一个对象才可以true,否则永远为false</p></li>
</ol>

<p>封装数据库操作类
注意: 
任何一个类都应该单独存在于一个文件
类文件的命名与类名字有关联: 类名.class.php</p>

<ol>
<li><p>新建一个DB类文件: DB.class.php</p></li>
<li><p>考虑类的属性: 主机,端口,用户名,密码,字符集,数据库名字等
应该尽可能的增加类对成员的控制: 只需要在类内部访问的,一定不要其能够被外部访问
Private &gt; protected &gt; public</p></li>
<li><p>属性初始化: 构造方法</p></li>
</ol>

<p>要实现一个功能: 就对应应该有一个方法(函数)
4.  连接数据库</p>

<ol>
<li><p>设置字符集</p></li>
<li><p>选择数据库</p></li>
<li><p>发现所有的SQL语句都是由mysql_query执行,而且都有可能出错: 将SQL语句的执行以及判断错误单独封装成一个方法.</p></li>
<li><p>将凡是用到mysql_query执行SQL语句的地方,调用db_query方法</p></li>
<li><p>增加新增功能</p></li>
<li><p>修改功能+删除功能: 都是返回受影响的行数</p></li>
<li><p>查询功能: 分成两种: 查询单一结果;查询多条结果
a)  单一结果</p></li>
</ol>

<p>b)  全部结果</p>

<ol>
<li><p>每次得到数据库类的对象之后: 必不可少的是要: 连接数据库,设置字符集,选择数据库: 应该在产生对象的时候就自动已经做好的. 在构造方法中内部调用方法.</p></li>
<li><p>既然连接数据库,设置字符集和选择数据库已经变成内部调用: 外部根本不需要调用: 应该尽可能的增加类对成员的控制: 变成私有private</p></li>
</ol>

<p>类加载
类是一种结构: 如果要访问类,前提是类在内存中存在.
类一般是一个单独的文件: 若要使用类就得加载类.</p>

<p>手动加载
在使用类之前,手动的将类对应的文件给包含进来</p>

<p>自动加载
自动加载: 系统会给提供一种机制: 如果系统当前要用类(实例化),但是系统又没有在内存中找到对应的类: 机制就会被触发, 可以通过被触发的机制,修改机制的内部,使得能够按照某个通用的规则将类文件进行加载到内存.</p>

<p>魔术函数: __autoload()</p>

<p>自动加载需要判断文件是否存在:存在才加载,不存在就不管</p>

<p>类常量的访问: 类 :: 常量名;
Self关键字
Self与$this相似: 都是在类的内部(方法内部)才能使用的关键字
$this代表的是对象;self代表的是类名(self不能单独使用)</p>

<p>回顾(第16天)
面向过程: 将过程(流程)拆分成一个个的小的节点, 使用函数实现. 在需要执行的时候调用函数即可.
面向对象: 在面向过程的基础上,增加了操作主体: 需要使用的时候, 先从主体得到具体对象,再由对象去调用自己的能力(方法:函数)进行操作.</p>

<p>面向对象基本概念
类: class, 归类,将一类具有相同特性的事务(实体)进行公共性质的抽离,形成的代码
对象: object, 对象是某一类特性公共实体下的具体的具象(类的实例)
实例化: new, 从类产生对象的一个过程.
实例化过程: ①内存中(代码段)寻找类; ②在堆区开辟内存存储对象; ③从类中取出所有的属性;</p>

<p>类成员: 属性(变量), 方法(函数),类常量(const)
访问修饰限定符: public(var),protected和private
范围解析操作符: ::专门给类用的: 类::常量名</p>

<p>成员访问: 属性和方法都是由对象访问: 对象-&gt;属性名 / 对象-&gt;方法名()
(对象能访问的东西都在对象空间中: 堆[方法] ;  类只能访问类空间里面的东西: 代码段[方法,类常量,静态])</p>

<p>私有成员访问: 必须在类内部访问(方法内部): $this
Self关键字: 在类内部代表类名</p>

<p>封装DB类: 类名与文件名一样(类名.class.php), 一个类文件中只能有一个类
类的加载: 手动加载, 自动加载(__autoload)</p>

<p>魔术方法: 构造方法(__construct)和析构方法(__destruct)</p>

<p>克隆
从一个原有的对象, 克隆复制一个产生一个新对象, 但是刚产生完新对象的表现性状与原对象一模一样.
对象变量2 = clone 对象变量1; //对象变量1保存的是一个对象</p>

<p>魔术方法: __clone()
当对象被克隆之后,克隆对象会立即自动调用的方法.</p>

<p>静态
静态: 本质属于类(类访问), 是在类进行编译的时候就会被初始化,而且只初始化一次(对象是否调用没有任何影响).</p>

<p>静态关键字: static
静态东西分为两类: 静态属性和静态方法, 就是在属性和方法之前使用static关键字.</p>

<p>静态属性
Static修饰的属性: 属于类(对象不能访问)</p>

<p>静态属性通过类进行访问: 类名::$静态变量</p>

<p>需求: 统计对象产生的个数: 实例化和克隆能够产生新对象: 保证在克隆或者实例化的时候对象计数器能够加1即可: 构造方法和克隆方法</p>

<p>静态方法
使用static关键字修饰的方法: 给类访问.</p>

<p>静态意义
静态成员给类访问: 不需要对象就可以访问</p>

<ol>
<li> 静态的效率比非静态高(静态直接访问;非静态找找到对象-&gt;找到类)</li>
<li> 静态的内存使用更加少(对象必须产生对象空间)</li>
</ol>

<p>能使用静态的地方绝不使用非静态.</p>

<p>静态与非静态的互访(不建议)
1.  对象本质也可以访问静态方法: 对象访问访问一定是在类中,静态方法也是在类中</p>

<ol>
<li><p>类本身也可以访问非静态方法(非静态方法也在类中)</p></li>
<li><p>对象也可以操作范围解析操作符</p></li>
</ol>

<p>静态与$this的关系
在非静态方法中使用$this, 静态方法中不允许使用$this: $this代表对象, 静态方法是给类访问(不需要对象), 这个时候访问的话, $this就无法获取对象</p>

<p>设计模式
设计模式: 是一种已经成型的,能够解决某一类相似问题的解决方案.</p>

<p>设计模式是一门课程: 有很多(尤其是JAVA), 主要是面向对象</p>

<p>在PHP中只讲两种设计模式: 单例模式和工厂模式</p>

<p>单例模式
单例模式: 单个实例(对象), 一个类在一个脚本执行周期中,永远只能产生一个对象</p>

<ol>
<li><p>关闭所有能够产生多个对象的方案: 实例化和克隆: 私有化构造方法和克隆方法</p></li>
<li><p>想办法进入到类的内部进行实例化产生对象: 私有方法在类内部可以访问: 静态方法</p></li>
<li><p>其实内部在实例化的时候,可以无限实例化</p></li>
<li><p>想办法解决问题: 在类的内部不应该每次都进行实例化: 应该在没有的情况下才实例化;而如果有对象,就不需要实例化: 增加一个静态属性,保存对象</p></li>
<li><p>产生对象的时候应该先判断对象是否存在</p></li>
</ol>

<p>单例实现: 三私一公
私有化构造方法: 防止在类外部无限实例化
私有化克隆方法: 防止对象在类外部无限克隆
公有化静态方法: 进入到类被进行实例化或者对象获取
私有化静态属性: 保存已经产生的对象</p>

<p>工厂模式
工厂: 生成工具, 外部要什么内容,工厂就生产什么内容
工厂模式: 帮助外部生成指定类的对象</p>

<ol>
<li> 工厂模式是用来帮助别人生产对象: 对象是别人,不是自己的: 静态方法</li>
</ol>

<p>工厂单例模式
1.  工厂单例模式完全不能保证对象真的永远只能产生一个
2.  工厂单例模式: 保证对同一个类进行实例化对象的时候只实例化一个</p>

<p>魔术方法
__toString()方法: 对象是一种复合数据类型, 不能直接echo, 但是假设需要将对象进行echo或者其他字符串方式处理,就会自动调用__toString方法.</p>

<p>增加魔术方法__tostring之后</p>

<p>Js面向对象
不是所有的面向对象语言都有类(class), 如js</p>

<p>js的面向对象”类”就是函数</p>

<p>面向对象三大特性
面向对象都有的三大特性: 封装,继承和多态</p>

<p>封装
封装: 字面意思上讲,是一个动词, 指的是从自然事物形成计算机可以识别的代码的过程.
从实体形成对实体的描述: 类(抽象: 从公共实体中抽离公共特性的过程)</p>

<p>抽象: 将数据(属性)以及数据的操作(方法),捆绑到一起,形成对外界的隐蔽(类是一种封闭的结构), 但是对外提供可以操作的接口(public).</p>

<p>继承
继承: extends</p>

<p>继承的现实意义: 子辈继承了父辈所拥有的财产: 子辈在什么都不需要的情况下, 就可以使用父辈遗留的财产等内容.</p>

<p>程序的继承: 当某一个类实现了某些基础的功能, 而另外一个类,与当前已有的类有一定的关联(内部关联: 比上一个类更细), 需要用到已有类的部分功能(或者全部), 如果自己内部封装功能那么需要耗费相当多的代价: 可以选择将已有的类作为父类, 自己当做父类的一个子类, 从而实现父类代码的使用(复用).</p>

<p>Class Car{
Function drive(){
Echo ‘drive’;
}
}
Class RedFlag extends Car{
}</p>

<p>$rf = new RedFlag();
$rf-&gt;drive();</p>

<p>多态
多态: 多种形态, 在继承的情况下, 如果一个父类对象得到的却是子类的实例, 当父类对象去进行方法调用的时候,表现出来的是子类的形态.</p>

<p>要求: 继承, 强类型语言, 重写(override)</p>

<p>Class Car{
Public string function drive(){
Return ‘drive’;
}
}</p>

<p>Class SmallCar extends Car{
//小车的跑与car的跑不一样
Public string function drive(){ //子类定义与父类同名的方法: 重写
Return ‘smallcar drive’;
}
}</p>

<p>//多态实现
Car car;    //定义一个car的变量,类型是Car类的对象类型
car = new SmallCar();   //实际保存的结果是SmallCar类对象
//父类对象保存了子类的实例
car.drive(); //调用的是子类的drive方法: smallcar drive</p>

<p>PHP继承
继承: 子类从父类获取对应的内容, 可以直接使用.</p>

<p>继承语法
子类 extends 父类;</p>

<p>继承效果
子类对象可以直接访问父类中被继承的类成员: 可以访问父类的方法(公有的)</p>

<p>继承内容
在PHP中子类继承父类: 只能继承所有的属性,和所有非私有的方法
在PHP中: 所谓的继承是子类对象继承父类对象, 而不是类与类的继承.但是PHP中类也同样适用于继承语法.</p>

<p>子类对象继承父类对象的所有属性(属性一定保存在对象中)</p>

<p>继承父类的非私有方法</p>

<p>Protected关键字
Protected: 受保护的, 只能在类内部访问, 是一种专门用于继承的关键字: 可以在子类的内部访问, 而不是private只能在自己类内部访问.</p>

<p>父类私有属性使用
父类私有属性一定只能在父类中使用: 在父类中增加一个方法可以访问私有属性, 子类继承父类的方法,从而实现父类私有属性的访问.</p>

<p>重写
重写:override, 子类拥有与父类同名的属性或者方法。</p>

<p>属性重写
创建一个子类的对象，用户只会产生一个对象空间（一块内存）
如果子类拥有与父类同名的属性：重写， 重写的结果就是父类的属性永远的消失。</p>

<p>属性重写： 一定不能重写父类的私有属性（属性带着类名）</p>

<p>属性重写后会被覆盖（私有的除外）： 在不同类中访问私有属性时，访问的是类自己的私有属性： 公有的或者受保护的一定访问的是子类的属性（子类覆盖了父类的）</p>

<p>方法重写
方法重写：方法属于类（保存在类结构中）：方法的重写是指子类有父类的同名方法， 但是不存在将父类的同名方法覆盖。</p>

<p>逻辑：继承类对象访问方法： 先去自己类中寻找有没有该方法（能不能被访问）： 确定可以就直接使用。 （只有私有的方法才有可能使用父类自己的）</p>

<p>继承内存原理
继承内存包含重写（属性）</p>

<p>重写规则
重写必须子类的权限要小于或者等于父类的权限（子类要比父类开放）</p>

<p>Parent关键字
方法重写是不会覆盖父类的方法的,只是因为对象访问方法的时候: 默认的永远先找子类,找到之后就不会找父类的: 但是有时候希望不单单只访问子类的方法,而且也想访问父类的被重写的方法: parent::父类被重写方法.</p>

<p>静态延迟绑定
Self代表当前所在的类的类名(固定的)</p>

<p>Self是在定义结构的时候,就已经给self绑定了值: 所属类名(静态绑定)</p>

<p>有时候我们希望谁调用方法: 就能够代表的是哪个具体的类: 定义的时候不要绑定类名,而应该在调用的时候绑定类名: static(静态延迟绑定: 调用时绑定)</p>

<p>PHP继承特点</p>

<ol>
<li><p>PHP不支持多继承: PHP只能有一个父类,只能支持单继承</p></li>
<li><p>PHP支持链式继承: A extends B, C extends A ====&gt; C extends A,B</p></li>
<li><p>PHP是双向继承: 子类可以继承父类的内容,但是在父类内部也可以访问子类的内容</p></li>
</ol>

<p>PHP特殊类
PHP中有几个关键字可以修饰的类, 修饰之后对类有特别限制.
主要有两个: final(最终)和abstract(抽象)</p>

<p>Final类
Final类: 最终类, 代表着类不能被扩展: final关键字修饰的类不能被继承</p>

<p>Final关键字还可以修饰方法(类不是final类): 表示该方法不可以被重写</p>

<p>Final类的意义
1.  Final修饰类:希望类不被继承, 意味着不会被扩展: 保护类结构
2.  Final修饰方法: 表示保护方法本身不要被重写</p>

<p>Abstract类</p>

<p>使用abstract修饰的类称之为抽象类: 抽象类表示不可以被实例化</p>

<p>抽象类只能用来被继承</p>

<p>Abstract还能修饰方法: 抽象方法: 没有方法体(没有{});</p>

<p>有抽象方法(abstract修饰的方法)的类必须为abstract抽象类</p>

<p>抽象类中可以拥有一个普通类所拥有的一切内容.</p>

<p>抽象类的意义
1.  规范子类. 所有的子类必须严格实现父类(抽象类)的所有抽象方法(abstract主要是用来修饰方法)</p>

<p>回顾（第17天）</p>

<p>克隆: clone, 克隆魔术方法(__clone)
静态: 给类访问的
静态属性: 在类加载的时候就会初始化
静态方法: 静态方法里不允许有$this</p>

<p>设计模式: 单例模式(三私一公)和工厂模式</p>

<p>面向对象三大特性: 封装,继承和多态(PHP不支持)
PHP继承: extends
继承内容: 所有属性和非私有方法(继承本质:对象继承对象)
Protected: 受保护的,专门用于继承
重写: 子类拥有与父类同名的属性或者方法: 重写规则: 权限
Parent关键字: 专门用于访问父类方法
静态延迟: self(静态绑定)与static(延迟绑定:调用时才确定属于哪个类)
特殊类: final类和abstract类</p>

<p>接口
接口: interface</p>

<p>接口: 对外提供的操作方式, 操作接口(public)
接口: 用来规范项目代码, 结构接口(interface)</p>

<p>接口语法
跟类结构很像
Interface 接口名字{
//接口成员
}</p>

<p>接口成员
接口中只能有两个内容: 常量和方法(抽象方法)</p>

<p>方法不能有方法体</p>

<p>接口中不允许有成员属性</p>

<p>接口中的方法必须为public(访问修饰限定符只有PUBLIC)</p>

<p>接口使用
接口的本质是为了规范结构(抽象类)</p>

<p>接口自己并没有用, 主要用来规范实现接口的类.</p>

<p>Class 类 implements 接口名{
//类中必须实现所有的接口中的抽象方法(除非类抽象类则可以不实现抽象方法)
}</p>

<p>实现接口: 要么抽象类要么实现抽象方法</p>

<p>接口意义
接口的存在是为了规范项目的结构.</p>

<p>抽象类与接口本质的意义都差不多: 都是规范项目结构</p>

<p>接口特点</p>

<ol>
<li><p>接口可以多实现: 一个类可以一次实现多个接口
Class 类名 implements 接口1,接口2...</p></li>
<li><p>接口是否可以被继承? 接口不能被继承,只能被实现? 接口可以被继承?
接口是被类实现: 类永远只能实现接口,不能继承接口;\
接口是可以继承接口.</p></li>
</ol>

<p>面试题
1.  抽象类是不是类?
肯定是类: 抽象类中可以有类中所包含的所有内容(属性,方法,类常量), 抽象类是一种用于继承的类.</p>

<ol>
<li><p>接口是不是类?
接口不是类, 接口interface, 类class: 在系统内部,接口与类的结构是一样的, 但是有一些细微的限制区别.</p></li>
<li><p>接口是否可以被继承?
接口不能类继承, 接口只能被类实现; 接口可以被接口继承.</p></li>
<li><p>PHP是否支持多继承?如何模拟?
PHP不支持多继承
模拟: 链式继承(继承链)</p></li>
</ol>

<p>重载
重载: overload, 是面向对象中一个很重要的概念: 在同一个类中,可以出现多个同名函数, 但是要求其返回值或者参数类型,或者参数的个数不同.</p>

<p>Class Person{   //java
Public string function eat(){
Return ‘eat’;
}</p>

<p>Public string function eat(string soup){
Return ‘soup’;
}
}</p>

<p>//系统调用方法的时候: 是自动根据参数来选择方法(不允许有多余的实参)</p>

<p>PHP重载
PHP重载与传统意义的重载完全两码事.</p>

<p>PHP重载: 当访问一个不存在或者权限不够(private,protected)的成员的时候(属性和方法), 系统会自动触发一些魔术方法.</p>

<p>PHP重载分为两种: 属性重载和方法重载</p>

<p>属性重载
重载都是指的魔术方法
__get(): 对象访问一个不存在的或者权限不够的属性的时候会自动触发的方法</p>

<p>常见的处理方式</p>

<p>__set(): 设置属性</p>

<p>__isset(): 使用isset或者empty判断属性</p>

<p>__unset(): 使用unset销毁属性</p>

<p>方法重载
当访问一个不存在的方法或者权限不够的方法的时候会自动触发的魔术方法.
__call(): 普通方法</p>

<p>__callStatic(): 静态方法</p>

<p>重载意义
1.  主要意义: 容错处理: 当用户不当的调用定义的结构(属性或者方法)不会报错
2.  保护结构完整性: __set和__unset</p>

<p>命名空间
命名空间: namespace, 是一种逻辑上对内存进行分离的技术: 分离之后,在不同的区间内部就允许有同名的结构出现.</p>

<p>命名空间就是文件夹: 在不同的文件夹中就可以有不同的同名文件(类,函数,常量)</p>

<p>命名空间不是PHP首创,在其他语言早就使用了(C#)</p>

<p>定义空间
空间关键字: namespace</p>

<p>定义命名空间的规则: 在定义命名空间之前不允许有任何代码.</p>

<p>定义空间</p>

<p>空间元素
命名空间中真正受影响的内容只有三个: 函数, 常量和类, 也可以有其他的内容,如变量等,但是不受空间影响.</p>

<p>访问空间元素
<strong>NAMESPACE</strong>: 获取当前所属的空间名字</p>

<p>PHP中命名空间提供了三种方法形式能够访问空间元素</p>

<p>非限定名称
当前文件夹: 只能从当前文件夹所找到元素: 该访问的位置向上找到的第一个最近的空间</p>

<p>限定名称
从当前目录向下查找: 找子文件夹内部的内容
子空间名\元素;</p>

<p>完全限定名称
从根目录开始访问: 代表根目录的方式是”\”反斜杠
\目录名\元素</p>

<p>子空间
有时候一个文件夹不足以解决所有的同名问题, 会将文件夹进行分层: 命名空间的子空间.
一级空间\二级空间;  //二级空间就是一级空间的子目录</p>

<p>子空间元素的访问: 用的最多的就是完全限定名称</p>

<p>空间引入
本质上不可能(没必要)在一个脚本文件中创建多个空间, 因为程序猿不可能在一个脚本中创建多个同名结构(常量,函数和类), 一般情况下都是一个脚本一个命名空间.</p>

<p>当进行文件的引入的时候,实际上也就引入了空间</p>

<p>非限定名称访问引入空间所在文件: 没有使用被引入的文件空间</p>

<p>限定名称访问: 被加载的文件的空间所在文件不会自动的变成当前空间的子空间</p>

<p>完全限定名称: 被加载的空间所在文件若要直接使用就必须使用完全限定名称</p>

<p>引入空间: use 空间名[\空间元素]; // 空间元素仅限类</p>

<p>引入空间之后: 可以通过限定名称进行访问</p>

<p>引入空间元素: use 空间名\类 [as 别名]; //引入空间元素: 引入之后,可以访问</p>

<p>全局空间
全局空间: 根目录, 如果一个文件中没有指定命名空间,那么该文件下的所有元素(常量,类和函数)都属于全局空间.</p>

<p>全局空间引入之后若要访问,那么必须使用全局空间符号: “\”;</p>

<p>对象的保存与还原</p>

<p>对象是一种复合数据类型, 文件中只能保存字符串数据: 将对象转换成字符串然后再存储到文件.</p>

<p>__tostring: 当对象被当做字符串处理的时候会自动调用. 用户自定义的字符串可以实现保存到文件, 但是没有办法从文件还原成对象本身.</p>

<p>序列化和反序列化
序列化: 将一个大的数据(复合或者简单),按照指定的格式要求(每个数据都有数据类型),转换成一个字符串: 字符串能够反映出结构的关系
Serialize函数: 将一个指定的数据转换成一个可以反映出类型的字符串</p>

<p>反序列化: 将一个拥有结构信息的字符串, 进行”解密”, 变成对应的复合结构的过程.</p>

<p>对象保存
将对象先序列化变成字符串,然后再保存到文件的过程</p>

<p>对象还原
将一个序列化好的对象字符串, 还原成对应的数据类型(对象)</p>

<p>还原得到的结果不是意料中的Person类对象: 因为内存中没有Person类: 应该在对象形成之前在内存中保证有Person类.</p>

<p>对象反序列化后: 只要保证内存中有与需要的类同名的类即可: 同样的反序列化是可以使用自动加载的.</p>

<p>魔术方法
当对象进入休眠的时候(序列化)的时候会自动调用一个魔术方法: __sleep()
当对象由休眠状态激活的时候(反序列化)会自动调用一个魔术方法:__wakeup()</p>

<p>资源数据是没有办法序列化并且进行保存.</p>

<p>序列化的时候就没有资源: 反序列化一定没有资源: 就不能进行资源操作</p>

<p>将对象休眠的时候: 资源是没有保存的意义: 资源不能保存: 通过__sleep将不需要保存的属性给剔除: 返回的是一个需要保存的对象属性的数组</p>

<p>将对象进行唤醒操作时: 唤醒的对象会立马调用对象所属类的唤醒方法(__wakeup)</p>

<p>面向对象相关函数
class_exists: 判断类在内存中是否存在
interface_exists: 判断接口
method_exists: 判断方法</p>

<p>get_class: 获取类名,给的参数是对象</p>

<p>get_parent_class: 获取父类的名字: 只能获取当前对象所在类的上级父类</p>

<p>Instancof: 判断一个对象是否属于指定的类</p>

<p>对象遍历
对象中只有属性: 公有, 受保护和私有. 所谓的对象遍历,指的是将所有的公有属性进行输出
Foreach遍历对象</p>

<p>实现Iterator接口
遍历: 本身没有必要对公有属性进行遍历,有时候希望遍历的是对象内部的某些特殊的数组(不一定是公有的)
Foreach永远只能遍历对象中公有的属性. 需要在foreach进行遍历的时候, 能够修改foreach的内部遍历原理: 让其不要盯着公有属性,而是应该制定某个具体的属性(数组)</p>

<p>若想改变foreach的内部原理而实现对象遍历某个私有或者受保护的属性: 那么当前对象所属的类必须实现某个指定的系统接口: Iterator</p>

<p>代码实现:实现五个抽象方法
Current方法</p>

<p>Key方法</p>

<p>Next方法</p>

<p>Rewind方法</p>

<p>Valid方法</p>

<p>效果</p>

<p>Ecshop安装</p>

<p>Ecshop是一套成熟的 ,市场应用非常广泛的一套电子商务网站模板.
Ecshop中包含了很多成熟的业务逻辑,需要去借鉴.</p>

<p>不单要作为ecshop的使用者, 而且要作为ecshop的管理者: 需要后台.
安装ecshop: 在本机搭建一个ecshop的网站项目: PHP + mysql</p>

<ol>
<li><p>获取ecshop的安装文件(安装包: 原码), 建议去官网: <a href="http://www.ecshop.com">http://www.ecshop.com</a></p></li>
<li><p>解压缩</p></li>
<li><p>进入到解压缩文件夹内部的文件夹</p></li>
<li><p>将Upload文件夹复制一份,放到为网站根目录</p></li>
<li><p>重命名: ecshop</p></li>
<li><p>介绍ecshop的文件夹目录</p></li>
<li><p>了解后台文件夹结构:admin目录</p></li>
<li><p>开始安装: 进入到install/index.php,进入到协议界面</p></li>
<li><p>同意协议,点击下一步,进入到配置安装检测</p></li>
<li><p>Php默认不支持图片处理,需要利用第三方扩展: GD扩展(开启GD扩展)</p></li>
<li><p>重启apache,刷新环境检测界面,重新检测</p></li>
<li><p>点击下一步,进入到配置系统界面: 配置分为三个部分:数据库配置, 后台管理员账号配置, 初始化数据配置
a)  数据库配置</p></li>
</ol>

<p>b)  后台管理员账号配置</p>

<p>c)  杂项配置: 勾选数据</p>

<ol>
<li><p>点击”立即安装”系统傻瓜式安装: 将数据库创建好</p></li>
<li><p>进入后台: 登录之后不断刷新</p></li>
<li><p>进入前台: 不断刷新</p></li>
<li><p>之所有有错误: ecshop本身没有错误: 错误的原因: 因为PHP版本问题: 关闭错误(关闭ecshop的错误提示): 在前台和后台的init.php(初始化文件)
a)  后台init.php: /admin/includes/init.php</p></li>
</ol>

<p>b)  前提init.php:/includes/init.php</p>

<ol>
<li><p>Ecshop做了缓存技术: 前台部分: 需要删除后台缓存文件: /temp</p></li>
<li><p>后台建议删除安装目录和demo目录</p></li>
<li><p>去摸索ecshop的后台是如何进行业务管理的: 布局是框架布局</p></li>
</ol>

<p>回顾（第18天）</p>

<p>接口: interface, 规范结构
接口成员: 常量和公有的抽象方法
实现接口: 类 implements 接口
接口继承: 接口 extends 接口</p>

<p>重载: 同名方法不同参数
PHP重载: 访问一个不存在的或者权限不够的会自动触发的魔术方法
属性重载: __get, __set,__isset,__unset
方法重载:__call,__callStatic
重载意义: 容错处理; 保护对象结构</p>

<p>命名空间: namespace, 本质类似文件夹
所有元素的访问默认都是寻找向上匹配到的第一个空间
空间元素: 类, 常量和函数
访问空间
非限定名称: 直接访问当前目录(当前文件夹)
限定名称: 访问子文件夹
完全限定名称: 从根目录开始()
子空间: 多重文件夹
空间包含: use , 包含空间元素(类), 别名(as 别名)</p>

<p>对象的保存与还原: 序列化和反序列化
魔术方法: __sleep, __wakeup(初始化资源)</p>

<p>面向对象相关函数</p>

<p>对象遍历: 默认的遍历公有属性
迭代器接口: iterator, 接口中有五个抽象方法:分别是用来替换foreach内部的原理</p>

<p>需求: 网站有可能需要使用到多个数据库(oracle和mysql): 要求系统在进行切换数据库的时候, 可以无缝切换(不需要修改系统原代码).</p>

<p>PDO
PDO基础
PDO是一种纯面向对象的数据库操作.(全是类)</p>

<p>PDO: PHP Data Object, PHP数据对象, 数据库抽象层: 将所有的数据库的操作都进行封装, 通过调用该层内容,就可以实现对不同数据库的操作.</p>

<p>PDO操作任何数据库的方法都一样: 提供了三个类</p>

<p>PDO类: 主要负责数据库的连接操作, 然后发送SQL指令</p>

<p>PDOStatement类: 结果处理类,处理所有的查询结果</p>

<p>PDOException类: 异常处理类, 在面向对象中,所有的错误都不会直接报出, 会将错误信息保存到一个对象中,需要通过访问对象才能得到错误信息(异常对象)</p>

<p>开启PDO
PDO是一种扩展,不是PHP自带的: 在PHP5版本之后,默认的就已经开启了PDO, 但是PDO所支持的数据库很多, 系统不知道PDO要操作哪个具体的数据库(类型), 所以需要在使用之前开启对应的数据库扩展.</p>

<p>开启PDO_mysql
1.  找到配置文件,加载PDO对mysql的支持</p>

<ol>
<li> 注意: 当前PHP版本是5.4.7默认的已经开启了PDO扩展,如果是低版本,还需要在扩展的最前面,先开启PDO</li>
<li> 指定扩展路径:extension_dir</li>
<li> 重启apache即生效</li>
</ol>

<p>使用PDO</p>

<ol>
<li><p>连接认证
PDO::__construct($dsn,用户名,密码);
$dsn: data source name,数据源名字
$dsn: 数据库类型:host=主机地址;port=端口信息;dbname=数据库名字;charset=字符集</p></li>
<li><p>发送SQL指令: 服务器执行: 返回执行结果
a)  没有结果集的指令: PDO::exec(),返回的是受影响的行数, 如果SQL语句有错误,那么返回false</p></li>
</ol>

<p>b)  有结果集的指令: PDO::query(), 返回的是PDOStatement类的对象</p>

<p>如果使用query执行没有返回结果sql或者使用exec执行有返回结果的sql的效果怎么样呢?</p>

<p>Query能够执行没有返回结果的SQL语句: 也能正确得到PDOStatement类对象(之后对象不能正确调用PDOStatement类方法)</p>

<p>Exec方法也可以执行有结果返回的SQL指令: 但是返回受影响的行数为0</p>

<ol>
<li> 关闭数据库的连接: PDO没有提供关闭操作(不需要关闭): 自动等到脚本执行结束释放</li>
</ol>

<p>PDO增删改查
增删改查是从用户对数据的理解操作: 对于系统只有两种操作: 读和写</p>

<p>写操作
大部分的时候都是使用exec直接得到结果即可: 受影响的行数, 但是新增操作往往需要获取自增长id.</p>

<p>SQl如果执行错误,可以获取错误信息(SQL语句语法错误)
PDO::errorCode: 获取错误编号
PDO::errorInfo: 获取所有错误信息(数组)</p>

<p>插入操作: 正确结果应该是获取自增长id: PDO::lastInsertId()</p>

<p>更新或者删除操作: 都是获取受影响的行数: exec的结果</p>

<p>读操作
读操作: 使用PDO::query方法</p>

<p>解析数据: PDOStatement下面提供了一系列的解析数据的方法: fetch系列
PDOStatement:: Fetch方法</p>

<p>默认的: 关联索引混合数组</p>

<p>获取关联数组: PDO::FETCH_ASSOC</p>

<p>获取索引数组:PDO::FETCH_NUM</p>

<p>获取对象: 将所有的字段数据都当做对象的属性(公有)</p>

<p>stdClass叫做标准类: 空类</p>

<p>获取对象: 指定类: PDOStatement::fetchObject</p>

<p>如果是获取表中的多条记录: 需要遍历获取所有结果</p>

<p>PDOStatement::fetchAll: 获取所有数据,返回一个二维数组</p>

<p>PDO::FETCH_BOUND: 在进行数据获取的时候, 将指定列的数据绑定到事先准备好的变量中: PDOStatement::bindColumn(字段, 要绑定的变量名);</p>

<p>预处理
事先处理: 先将一条可能需要重复执行的非常复杂的sql指令发送给服务器: 但是告诉服务器不要执行, 等待后续需要执行的时候,再次给定指令让其他执行原来的SQL指令.</p>

<p>预处理是mysql提供的一个功能(跟PDO没有关系).</p>

<p>基本语法
1.  准备预处理: 将要执行的SQL指令发送给服务器
Prepare 预处理名字 from ‘需要执行的SQL指令’;</p>

<ol>
<li> 执行预处理
Execute 预处理名字;</li>
</ol>

<p>预处理可以提供参数: 预处理在准备的时候也许有参数不确定,需要执行的时候才能确定: 可以在准备预处理的时候,使用占位符问号”?”来代替将来可能出现的内容
Prepare 预处理名字 from ‘SQL指令 where id = ?’;</p>

<p>一旦预处理有参数: 那么执行预处理的时候,就必须携带参数
Execute 预处理名字 using 变量; //如果有多个占位符,就跟多个变量,使用逗号分隔</p>

<p>预处理的意义
1.  优化SQL语句, 节省带宽</p>

<p>PDO预处理</p>

<ol>
<li><p>PDO发送预处理语句给服务器: PDO::prepare(),参数就是要执行的预处理语句
PDO为了增加脚本代码的识别度, 不单单支持在预处理语句中使用原始占位符”?”, 还定制了一套自己的占位符(PDO自己解析,mysql不识别): 使用冒号+名字:   :id</p></li>
<li><p>执行预处理: PDOStatement::execute()
预处理语句中有占位符(系统会自动将:id变成?), 在执行的时候一定需要传入参数(前提的预处理中有占位符), 需要给占位符提供数据: PDO提供了三种方法
方案1: 使用数组直接传参: array(‘:id’ =&gt; 3); //如果是使用的原始占位符,那么请使用索引下标array(3);</p></li>
</ol>

<p>方案2: 在执行预处理之前,绑定占位符数据
PDOStatement::bindValue()</p>

<p>PDOStatement::bindParam()</p>

<p>bindValue与bindParam的区别: bindParam绑定一次变量永久生效(变量改变再执行预处理,新数据有效),bindValue只能生效一次
bindParam的变换变量的效果</p>

<p>bindValue变换变量的效果</p>

<p>PDO事务处理</p>

<ol>
<li><p>开启预处理: PDO::beginTransaction();   //内部exec(‘start transaction;’);</p></li>
<li><p>执行事务: 多条写操作的SQL指令</p></li>
<li><p>提交事务
a)  PDO::commit(): 正确提交  exec(‘commit’);
b)  PDO::rollback(): 错误回滚   exec(‘rollback’);</p></li>
<li><p>如果要设置回滚点: 通过PDO::exec();
a)  设置回滚点
$pdo-&gt;exec(‘savepoint sp1’);
b)  回到回滚点
$pdo-&gt;exec(‘rollback to sp1’);</p></li>
</ol>

<p>属性处理
PDO属性处理,指的不是PDO类或者PDOStatement类自己对象的属性: 指的是对应mysql服务器的属性(变量): 改变mysql服务器的服务状态.</p>

<p>获取属性: PDO::getAttribute(PDO常量); //在PDO内部,系统用常量代替了属性的名字
设置属性: PDO::setAttribute(PDO常量,PDO常量); //在PDO内部,系统通过常量值来决定给变量设置什么样的值.</p>

<p>常见的属性
PDO::ATTR_AUTOCOMMIT（1,0）: 控制自动事务, 默认的是1(系统自动提交), 0代表不自动提交</p>

<p>PDO::ATTR_CASE: PHP在获取到记录数据之后, 字段名是什么格式的
PDO::CASE_LOWER: 所有的字段名都小写
PDO::CASE_UPPER: 所有的字段名都大写
PDO::CASE_NATURAL: 默认的,所有的字段名与原始的字段一致</p>

<p>PDO::ATTR_ERRMODE: mysql在遇到错误之后的处理方式(PDO)
PDO::ERRMODE_SILENT: 默认的, 静默模式, 出错了不会报错
PDO::ERRMODE_WARNING: 警告模式, 出错了给警告
PDO::ERRMODE_EXCEPTION: 异常模式, 出错了会抛出异常</p>

<p>PDO::ATTR_PERSISTENT: 是否支持长连接, 默认的数据库连接资源会随着脚本的执行结束而结束: 但是实际上mysql服务器支持长连接: 脚本执行结束之后不会立即释放连接资源,下一个脚本还可以继续使用.
TRUE: 支持长连接: 若要支持长连接, mysql说了还不算, apache还要允许长连接
FALSE: 默认的,不支持(脚本执行结束一定释放连接资源)</p>

<p>PDO异常处理
异常处理是面向对象语言的一种错误处理机制: 将所有的错误信息存放到异常类对象中.</p>

<p>异常处理机制</p>

<p>异常处理机制: 将所有的有可能出现错误的语句都被动的被异常进行监听(try),一旦出错就立马被异常类的对象(PDOException)捕捉到: 捕捉到之后就不再执行语句,而是自动进入到异常处理(catch)
Try{
//所有有可能出错的要执行语句
//一旦出错:系统自动new PDOException,对象的内存地址赋值给$e
}catch(PDOException  $e){
//通过PDOException类的对象$e去调用相关方法或者属性显示错误信息
}</p>

<p>异常处理
PDO连接数据库的异常捕捉.</p>

<p>PDO默认的错误处理模式是静默模式: 异常捕捉不到: 必须开启异常模式</p>

<p>抛出异常
有时候也许代码不会出现问题, 但是有可能代码执行的逻辑不是预期的逻辑: 不希望代码继续执行: 可以选择主动抛出异常: throw new PDOException;</p>

<p>反射
反射: reflection, 反射是指通过某种机制能够查看到某些结构的内部情况,如类,函数和方法.</p>

<p>反射机制在面向对象语言中,是一种非常重要的机制. 能够让我们软件开发工程师能够更好的了解一些结构的内部关系, 从而实现更好的应用.
反射的应用在一些比较大的项目中用的比较, 小项目中几乎不用.(主要是编译型语言使用)</p>

<p>在PHP中提供了很多反射类来查看不同的结构: 
ReflectionClass: 反射类
ReflectionFunction: 反射函数
ReflectionMethod: 反射方法</p>

<p>类反射
类反射: 通过反射类(ReflectionClass)去了解一个类的内部结构(通常不是用户自定义类,而是系统类)
ReflectionClass: export(‘类名’): 将一个指定类的内部结构给反映出来(属性,方法和类常量)</p>

<p>获取类的对象: ReflectionClass::__construct(‘类名’);</p>

<p>该类(ReflectionClass)有很多方法,可以获取指定类中的很多信息
ReflectionClass::getMethods: 获取所有的方法
ReflectionClass:getConstants: 获取所有常量</p>

<p>反向代理</p>

<ol>
<li><p>可以通过ReflectionClass反向代理获取指定类的对象
ReflectionClass::newInstance()</p></li>
<li><p>反向代理: 调用指定类的方法: ReflectionMethod
获取ReflectionMethod类的对象</p></li>
</ol>

<p>ReflectionMethod类下有一个方法叫做invoke: 代理调用方法</p>

<p>如果当前要调用的是静态方法</p>

<p>封装PDO类</p>

<ol>
<li><p>创建一个MyPDO类文件: 初始化属性</p></li>
<li><p>增加一个连接数据库的方法: new PDO</p></li>
<li><p>增加一个错误模式: 模拟PDO设置(使用常量)
增加常量</p></li>
</ol>

<p>增加方法让用户选择模式</p>

<p>将PDO类实例化得到的对象定义成属性保存(跨方法)</p>

<p>回顾（第19天）</p>

<p>PDO: 数据抽象层(PHP数据对象)</p>

<p>PDO: 初始化数据库连接操作,发送SQL指令
PDOStatement: 主要进行数据的获取
$stmt-&gt;setFetchMode(PDO::FETCH_ASSOC);
$stmt-&gt;fetch(); //都是获取关联数组
PDOException: 异常处理</p>

<p>反射: 反射结构内部(类), 反向代理(代理生成对象, 代理调用方法)</p>

<p>项目需求
仿照ECshop做一个电子商务网站: 都分为前台和后台部分
前台: 供用户使用
后台: 管理员使用(维护数据)
前端: 界面的设计(UI和JS), 主要是效果
后端: 服务器的处理逻辑(PHP)</p>

<p>后台部分功能
权限管理: 会话技术, 模板技术, 验证码技术等
商品分类: 无限极分类(递归), 增删改查
商品管理: 分页技术, 回收站思想, 文件上传, 图片处理等</p>

<p>给大家提供了静态模板(静态网站), HTML文件,css文件,js文件都已经到位. 使用PHP将网站变成动态.</p>

<p>项目设计
项目的设计分为三层管理: 项目架构, 代码架构, 数据库架构</p>

<p>项目架构</p>

<ol>
<li> 确定项目的内容(需求分析)                                 电子商务网站</li>
<li> 网站开发语言: 3P(PHP,JSP,ASP),Java,C#等                  PHP语言</li>
<li> PHP开发网站的方式: 源码,框架,二次开发                    源码开发</li>
</ol>

<p>代码架构</p>

<ol>
<li> PHP支持多种开发思想: 面向对象,面向过程,混编               混编(对象+过程)</li>
<li> 代码目录结构: 扁平化和树状结构                            树状结构</li>
<li> MVC设计思想(模型:类,视图:HTML和控制器:PHP)</li>
<li> 编程规范: 
a)  代码风格: 注释
b)  字符集: UTF-8</li>
<li> 任何一张数据表都应该有一个对应的操作类专门负责操作(封装SQL)</li>
</ol>

<p>数据库架构</p>

<ol>
<li> 考虑项目使用数据库的性能和安全: 关系型和非关系型             关系型数据库</li>
<li> 数据库品牌很多: Oracle, DB2, Mysql等                            Mysql数据库</li>
<li> 考虑是否使用数据库特殊功能: 事务,外键等                       存储引擎:innodb</li>
<li> 数据库的规范
a)  命名规范: 任何一张表都应该有表前缀(数据库名字简写)
b)  数据表的制作必须要写到comment
c)  字符集的统一: UTF8
d)  命名规范: 表应该使用下划线法</li>
</ol>

<p>项目开发</p>

<p>搭建目录结构</p>

<ol>
<li><p>确定网站根目录:E:/class/php150710/shop</p></li>
<li><p>模拟ecshop: 前台和后台没有分开,只是通过文件夹进行分层实现</p></li>
<li><p>在后台中建立相应的目录结构</p></li>
<li><p>增加虚拟主机: <a href="http://www.shop.com">www.shop.com</a></p></li>
<li><p>将后台所有的模板文件都放到/admin/templates/</p></li>
</ol>

<p>登录功能
任何一个功能,一定是顺着是用户的操作开始.
要求: 所有的相关请求请求同一个php文件: 如登录,退出,获取登录表单,都请求权限对应的PHP文件: privilege</p>

<p>显示表单</p>

<ol>
<li><p>输入URL: <a href="http://www.shop.com/admin/privilege.php">http://www.shop.com/admin/privilege.php</a> /admin/privilege.php</p></li>
<li><p>权限管理要做的事情: 获取登录表单. /admin/privilege.php</p></li>
<li><p>将样式,js和图片文件全部加载到网站中: 从ecshop中获取过来. 分别放到admin/styles, admin/images, admin/js</p></li>
</ol>

<p>用户表单提交
1.  修改表单提交对象: form中的action. /admin/templates/login.html</p>

<ol>
<li> 用户输入用户名和密码之后: privilege.php应该处理用户的提交操作,需要通过判断用户的请求来确定处理方式. /admin/privilege.php</li>
</ol>

<p>需要为用户的请求分配一个动作关键字: 通过动作来区分用户的具体请求, 从而实现服务器为不同的请求作出不同的处理. 动作: action(act)
A)  在表单中增加一个参数:act, 隐藏域 /admin/templates/login.html</p>

<p>B)  后台应该通过用户的动作(act)来判断用户的请求: 接收动作 /admin/privilege.php</p>

<p>C)  根据动作进行不同的服务处理. /admin/privilege.php</p>

<ol>
<li><p>接收用户提交的数据. /admin/privilege.php|act=check</p></li>
<li><p>合法性验证数据, 用户名和密码都不能为空. /admin/privilege.php|act=check</p></li>
<li><p>解决乱码问题: header解决. /admin/privilege.php</p></li>
<li><p>合理性验证: 用户名和密码在数据库能够配对.
a)  搭建数据库环境</p></li>
</ol>

<p>b)  任何数据库的操作都必须最终是由指定的DB类来实现.将DB类引入项目. /admin/includes/DB.class.php</p>

<p>c)  任何一张表的操作都应该有一个专门的类: 对其进行操作(类的作用是封装SQL语句). /admin/includes/Admin.class.php</p>

<ol>
<li> 调用Admin类进行对表sh_admin的数据查询操作: 用户名和密码. /admin/privilege.php
a)  通过用户名获取用户信息: 可以判断用户名是否存在</li>
</ol>

<p>增加通过用户名获取用户信息的方法. /admin/includes/Admin.class.php</p>

<p>防止用户SQL注入</p>

<p>判断查询结果: 错误处理: 用户不存在. /admin/privilege.php|act=check</p>

<p>b)  将取出的用户信息与用户输入的密码进行比较:确定密码是否正确</p>

<p>初始化文件</p>

<p>将所有的非业务逻辑性的代码存放到一个公共文件中: init.php</p>

<ol>
<li><p>在公共目录下创建init.php. /admin/includes/init.php</p></li>
<li><p>初始化文件既然要被所有文件包含: 解决公共问题: 脚本显示字符集问题</p></li>
<li><p>通过项目的初始化文件,控制整个项目对待错误的处理方式.ini_set函数</p></li>
<li><p>建立目录常量: 任何一个目录都建一个常量保存对应的绝对路径.</p></li>
<li><p>任何一个被用户直接可以访问的PHP文件(如privilege.php)应该加载init.php文件,并且可以使用里面的内容. /admin/privilege.php</p></li>
</ol>

<p>封装公共函数
1.  建议一个专门公共函数脚本: functios.php. /admin/includes/functions.php</p>

<ol>
<li><p>创建第一个公共函数: 跳转提示函数</p></li>
<li><p>将公共函数文件包含到init.php中. /admin/includes/init.php</p></li>
<li><p>凡是加载了init.php的php文件都可以直接使用公共函数./admin/privilege.php|act=check</p></li>
</ol>

<p>修改提供跳转提示机制
以前利用header实现跳转提示: 现在在项目中使用html中的标签实现跳转</p>

<ol>
<li><p>在跳转函数中加载跳转html文件. /admin/includes/functions.php</p></li>
<li><p>修改跳转模板,显示对应的数据. /admin/templates/redirect.html</p></li>
</ol>

<p>自动加载</p>

<ol>
<li><p>自动加载是一种函数, 应当封装到公共函数文件. /admin/includes/functions.php</p></li>
<li><p>在需要类的地方可以直接使用,而不需要手动加载类./admin/privilege.php|act=check</p></li>
</ol>

<p>配置文件
配置文件: 用来控制项目的运行(核心内容控制): 有一些修改需要发生的时候, 一定需要进入到项目原代码. 在项目的外围(单独有个文件)来对核心部分进行控制.</p>

<ol>
<li><p>新增配置文件: 利用脚本中的return. /admin/conf/config.php</p></li>
<li><p>使用配置文件: 任何一个后台脚本都需要使用数据库操作: 都会需要数据库信息. 在公共文件中加载配置文件. /admin/includes/init.php</p></li>
<li><p>在需要使用数据库信息操作数据库的位置,使用配置文件信息. /admin/includes/DB.class.php</p></li>
</ol>

<p>首页功能</p>

<ol>
<li><p>登录成功,跳转到首页. /admin/privilege.php|act=check</p></li>
<li><p>进入系统首页: index.php. /admin/index.php</p></li>
<li><p>类似ecshop,后台应该是框架结构. 加载框架. /admin/index.php</p></li>
<li><p>修改框架: 对每个frame增加src,找到对应的部分. /admin/templates/index.html</p></li>
<li><p>光只请求index.php无法实现加载具体的frame: 意味着浏览器必须传入参数才能告诉服务器到底该加载什么内容. /admin/templates/index.html</p></li>
<li><p>服务器应该根据不同的参数,作出不同的服务响应. /admin/index.php</p></li>
</ol>

<p>项目总结
以图形的形式, 将今天的内容完全串起来.</p>

<p>Shop项目请求过程(第20天)</p>

<p>会话技术
会话: 在一次联通过程中(浏览器没有关闭),所进行的多次请求(请求了多个脚本)
会话技术: 在浏览器不关闭的情况下, 对一个网站进行多次访问, 整个的访问过程称之为一次会话. 因为HTTP协议的无状态和无连接, 导致虽然浏览器没有关闭,但是在多个脚本之间请求的时候, 脚本之间无法实现数据的共享: 会话技术就是为了解决在浏览器进行多次请求的过程中,能够实现数据跨脚本共享.</p>

<p>会话技术分类
会话技术因为有两个不同的技术,实现的目标也不怎么一致: 整个将会话技术分为两类.</p>

<p>Cookie技术: cookie是一种服务器将数据保存到浏览器, 然后浏览器能够将数据重新携带回服务器,从而实现服务器识别浏览器的多次请求的技术.</p>

<p>Session技术: session是一种将数据保存在服务器端,实现跨脚本共享数据的技术. Session技术依赖cookie存在.</p>

<p>Cookie技术</p>

<p>Cookie技术: 将数据保存到浏览器的技术.</p>

<p>Cookie技术的实现: HTTP协议中提供了一对cookie操作协议
Set-cookie: HTTP响应, 允许服务器把数据通过HTTP协议携带给浏览器.
Cookie: HTTP请求, 允许浏览器将服务器保存的数据携带给服务器.</p>

<p>Header设置cookie
Header函数用来修改HTTP协议的: HTTP响应
Header(‘set-cookie:cookie名字=值’);</p>

<p>查看浏览器保存的cookie</p>

<p>验证: 会话技术cookie会失效(被浏览器清除): 关闭浏览器再重新打开</p>

<p>Header没有办法很好的控制cookie, header可以实现任何http协议的修改.</p>

<p>Setcookie函数
PHP提供了一个专门设置cookie的函数: setcookie
Setcookie(名字,值);</p>

<p>获取cookie
浏览器能够在访问同一个网站的时候,会自动将以前的cookie数据携带给服务器.</p>

<p>Apache不能获取cookie数据, 只能PHP来做.
PHP会将所有的cookie数据(浏览器携带的)保存到超全局预定义数组中: $_COOKIE</p>

<p>Cookie生命周期</p>

<p>生命周期: cookie会在什么时间内失效(失效的cookie才会被浏览器清除)
默认的: cookie的生命周期是会话技术(浏览器关闭)</p>

<p>Setcookie函数的第三个参数: 就是用来设置cookie的生命周期: 没有给定第三个参数, 是因为第三个参数有默认值: 0, 就代表会话技术(浏览器关闭)
第三个参数是时间戳: 生命长度</p>

<p>证明: 10秒的cookie已经过期: 获取一次</p>

<p>Cookie作用范围</p>

<p>Cookie作用域: 默认的, cookie只针对自己所在目录及其子目录生效, 上级目录不能访问.</p>

<p>通常的解决方案是: cookie整站有效: 网站根目录: setcookie的第四个参数.</p>

<p>Cookie跨域
Cookie对不同的主机名可以共享, 但是默认的不支持.</p>

<p>域名: Domain Name, IP地址的别名
顶级域名: .com / .cn / .net / .org 
一级域名: 在顶级域名的左边,增加一个字段: baidu.com / itcast.cn /apache.org / php.net
二级域名: 在一级域名又增加一个字段: <a href="http://www.itcast.cn">www.itcast.cn</a> / gz.itcast.cn / bj.itcast.cn</p>

<p>Cookie跨域: cookie可以在不同的二级域名下共享数据. 通过setcookie的第五个参数来实现.指定方式是共享的一级域名</p>

<p>Cookie特性
Cookie特性主要是从$_COOKIE中处理</p>

<ol>
<li><p>Cookie设置是通过setcookie函数实现: 没有办法存储数组: setcookie不论名字还是值都只能是普通数据(字符串数据)</p></li>
<li><p>$_COOKIE永远是一维数组: 但是可以想办法让$_COOKIE变成二维数组(不是手动修改)</p></li>
<li><p>在服务器端(PHP)不要修改$_COOKIE里面的内容: 修改无效</p></li>
</ol>

<p>Session技术
Session技术: 将数据保存在服务器端,实现跨脚本共享数据.
Session技术依赖cookie实现.</p>

<p>Session默认的将数据保存到文件中: 文件不会随着脚本执行的结束而删除, 就可以实现将数据放到文件中, 下一个脚本又从文件中读取数据.</p>

<p>Session文件的保存位置: 默认没有指定,就是操作系统的临时目录(C:/windows/temp)</p>

<p>修改session文件的存储目录: D:/server/temp</p>

<p>Session原理
Session在PHP中有一套内部机制, 只需要用户(程序员)去简单的触发即可.</p>

<p>实现session</p>

<p>Session要使用: 基本上使用手动模式</p>

<ol>
<li><p>激活session系统: 开启session: session机制对外提供了一个操作接口: 函数session_start()</p></li>
<li><p>存储数据: 系统提供了一个专门存储数据的容器,只要用户将数据保存到对应的容器中,系统就会自动的将容器内部的内容,保存到session文件中. $_SESSION</p></li>
</ol>

<p>注意: session序列化是选择性序列化: 不会对$_SESSION中的下标序列化,只对值进行序列化
3.  使用session数据: 跨脚本: 在一个新的脚本中,拿着”钥匙”开锁后就可以取出里面的内容.</p>

<p>注意: 即便只是访问$_SESSION,系统提示session文件被修改</p>

<p>Session实现具体原理
Session机制内部有很多功能, 内部自己协调.</p>

<p>开启session: session_start()
1.  激活session: session机制开始工作
2.  获取sessionID: PHPSESSID
a)  第一次: 系统自动生成,而且会将sessionID保存到cookie
b)  第二次: 从cookie中获取sessionID
3.  初始化变量$_SESSION: 空数组
4.  系统会拿着sessionID取到session文件夹寻找对应的session文件(没有就创建一个)
5.  将session文件中保存的数据进行反序列化保存到$_SESSION中
6.  Session系统会设定一个监听程序: 监听脚本执行结束</p>

<p>使用session: $_SESSION</p>

<p>脚本执行结束: session机制监听到脚本要结束了: 将$_SESSION中的数据进行序列化,然后写入到sessionID对应的session文件.</p>

<p>证明: session在开启之后, 一个脚本中一定会对session文件操作两次</p>

<p>Shop使用session</p>

<ol>
<li><p>在需要保存数据到另外一个脚本共享的地方,使用session保存数据. /admin/privilege.php|act=check</p></li>
<li><p>去到需要使用用户信息的位置开启session取出数据. /admin/index.php?act=top</p></li>
<li><p>在具体的显示数据的位置,使用$_SESSION中的数据. /admin/templates/top.html</p></li>
<li><p>将时间戳转换成时间日期格式.  /admin/templates/top.html</p></li>
</ol>

<p>默认的session文件有一定的减少概率.</p>

<p>删除session
删除session指的是删除session对应的文件.</p>

<p>Session_destroy(): 删除当前sessionID对应的session(凡是要操作session需要先开启session)</p>

<p>Session常用配置
Session的表现特性都是由php.ini中进行配置实现的(大部分都是用默认配置)</p>

<ol>
<li><p>Session默认是必须使用cookie实现</p></li>
<li><p>Session名字: cookie对应的sessionID名字叫做: PHPSESSID</p></li>
<li><p>Session默认是需要手动开启, 自动session关闭掉了</p></li>
</ol>

<p>使用自动session: 不需要手动开启session(session_start()不用了)</p>

<p>因为不是所有的地方都需要使用session: session会产生session文件占用服务器的磁盘空间(从来不用自动session)</p>

<ol>
<li><p>Session的生命周期其实受cookie的影响: 默认的cookie的生命周期是会话结束</p></li>
<li><p>Session对应的ID(cookie)的作用范围都是网站根目录</p></li>
<li><p>Session数据的序列化方式使用PHP的序列化实现.</p></li>
<li><p>Session垃圾回收机制: 一旦触发垃圾回收,系统会自动一次性清理所有的过期的session</p></li>
<li><p>Session有自己的生命周期: 1440秒</p></li>
<li><p>Session可以通过配置实现将sessionid信息绑定到URL(a标签中)</p></li>
</ol>

<p>Session特点
Session是利用$_SESSION来进行数据保存.
$_SESSION中不允许使用索引下标</p>

<p>Session面试题</p>

<p>如果禁用cookie能否使用session?如果可以,如何实现?
如果禁用cookie理论上来讲,会影响session: session基于cookie实现, session的SESSID利用cookie保存.
但是如果禁用了cookie之后,session就不能用了. 如果有用户恶意(选择)禁用cookie: 可以理解为用户不愿意使用我们的网站.</p>

<p>如果非要实现: 可以通过a链接实现</p>

<p>手动a链接: 用户自己给a链接的href
Session_name(): 获取或者设置session名字(没有参数就是获取,有参数就是设置)
Session_id(); 获取或者设置sessionID(没有就是获取,有就是设置)</p>

<ol>
<li><p>在保存session数据界面, 获取session信息(name和id),嵌入到URL中.</p></li>
<li><p>在需要共享session数据的界面: 先获取session信息, 然后再获取session数据</p></li>
</ol>

<p>自动a链接: 通过修改session默认的机制(PHP配置文件php.ini)
1.  修改session默认的只允许使用cookie的原则</p>

<ol>
<li> 开启URL转换sessionid信息的配置</li>
</ol>

<p>以上修改完了之后: 系统会自动在a标签中加入sessionid信息, 而且还能在获取session数据界面自动的从a标签去获取sessionid信息
效果1: 所有的a标签都会自动加上session信息</p>

<p>效果2: session使用的时候,会自动的从a标签读取session信息</p>

<p>退出功能
1.  增加用户操作入口. /admin/templates/top.html</p>

<ol>
<li><p>增加logout处理操作. /admin/privilege.php?act=logout</p></li>
<li><p>Privilege.php默认的是接收post数据,但是退出的操作给的get数据. /admin/privilege.php</p></li>
</ol>

<p>登录更新
1.  用户既然有上次登录信息显示: 用户每次登录之后都应该记录当前登录的时间和ip地址. /admin/privilege.php?act=check</p>

<ol>
<li><p>增加一个更新用户信息的方法. /admin/includes/Admin.class.php</p></li>
<li><p>需要判断执行的结果. /admin/privilege.php?act=check</p></li>
</ol>

<p>回顾（第21天）
会话技术: cookie和session</p>

<p>Cookie: 服务器将数据保存到浏览器上的技术(HTTP协议: set-cookie和cookie)
Header设置cookie: header(‘set-cookie:name=value’)
Setcookie函数: setcookie(名字,值,过期时间,作用范围,跨域)
$_COOKIE接收cookie数据</p>

<p>Session: 将数据保存在服务器端的技术(依赖cookie)
开启session: sessino_start()
存储或者使用session数据: $_SESSION
脚本执行结束: 取出$_SESSION中的数据进行序列化保存到session文件</p>

<p>Cookie和session的区别
1.  数据存储的方式不一样: cookie是键值对,session是文件
2.  数据存储的位置不一样: cookie是在浏览器,session是在服务器
3.  数据的安全不一样: cookie不安全, session是安全的(相对)</p>

<p>验证码
验证码: captcha, 是一种用于区别人和电脑的技术
原理（Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试)</p>

<p>如何区分计算机和人类?
只要是文字性的内容,计算机一定可以识别; 计算机是不能识别图片内容的, 但是人眼非常容易识别图片中的内容.</p>

<p>验证码本质: 将文字性的内容印在图片上, 用来实现计算机和人类的区别.</p>

<p>图片扩展了解
PHP本身无法操作图片.
PHP但是可以利用提供的图片扩展操作图片.</p>

<p>图片扩展有很多: 常用的是GD</p>

<p>加载GD扩展: 在安装ecshop的时候,已经加载过GD扩展: 所有的GD扩展函数image开头</p>

<p>PHP操作图片</p>

<ol>
<li><p>增加画布(创建画布)
图片资源 Imagecreatetruecolor(宽,高);</p></li>
<li><p>在画布上增加内容(文字)
a)  给将要在图片上添加的内容分配颜色: 先将颜色关联到图片资源,然后才可以使用
颜色句柄[整型] Imagecolorallocate(图片资源,红色,绿色,蓝色); //颜色可以使用数字0-255或者使用十六进制#十六进制</p></li>
</ol>

<p>b)  写文字: 只能写英文(ASCII码表上的内容)
布尔 Imagestring(图片资源,文字大小,起始X坐标,起始Y坐标,写内容,颜色);
字体大小: 1-5</p>

<ol>
<li> 保存输出
Imagepng(图片资源[,保存位置]);
保存: 使用两个参数</li>
</ol>

<p>输出: 使用一个参数</p>

<ol>
<li> 释放资源(资源建议释放)
布尔结果 Imagedestroy(图片资源);</li>
</ol>

<p>验证码图片</p>

<ol>
<li><p>生成随机验证码数据</p></li>
<li><p>创建画布</p></li>
<li><p>填充背景色: imagefill(图片资源,起始位置X,起始位置Y,颜色句柄);  //imagefill: 找到一个像素点之后, 如果发现周围相邻的像素点与当前像素点颜色一样(全部黑色)就会被自动渲染.</p></li>
<li><p>添加文字内容: 先分配颜色</p></li>
<li><p>保存输出: 验证码都是输出</p></li>
<li><p>释放资源</p></li>
</ol>

<p>中文验证码</p>

<p>两个注意点
获取随机中文: 在PHP中都是以字节为单位操作数据,中文在不同字符集中有不同字节数
中文写入函数: imagettftext(图片资源,字体大小, 字体旋转角度, 字体的起始X,字体起始Y, 字体文件,内容, 颜色);</p>

<ol>
<li><p>创建画布: 填充背景色</p></li>
<li><p>获取随机中文</p></li>
<li><p>将中文写入到图片</p></li>
<li><p>保存输出图片</p></li>
<li><p>销毁资源</p></li>
</ol>

<p>封装验证码类</p>

<ol>
<li><p>验证码类是一种需要被包含的文件. /admin/includes/Captcha.class.php(工具类)</p></li>
<li><p>给验证码类增加属性: 长和宽, 验证码字符串长度等</p></li>
<li><p>初始化属性: 构造方法</p></li>
<li><p>生成验证码图片</p></li>
<li><p>创建画布: 给定背景色</p></li>
<li><p>增加干扰源: 干扰线和干扰点
a)  增加干扰线: imageline(资源,起始X,起始Y,终点X,终点Y,颜色句柄)</p></li>
</ol>

<p>b)  增加干扰点: imagestring</p>

<ol>
<li> 增加文字
a)  获取随机文字(英文)</li>
</ol>

<p>b)  写入文字: 调用生成随机字符串的函数</p>

<ol>
<li><p>输出验证码图片</p></li>
<li><p>释放资源</p></li>
</ol>

<p>Shop应用验证码
1.  在登录表单中,增加一个验证码的链接,能够请求得到一张验证码图片. /admin/templates/login.html</p>

<ol>
<li><p>接收请求,产生一个验证码图片./admin/privilege.php?act=captcha</p></li>
<li><p>调整验证码类: 适应当前的网站. 修改宽和高适应当前项目. /admin/includes/Captcha.class.php</p></li>
<li><p>修改类内部的原码: 让代码能够适应当前的小的图片.</p></li>
</ol>

<p>验证码验证原理</p>

<p>修改验证码类
在服务器生成验证码的时候: 应该将验证码字符串保存到session中. /admin/includes/Captcha.class.php</p>

<p>验证验证码
1.  接收用户提交的验证码. /admin/privilege.php?act=check</p>

<ol>
<li><p>合法性验证: 验证码不能为空. /admin/privilege.php?act=check</p></li>
<li><p>合理性验证: 用户输入的与服务器保存的是否一致./admin/privilege.php?act=check</p></li>
<li><p>验证码类应该负责处理所有跟验证码相关的信息: 验证验证码应该是验证码类分内的事情. /admin/includes/Captcha.class.php</p></li>
<li><p>修改验证码的验证方式: 调用验证码类进行验证./admin/privilege.php?act=check</p></li>
<li><p>后台所有几乎地方都要用到session: 每次都必须开启session, 应该讲session的开启放到init.php. /admin/includes/init.php</p></li>
</ol>

<p>点击更换验证码
1.  给验证码图片(img)增加点击事件. /admin/templates/login.html</p>

<ol>
<li> 如何让一个图片(img标签)能够重新在不改变成个页面的情况下,单独发起新的请求呢?本质发起请求应该是浏览器去做: 浏览器只会在链接(src)发生改变之后才会重新发起请求: 修改图片的src, 但是要保证每次请求的一定是获取图片的src:privilege.php?act=captcha&amp;随机内容</li>
</ol>

<p>首页验证
只有登录成功的用户,才能够访问首页,否则必须登录.</p>

<ol>
<li> 当用户访问首页的时候,必须进行身份验证: 只有登录的才能访问,否则跳转到登录页面. /admin/index.php</li>
</ol>

<p>记住用户信息
当用户在登录的时候,选择了记住用户信息之后,在7天之内,下次访问网站的时候, 可以不用验证身份.</p>

<ol>
<li><p>增加用户操作入口: 让用户可以有一个选择,能够选择记住用户信息. /admin/templates/login.html</p></li>
<li><p>应该在用户提交信息验证成功之后: 判断用户是否选择了记住用户信息. /admin/privilege.php?act=check</p></li>
<li><p>在需要验证用户身份的界面(index.php),不单单只判断session, 还需要判断cookie信息. /admin/index.php</p></li>
<li><p>帮助用户登录: 验证用户的id是否真实有效. /admin/index.php</p></li>
<li><p>增加通过用户id获取用户信息的方法. /admin/includes/Admin.class.php</p></li>
<li><p>判断用户登录信息./admin/index.php</p></li>
<li><p>假设登录成功(记住用户信息成功),应该将用户信息存入到session数据</p></li>
<li><p>在系统帮助用户进行登录成功之后, 应该更新用户登录信息.</p></li>
<li><p>应该在用户点击退出功能的时候,实现真正的退出: 用户下次一定需要手动登录. /admin/privilege.php?act=logout</p></li>
</ol>

<p>回顾(第22天)</p>

<p>验证码: Captcha
验证码本质: 图片(将随机字符串印在图片上面)
图片操作: 创建画布; 写入文字[分配颜色,背景填充]; 保存输出; 销毁资源</p>

<p>验证码验证
第一次请求脚本: 获取验证码图片. (session跨脚本)
第二次请求脚本: 提交验证码数据</p>

<p>商品分类</p>

<p>商品分类操作就是增伤改查四个操作.</p>

<p>商品分类查询</p>

<ol>
<li><p>增加用户操作入口. /admin/templates/menu.html</p></li>
<li><p>创建商品分类的处理脚本. /admin/category.php</p></li>
<li><p>先接受动作,再根据动作做出不同的请求处理.</p></li>
<li><p>判断动作处理请求: 列表功能,需要加载模板显示数据</p></li>
<li><p>搭建数据库环境</p></li>
<li><p>任何一张数据表的操作,都应该有一个对应的 专门的类来进行操作处理. /admin/includes/Category.class.php</p></li>
<li><p>在需要操作数据库的地方,调用Category类操作数据库. /admin/category.php?act=list</p></li>
<li><p>增加获取所有的商品分类的方法. /admin/includes/Category.class.php</p></li>
<li><p>显示所有的商品分类. /admin/templates/category_list.html</p></li>
</ol>

<p>无限极分类
很多的分类都是有子分类的,而且子分类也可能拥有子分类, 不确定层级的分类称之为无限极分类.(本质与遍历文件夹及其子目录是一样的)</p>

<p>无限极分类原理
从所有分类中去找出指定一层分类(顶级分类), 然后通过当前查出来的顶级分类,去寻找自己的子分类.
但是在查询子分类的过程中,又有可能子分类还有子分类,又可以使用查询顶级分类的子分类的方式,来实现同样的查询.</p>

<p>实现无限极分类
对一个二维数组进行操作: 变成一个有顺序的二维数组</p>

<ol>
<li><p>在进行所有商品分类查询的时候: 对查询的结果进行无限极分类. /admin/includes/Category.class.php</p></li>
<li><p>创建一个能够进行无限极分类的方法.可以调用实现无限极分类.</p></li>
<li><p>创建无限极分类方法.</p></li>
<li><p>无限极分类必须是由指定的首层开始向下寻找: 默认的首层是顶层,在数据表中对应的就是c_parent_id  = 0</p></li>
<li><p>找出所有的商品分类中的符合条件的商品分类.</p></li>
<li><p>在找出来的商品分类中,有可能有子分类: 想办法找出指定分类的子分类: 当前方法已经解决了这个问题: 只要在合适的地方调用方法自己就可以实现: 递归点</p></li>
<li><p>因为新方法的调用,得到的结果是放到每个方法自己内部的局部变量$lists中,没有办法实现合并: 静态变量.</p></li>
<li><p>任何一个递归都有两个要素: 递归点和递归出口: 当前方法的递归出口: 所有的分类找完也没有找到自己的子分类(整个数组遍历结束)</p></li>
<li><p>为了增加缩进来确定分类的父子关系. 需要给每一个商品分类增加一个额外的属性. 确定当前商品分类是在第几层方法的递归调用的时候查出来的.</p></li>
<li><p>将缩进级别控制添加到每一层找出来的合适的商品分类中.</p></li>
<li><p>外部在进行输出商品分类的时候: 应该根据级别进行缩进. /admin/templates/category_list.html</p></li>
</ol>

<p>删除商品分类</p>

<ol>
<li><p>增加用户操作入口. 增加删除点击事件. /admin/templates/category_list.html</p></li>
<li><p>接收动作,处理请求. /admin/category.php?act=del</p></li>
<li><p>接收要删除的数据</p></li>
<li><p>删除逻辑: 不是叶子节点的商品分类(没有子分类)不能删除. 删除之前必须判断当前商品分类是否是叶子节点</p></li>
<li><p>增加方法,验证当前的商品分类是否是叶子节点. /admin/includes/Category.class.php</p></li>
<li><p>对结果进行处理. /admin/category.php?act=del</p></li>
<li><p>删除叶子节点.  /admin/category.php?act=del</p></li>
<li><p>新增删除商品分类的方法. /admin/includes/Category.class.php</p></li>
<li><p>判断删除结果. /admin/category.php?act=del</p></li>
</ol>

<p>新增商品分类</p>

<ol>
<li><p>新增用户操作入口: 让用户有一个点击链接进入到新增商品分类的表单页面. /admin/templates/menu.html || /admin/templates/category_list.html</p></li>
<li><p>接收动作,处理请求. /category.php?act=add</p></li>
<li><p>获取新增商品分类的表单. </p></li>
<li><p>获取所有的商品分类信息: 任何一个子分类都可以添加在已有分类下. /category.php?act=add</p></li>
<li><p>将获取的所有的商品分类在表单中解析. /admin/templates/category_add.html</p></li>
<li><p>考虑到用户输入完数据之后会选择提交: 确定用户提交的对象. /admin/templates/category_add.html</p></li>
<li><p>为了让服务器知道当前操作是将数据插入到数据库, 还需要提供一个动作: post请求,所以使用隐藏域. /admin/templates/category_add.html</p></li>
<li><p>服务器接收动作,处理请求. /admin/category.php?act=insert</p></li>
<li><p>接收数据</p></li>
<li><p>合法性验证: 商品分类名字不能为空, 商品排序必须是数组
a)  商品分类名字不能为空</p></li>
</ol>

<p>b)  商品排序必须是整型</p>

<ol>
<li><p>合理性验证: 同一分类下商品分类名字不能重复.</p></li>
<li><p>增加一个验证同名方法. /admin/includes/Category.class.php</p></li>
<li><p>判断结果. /admin/category.php?act=insert</p></li>
<li><p>将数据插入到数据库. /admin/category.php?act=insert</p></li>
<li><p>新增插入商品分类的方法. /admin/includes/Category.class.php</p></li>
<li><p>判断结果给出提示. /admin/category.php?act=insert</p></li>
</ol>

<p>更新商品分类</p>

<ol>
<li><p>增加用户操作入口: 给用户提供一个链接, 点击就可以进入到商品编辑界面:点击可以编辑商品. /admin/templates/category_list.html</p></li>
<li><p>服务器接收动作,处理请求: /admin/category.php?act=edit</p></li>
<li><p>接收要编辑的对象: 商品分类的id.</p></li>
<li><p>获取商品分类id对应的商品分类</p></li>
<li><p>新增获取商品分类的方法. /admin/includes/Category.class.php</p></li>
<li><p>判断查询的数据是否存在. /admin/category.php?act=edit</p></li>
<li><p>加载模板显示数据</p></li>
<li><p>在模板中显示数据. /admin/templates/category_edit.html</p></li>
<li><p>获取所有商品分类: 商品分类的编辑就包含转换不同的父级商品分类: /admin/category.php?act=edit</p></li>
<li><p>显示所有的商品分类. /admin/templates/category_edit.html</p></li>
<li><p>在下拉列表中匹配对应的上级商品分类. </p></li>
<li><p>修改表单的提交对象: 提交给商品分类. </p></li>
<li><p>更新商品分类必须按照id进行更新: 必须在表单中将商品分类的id给传递过去. </p></li>
<li><p>接收动作,处理请求. /admin/category.php?act=update</p></li>
<li><p>接收要更新的数据</p></li>
<li><p>合法性验证: 名字不能为空, 排序必须是整型</p></li>
<li><p>合理性验证: 相同的父级分类下不能有同名分类.</p></li>
</ol>

<p>问题1: 更新的时候自己与自己重名(不改变上级分类的情况下)
18. 更新到数据库</p>

<ol>
<li><p>新增更新商品分类的方法. /admin/includes/Category.class.php</p></li>
<li><p>判断更新结果. /admin/category.php?act=update</p></li>
</ol>

<p>问题2:当将商品分类的上级分类指向自己或者自己的子分类之后,商品分类就不再显示?</p>

<p>编辑商品分类（第23天）</p>

<p>一.    在更新商品分类的时候, 如果只是更新商品分类的排序(不变更对应的父分类),那么会导致在更新的时候系统判断当前指定的父分类下会出现重复的问题: 在进行重复性验证的时候应该排除自己.</p>

<ol>
<li><p>需要在进行商品分类同名验证的时候,将当前商品分类的id传递过去. /admin/category.php?act=update</p></li>
<li><p>更新的验证方法: 将第三个参数作为一个判断条件: 又不应该影响原来的逻辑. /admin/includes/Category.class.php</p></li>
<li><p>修改查询数据的逻辑: 应该按照排序字段进行升序排序. /admin/includes/Category.class.php</p></li>
</ol>

<p>二.    当进行商品分类编辑的时候,如果选择的上级分类是当前商品分类自己或者其子分类,最终更新之后会导致自己及其子分类都永远不能被查询出来: 解决方案:  从源头上解决问题, 不让用户在进行商品分类编辑的时候, 选择上级分类的时候,可以看到自己及其自己的子分类.</p>

<ol>
<li><p>在查询所有商品分类的时候,增加一个排除id: 排除自己不需要获取. /admin/category.php?act=edit</p></li>
<li><p>修改方法,支持参数. /admin/includes/Category.class.php</p></li>
<li><p>修改无限极分类: 做到排除商品分类.</p></li>
</ol>

<p>商品管理
商品管理中会涉及到以下知识: 分页, 文件上传, 图片处理(缩略图,水印)</p>

<p>商品列表(查)
1.  增加用户操作入口: 给用户增加操作链接. /admin/templates/menu.html</p>

<ol>
<li><p>接收动作处理请求: /admin/goods.php</p></li>
<li><p>先加载模板. /admin/goods.php?act=list</p></li>
<li><p>搭建数据库环境.</p></li>
<li><p>获取所有的商品信息. /admin/goods.php?act=list</p></li>
<li><p>增加商品表对应的类. /admin/includes/Goods.class.php</p></li>
<li><p>通过对象调用方法,获取所有的商品信息. /admin/goods.php?act=list</p></li>
<li><p>增加获取所有商品的方法. /admin/includes/Goods.class.php</p></li>
<li><p>显示所有的商品信息. /admin/templates/goods_list.html</p></li>
<li><p>用图片显示对应的新品,精品,热销和上架. /admin/templates/goods_list.html</p></li>
<li><p>更新所有已有的货号,变成ITCAST + 0000的规则</p></li>
</ol>

<p>分页技术
因为一次性显示所有的数据: 会耗费很多的资源, 而且给用户操作带来不便.
使用分页技术来解决以上问题.</p>

<p>分页技术分为两个大类
服务器分页: 使用limit查询数据时进行数据限制
浏览器分页: 一次性查出所有数据,分到不同的div等标签中,使用js进行轮换</p>

<p>利用服务器分页来实现商品的分页查看</p>

<ol>
<li><p>要实现分页, 本质利用的是SQL语句的limit子句.测试一下. /admin/includes/Goods.class.php</p></li>
<li><p>想办法修改每页的起始位置,前提: 每页显示的数据量是固定的.需要通过参数来实现步长和起始位置的计算.</p></li>
<li><p>在调用的时候应该传入不同的页码./admin/goods.php?act=list</p></li>
<li><p>应该让页码动态的变起来</p></li>
<li><p>增加可以点击的分页操作链接. /admin/templates/goods_list.html</p></li>
<li><p>想办法动态的生成页码链接: 总记录数, 每页显示的记录数, 当前页码
a)  求出总记录数. /admin/goods.php?act=list</p></li>
</ol>

<p>新增获取总记录数的方法. /admin/includes/Goods.class.php</p>

<p>b)  每页显示的记录数: 使用配置文件来进行控制. /admin/conf/config.php</p>

<p>在需要使用到分页的时候,应用配置文件./admin/goods.php?act=list</p>

<p>c)  当前页码</p>

<ol>
<li><p>求出总页数</p></li>
<li><p>动态生成整个链接.</p></li>
<li><p>将动态生成的页码字符串在模板中显示. /admin/templates/goods_list.html</p></li>
</ol>

<p>封装分页</p>

<p>封装分页类: 有两种方式
方案1: 将获取数据这件事情与分页链接合并到一起,都在分页类: 分页类自带查询数据
方案2: 将获取数据以及分页链接进行分离: 数据由自定义SQL使用limit实现, 分页链接由分页类实现.</p>

<ol>
<li><p>在公共文件夹下创建分页类. /admin/includes/Page.class.php</p></li>
<li><p>分页类的功能就是产生分页链接. 使用静态方法产生分页链接. </p></li>
<li><p>在需要使用分页链接的地方调用分页类实现. /admin/goods.php?act=list</p></li>
<li><p>为分页类增加其他分页链接功能
a)  按钮分页(首页,上一页,下一页,末页)</p></li>
</ol>

<p>b)  下拉列表分页(select)</p>

<p>c)  输入分页(input提交): 必须增加表单才能提交</p>

<ol>
<li> 因为form表单提交的数据有可能超出总页数长度(不符合条件),需要验证</li>
</ol>

<p>注释: 虽然分页类中实现了页码校验,但是没有对数据库进行校验,效果不足: 将校验放到类的外部进行校验./admin/goods.php?act=list</p>

<ol>
<li><p>增加数据提示文字功能.</p></li>
<li><p>所有的链接都是在PHP类中产生, 前端不可能进行样式控制: 需要给所有的分页链接做一些特殊的标志, 让其在外部可以通过js操作dom或者使用css进行样式控制.</p></li>
<li><p>让输入框分页与其他几个分页显示在一行: 对form进行行元素显示</p></li>
</ol>

<p>删除商品(回收站)</p>

<p>删除商品: 本质不是真删除, 而是将商品移动到另外一个位置(回收站)
回收站: 增加用户操作缓冲</p>

<p>数据库设计方案
方案1: 增加一张商品回收站表: 将”删除”的上移动到回收站表(两次写操作)
方案2: 增加一个字段,通过字段状态来描述商品的性质
给商品增加状态字段: g_is_delete, 0表示默认没有被删除(正常商品)</p>

<ol>
<li><p>增加用户操作入口: 给用户一个可以选择加入到回收站的链接. /admin/templates/goods_list.html</p></li>
<li><p>接收动作,处理请求. /admin/goods.php?act=del</p></li>
<li><p>增加一个修改状态的方法. /admin/includes/Goods.class.php</p></li>
<li><p>判断结果. /admin/goods.php?act=del</p></li>
<li><p>已经删除的商品不应该在查询商品列表中出现: 修改查询的逻辑. /admin/includes/Goods.class.php</p></li>
<li><p>增加一个用户防错处理: 防止用户是不小心点的删除. Js实现. /admin/templates/goods_list.html</p></li>
</ol>

<p>回收站查看商品</p>

<ol>
<li><p>增加用户操作入口: 在菜单中增加一个可以查看链接. /admin/templates/menu.html</p></li>
<li><p>接收动作,处理请求./admin/goods.php?act=trash</p></li>
<li><p>修改方法: 因为不管是回收站还是正常商品都是从商品表中查询出对应的多条商品记录: 可以共用一个方法. 通过状态控制. /admin/includes/Goods.class.php</p></li>
<li><p>修改获取分页总记录数的方法. 跟上面方法一样. </p></li>
<li><p>加载显示商品回收站数据的模板. /admin/goods.php?act=trash</p></li>
<li><p>显示数据. /admin/templates/goods_trash.html</p></li>
<li><p>给回收站增加分页功能./admin/goods.php?act=trash</p></li>
<li><p>获取数据的时候,传入分页信息(每页显示数据量和页码).</p></li>
<li><p>调用分页类产生分页链接.</p></li>
<li><p>显示分页链接信息. /admin/templates/goods_trash.html</p></li>
<li><p>增加回收站商品显示数量的配置文件. /admin/conf/config.php</p></li>
<li><p>纠正商品回收站获取每页显示数据量的代码. /admin/goods.php?act=trash</p></li>
</ol>

<p>数据表名永远是固定死的: 一旦表名被修改,意味着必须修改源代码.</p>

<p>构造表全名
表全名: 表前缀(DB类) + 表名(表类), 表类是继承自DB类.</p>

<ol>
<li><p>应该在DB类中增加一个方法: 构造表全名(DB类可以访问表类中的表名属性). /admin/includes/DB.class.php</p></li>
<li><p>在任何SQL语句需要表名的地方, 调用构造表全名的方法. Admin类,Goods类,Category类</p></li>
<li><p>改进构造表全名方法: 因为有时候表操作需要多表连接操作.</p></li>
</ol>

<p>新增商品（第24天）
1.  增加用户操作入口. 增加用户新增商品的链接. /admin/templates/menu.html</p>

<ol>
<li><p>接收动作,处理请求. /admin/goods.php?act=add</p></li>
<li><p>新增表单模板中有多个选项卡: 3个, 但是只有一个表单form, 每一个选项卡都是一个table</p></li>
<li><p>获取所有的商品分类信息. /admin/goods.php?act=add</p></li>
<li><p>在模板中显示所有的商品分类信息./admin/templates/goods_add.html</p></li>
<li><p>修改表单提交对象,同时要增加处理动作. /admin/templates/goods_add.html</p></li>
<li><p>接收动作,处理请求. /admin/goods.php?act=insert</p></li>
<li><p>接收用户提交的数据: 字段很多, 使用数组接收: 数组下标严格对应的字段的名字</p></li>
<li><p>合法性验证: 名字不能为空, 货号格式, 价格有效, 商品分类必须选择, 库存必须为整数, 排序也必须是正整数
a)  名字验证: 不能为空</p></li>
</ol>

<p>b)  货号验证:格式必须为10位长度, 前六位是ITCAST,后四位是数字字符串</p>

<p>c)  价格验证</p>

<p>d)  商品分类验证: 不能为空</p>

<p>e)  库存验证</p>

<p>f)  排序验证</p>

<ol>
<li><p>合理性验证: 货号如果填了,就必须保证唯一性</p></li>
<li><p>增加一个验证货号唯一性的方法. /admin/includes/Goods.class.php</p></li>
<li><p>如果用户没有输入货号: 系统必须自动生成货号,在原有的货号上自增. /admin/goods.php?act=insert</p></li>
<li><p>新增一个生成货号的方法. /admin/includes/Goods.class.php</p></li>
<li><p>将数据插入到数据库. /admin/goods.php?act=insert</p></li>
<li><p>新增插入商品数据的方法. /admin/includes/Goods.class.php</p></li>
<li><p>判断执行结果. /admin/goods.php?act=insert</p></li>
</ol>

<p>文件上传(封装类)
文件上传的核心操作: $_FILES接收数据, move_uploaded_file移动数据</p>

<p>文件上传条件: 服务器允许上传, 浏览器支持上传</p>

<p>将文件上传的功能封装成工具类: 上传类</p>

<ol>
<li><p>新建一个文件上传类. /admin/includes/Uploads.class.php</p></li>
<li><p>文件上传,接收数据已经被$_FILES实现了,只要将文件移动到指定目录即可. 使用静态方法实现. </p></li>
<li><p>判断要移动的文件数组是否合理合法</p></li>
<li><p>判断系统错误: $file[‘error’]</p></li>
<li><p>文件类型限定: 从指定允许列表进行匹配</p></li>
<li><p>验证文件大小是否符合当前需求.</p></li>
<li><p>文件没有错误: 移动到指定目录</p></li>
<li><p>规范文件名字: 随机生成新名字.</p></li>
<li><p>调用随机生成名字的函数(方法),移动到指定目录</p></li>
</ol>

<p>商品文件上传</p>

<ol>
<li><p>找到需要使用文件上传地方: 文件上传是否成功不影响商品的数据插入到数据库, 但是要提醒要用户文件是否上传成功. /admin/goods.php?act=insert</p></li>
<li><p>将文件类型的设置放到配置文件. /admin/conf/config.php</p></li>
<li><p>在需要使用类型限定的时候访问配置文件. /admin/goods.php?act=insert</p></li>
<li><p>上传文件是用户行为,所以不论上传成功与否都应该告知用户. /admin/goods.php?act=insert</p></li>
</ol>

<p>缩略图
缩略图: 比原图要小(大小size, 尺寸)</p>

<p>制作缩略图
缩略图的制作离不开原图</p>

<ol>
<li><p>读取原图: 资源
Resource Imagecreatefromjpg/gif/png: 有三个函数分别读取三类图片</p></li>
<li><p>制作缩略图资源: 自己按照指定的size设定. Imagecreatetruecolor</p></li>
<li><p>采样复制: 从原图中采样(取区域), 复制到缩略图
Imagecopyresampled(缩略图资源,原图资源,缩略图的起点X,缩略图起点Y,原图采样起点X,原图采样起点Y,缩略图放宽,缩略图放高,原图采样宽,原图采样高)
获取图片信息的函数: getimagesize返回一个数组</p></li>
</ol>

<p>采样复制</p>

<ol>
<li><p>保存输出缩略图: 一般会按照原图的格式进行保存(也可以使用png)
Imagepng/jpeg/gif: 保存成不同格式的图片</p></li>
<li><p>释放资源(原图资源通常很大)</p></li>
</ol>

<p>缩略图补白
有时候缩略图的比例并不一定与原图的比例(宽高比)一样, 如果让原图采样后完全填充缩略图,会导致图片变形, 给用户看到的感觉就很差, 应该尽可能的让图片保留原来的比例, 但是会导致缩略图有一部分位置是空着的, 这个时候通常会将缩略图的底变成白色, 俗称”补白”.</p>

<p>补白缩略图的宽高原理</p>

<p>封装图片处理类
图片类当前只负责处理缩略图.</p>

<ol>
<li><p>制作缩略图类. /admin/includes/Image.class.php</p></li>
<li><p>增加一个静态方法,制作缩略图.</p></li>
<li><p>判断原图资源释放存在. </p></li>
<li><p>构造函数名: 打开文件资源必须使用指定的函数打开(跟图片格式有关).</p></li>
</ol>

<p>在类中定义了一个静态属性$mime</p>

<ol>
<li><p>创建缩略图资源</p></li>
<li><p>补白:背景填充</p></li>
<li><p>采样复制</p></li>
<li><p>求采样复制的时候,缩略图的起始位置(居中)和宽高
a)  求出缩略图宽高</p></li>
</ol>

<p>b)  求出缩略图起始位置</p>

<ol>
<li> 保存输出缩略图</li>
</ol>

<p>商品应用缩略图</p>

<ol>
<li> 找到需要使用缩略图的位置: 文件上传成功的时候才制作缩略图. /admin/goods.php?act=insert</li>
</ol>

<p>注意: 缩略图是服务器系统处理, 跟用户一点关系都没有,所以即便是出错也不需要告知用户.</p>

<p>多文件上传
多文件上传: 用户一次上传多个文件.</p>

<p>用户上传多个文件的时候,有两种方案:
方案1: 每个表单域file, 名字不同, 服务器在接收的时候,每个文件都有一个单独的五要素数组</p>

<p>方案2: 每个表单域file,名字相同([]), 服务器会进行元素合并,每个五要素都是一个数组</p>

<p>方案1解决方案: 遍历$_FILES数组,取出其中的每一个文件,调用上传函数进行单个文件上传.</p>

<p>方案2解决方案: 需要遍历文件数组, 组成单个的文件五要素再上传</p>
        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/tjloved" class="avatar"><img src="https://avatars1.githubusercontent.com/u/15959225?v=3&amp;s=60" width="48" height="48"></a> <a href="https://github.com/tjloved">tjloved</a> maintains <a href="https://github.com/tjloved/tjloved.githup.io">我的博客</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <a href="https://github.com/tjloved/tjloved.githup.io/tarball/master" class="tar">tar</a><a href="https://github.com/tjloved/tjloved.githup.io/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
    <p class="name"></p>
  </div>

  
</body>
</html>
