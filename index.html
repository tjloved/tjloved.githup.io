<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" href="stylesheets/github-dark.css">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>我的博客</title>
  <meta name="description" content="">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">我的博客</h1>
    </header>
    <div id="container">
      <p class="tagline"></p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/tjloved/tjloved.githup.io/tarball/master" class="download-button tar"><span>Download</span></a>
          <a href="https://github.com/tjloved/tjloved.githup.io/zipball/master" class="download-button zip"><span>Download</span></a>
          <a href="https://github.com/tjloved/tjloved.githup.io" class="code">View 我的博客 on GitHub</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
          <p>欢迎来到我的博客
LINUX系统操作（上）
目录
一、简介： 2
1、什么是linux  2
2、发展史：    2
二、安装    2
1、创建一个虚拟机系统（攒机，创建一台裸机）    2
2、设置启动盘（引导顺序）   5
3、启动电脑，开始安装 7
三、根目录讲解   16
四、shell的操作， 18
1、什么是shell  18
2、Linux命令组成部分 18
3、常用的命令集。   19
（1）ls   19
（2）pwd  20
（2）cd切换目录   20
（3）clear 清屏命令   20
（4）字符界面与图形界面的切换 20
（5）系统时钟命令：    20
（6）系统关机重启命令。  21
五、 vi编辑器操作    22
1、什么是vi编辑器    22
2、vi的三种操作模式 22
3、使用vi    23
4、基本操作    23
（1）命令行模式下操作 23
（2）编辑模式下使用    24</p>

<p>一、简介：
1、什么是linux
是一个软件，是一个操作系统软件，是一个性能稳定的多用户网络操作系统。很多服务架构在linux服务器上，比如典型的LAMP LNMP 架构.
特点：
免费、开源
支持多线程，多用户
安全性好
对内存和文件管理优越。
2、发展史：
目标：了解unix与linux的关系，linux的内核与各发行版本。
（1）unix
（2）linux
（3）linux的主要产品</p>

<p>二、安装
安装方式：使用一个虚拟机软件，来安装linux系统，通过虚拟机软件来虚拟出一台电脑。
虚拟机软件：VMare workstation和 virturalbox
安装步骤非常简单：单击下一步即可。
1、创建一个虚拟机系统（攒机，创建一台裸机）
（1）单击新建开始创建</p>

<p>（2）指定一个虚拟电脑的名称，和安装的系统类型</p>

<p>（3）给虚拟机指定内容大小，最小是256MB，</p>

<p>（4）设置虚拟硬盘大小设置方式</p>

<p>动态设置：给虚拟机硬盘动态的分配空间
固定设置：一次性把虚拟机硬盘需要的空间，给划分出来。
（5）设置虚拟机硬盘的大小，以及虚拟机系统的存储位置。</p>

<p>（6）单击create创建完成，</p>

<p>2、设置启动盘（引导顺序）
计算机在启动时，设置的引导顺序，
在安装系统时，设置光盘（u 盘）引导，在安装完成系统后，设置硬盘引导。</p>

<p>把光盘塞进光驱里面，（让虚拟机系统加载系统的安装镜像）</p>

<p>3、启动电脑，开始安装</p>

<p>安装步骤：
（1）选择第一个，开始安装</p>

<p>（2）检测硬键是否有错误，可以使用tab键切换到”skip”进行略过。</p>

<p>（3）选择安装界面的提示文字，自然选择谁（中文简体）</p>

<p>（4）选择键盘，使用“美国英语式”</p>

<p>（5）重新初始化所有。</p>

<p>（6）给超级管理员（root）用户创建一个秘密</p>

<p>（7）选择自定义分区：</p>

<p>分区的讲解：
分区的目的，便于存储数据，
window里面的分区，采用cdef…作为盘符。</p>

<p>window里面的文件系统：比如要读取c盘里面的nihao.txt文件。读取方式：c:/nihao.txt</p>

<p>linux的分区：
在linux里面至少需要两个分区：一个是根分区（/）和swap分区（交换分区）
swap分区，是交换分区，是当linux里面的内存空间不够用时，拿出该分区的空间作为内存使用。一般设置为内存的1到2倍大小，最多不要超过1G。</p>

<p>linux的文件系统：就是一个倒置的树。</p>

<p>linux的文件系统与分区的关系，</p>

<p>（8）开始分区
选择标准分区:</p>

<p>建立一个swap分区：</p>

<p>建立一个根分区</p>

<p>（9）选择“软件开发工作站”，会安装系统需要的所有的软件。</p>

<p>开始安装：</p>

<p>4、安装完成后，启动虚拟机
在启动时创建一个普通用户。</p>

<p>注意点：如果安装完成系统后，需要重启，则需要修改引导顺序，改为硬盘优先（或把安装光盘拿出也可以）</p>

<p>三、根目录讲解
根目录下面的文件夹</p>

<p>通过讲解根目录下面的文件，知道，哪些文件夹存储哪些文件。
 /bin
是存储所有的用户的命令文件。</p>

<p> /dev 
是存储硬件设备文件，在linux里面所有的硬件都是文件，要操作该硬件就要操作该硬件对应的文件。
比如：光驱对应的硬件是：/dev/cdrom或/dev/sr0</p>

<p> /home
用户的家目录，每创建一个用户，会在该目录下面创建一个和用户名同名的一个文件夹。
当用户登录后，就默认进入到自己的家目录里面，来进行操作。
注意：root 用户的家目录在/root里面。</p>

<p> /lib
系统的库目录，就类似于 window里面的window目录。
 /media<br>
多媒体目录，用于存储系统的一些媒体文件。
 /mnt （该目录不是必须的）
映射目录，就类似于 window里面使用U盘，移动硬盘的盘符，通过把U盘或移动硬盘的映射到该目录里面，读取该目录就读取u 盘或移动硬盘里面的内容。
 /proc 
内存的映射目录，
 /sbin 
超级管理员的命令目录，该目录里面存储的命令只有超级管理员能够使用，比如关机命令，添加用户，删除用户的命令，都在该目录里面。
 /tmp 
临时文件目录，
 /var 
可变文件存储目录，比如一些日志文件，数据库文件（mysql里面的data目录）等等，我们也可以使用该目录布局网站，
比如商城网站：/var/www/shop
比如门户网站：/var/www/cms
 /boot 
存储系统引导文件目录，
 /etc 
配置文件目录，存储一些系统的配置文件（比如用户配置文件passwd,shadow），系统服务的配置文件，等等，也可以存储，我们自己安装的一些程序文件的配置文件。
 /lost+found 
失物招领处，存储系统非正常关机的一些文件，由系统自动调用，无需我们干预。
 /opt
存储第三方程序文件的目录，
 /root
root用户的家目录，
 /usr 
该目录就类似于window系统里面的C:\Program Files  是默认软件的安装路径。
比如我们后面安装的apache软件、mysql软件，php软件，redis,memcache等等软件可以安装到该目录里面。
四、shell的操作，
1、什么是shell
shell就是命令集，用户通过（字符界面或命令行界面）发送shell 命令集来驱动内核调用硬件完成命令。</p>

<p>2、Linux命令组成部分
如果是在图形界面可以单击右键选择终端，就会进入到命令行操作。</p>

<p>语法格式：
命令   选项   参数（操作对象）
比如： ls  -l   /home
比如： useradd   xiaowang   </p>

<p>3、常用的命令集。
（1）ls 
查询指定路径下面的文件内容。
选项：
-l   是以详情的格式来显示文件内容。</p>

<p>-a  显示出所有的文件，包括隐藏文件，在linux里面，以 .开头的文件是以隐藏文件。</p>

<p>（2）pwd
查看当前工作的路径</p>

<p>（2）cd切换目录
切换目录可以使用绝对路径，也可以是相对路径。</p>

<p>cd  /  直接切换到根目录
cd  ..切换到上一级目录。
（3）clear 清屏命令
（4）字符界面与图形界面的切换
从图形界面直接切换到字符界面   init 3 
从字符界面直接切换到图形界面   init 5 （必须安装了图形界面才能操作，必须是本地操作）
（5）系统时钟命令：
date 查看系统时间
date –s  设置系统时间，
语法：date   –s   “年-月-日 时:分:秒” </p>

<p>以上设置，如果系统重启了，则时间又恢复到以前的状态。
要想让时间永久有效，则要把时间信息写入到计算机的 cmos（理解成计算机的硬件）里面。
clock –r  查看计算机的硬件时钟。
clock –w  把系统时钟写入到硬件时钟里面。</p>

<p>注意：在更改时，不要设置为系统安装之前的时钟。
比如，我们安装系统的时间是2015年10月22日8点整；如果要把时钟改为2015年10月22日8点整之前的时间，则无法启动系统了。
（6）系统关机重启命令。
超级管理员用户才可以设置，普通用户在默认时，没有 shutdown命令权限的。
shutdown  –h   10    表示10分钟之后，关闭计算机
shutdown  –r   10    表示10分钟之后，重启计算机
shutdown  -k   10    表示10分钟之后，关闭计算机，（并不是真正的关闭计算机，吓唬其他登录的用户）
shutdown –c  取消关机
shutdown –h now  表示立即关闭计算机 
shutdown –r  now  表示立即重启计算机
halt  等同于shutdown –h now  表示立即关闭计算机 
reboot等同于shutdown –r  now  表示立即重启计算机
当执行shutdown 命令后，会在其他用户的界面出现如下提示的。</p>

<p>五、 vi编辑器操作
1、什么是vi编辑器
Vim是一个功能强大的全屏幕文本编辑器，是Linux/UNIX 上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。 
Vim没有菜单,只有命令。</p>

<p>2、vi的三种操作模式</p>

<p>有命令行模式，输入模式（编辑模式），末行模式（尾行模式） 
在不同的模式下，执行不同的操作，</p>

<p>3、使用vi</p>

<p>vi    filename  使用vi编辑该文件，如果该文件不存在，则自动创建
vi  +  filename 使用vi编辑该文件，光标定位到最后一行。
vi  +n  filename：使用vi编辑该文件，光标定位到第n行。
vi +/string filename：使用vi编辑该文件，光标定位到string所在的行。<br>
vi  filename1   filename1  使用vi可以编辑多个文件，使用  :n切换到下一个文件，使用:prev切换到上一个文件。</p>

<p>4、基本操作
（1）命令行模式下操作
移动光标操作
字符级
            上       下       左        右(键盘箭头键)
            h(左)    j(下)    k(上)    l(右)
行级
            $   行尾
            0   行首
文档级
            G   文档尾部
            1+G 文档首部（1和G联合使用）
            n+G 定位到文档的第n行</p>

<p>删除内容操作
dd      删除本行
n+dd    当前行开始往下删除n行
x       删除单个字符
复制内容的操作
yy      复制本行
p       粘贴内容
                    [删除的内容也可以被粘贴,
                    删除内容和复制内容一样被先存入系统的缓存里边]
n+yy    从当前行往下复制n行
（2）编辑模式下使用
从命令模式进入编辑模式
    a:  光标后面输入内容
    i:  光标前面输入内容
    o:  另起空白行进入编辑模式
    s:  删除光标所在字母
（3）尾行模式下面使用
:q      退出vi编辑器
    :w      保存修改
    :wq     保存并退出编辑
    :q!     强制退出，不保存修改
    :wq!    强制保存退出
    :set  number  (:set nu)  给编辑器设置序号
    :set  nonumber (:set nonu) 取消序号显示</p>

<ol>
<li>三种模式
命令(默认)、尾行、编辑模式</li>
<li>
<p>尾行模式
:
:q      退出vi编辑器
:w      保存修改
:wq     保存并退出编辑
:q!     强制退出，不保存修改
:wq!    强制保存退出
:set  number  (:set nu)  给编辑器设置序号
:set  nonumber (:set nonu) 取消序号显示
:/内容/     搜索指定内容，小写"n"寻找下一个，大写"N"，找上一个
/内容       搜索指定内容</p>

<p>:s/被替换内容/替换内容/     替换当前行的第一个目标内容
:s/被替换内容/替换内容/g    替换当前行全部目标
:%s/被替换内容/替换内容/g   替换文档的全部目标</p>

<p>:n          跳转到n行</p>
</li>
<li>
<p>命令模式操作
① 光标移动
    字符级
        上       下       左        右(键盘)
        h(左)    j(下)    k(上)    l(右)
    单词级
        e  (本)下个单词的尾字母end
        w   下个单词的首字母word
        b  (本)上个单词的首字母before
    行级
        $   行尾
        0   行首
    段落级
        {   本(上一个)段落首部
        }   本(下一个)段落尾部
    屏幕级
        L   屏幕尾部
        H   屏幕首部
            不支持跨屏幕跳转
    文档级
        G   文档尾部
        1+G 文档首部（1和G联合使用）
        n+G 定位到文档的第n行</p>

<p>② 删除内容
        dd      删除本行
        n+dd    当前行开始往下删除n行
        x       删除单个字符</p>

<pre><code>    d+光标移动的区域
    d+$     从当前位置一直删除至行尾(包括光标所在位置)
    d+0     从当前位置一直删除至行首(保留光标所在字母)
    d+e     从当前位置一直删除至本单词结尾
    d+w     从当前位置删除至下个单词的首字母(下个单词首字母有保留)
    d+}     删除到段落的尾部(包括光标所在字母)
    d+{     删除到段落的首部(不包括光标所在字母)
    d+n+G   删除到第n行(连同光标所在行，不用考虑向下、向上删除)
</code></pre>

<p>③ 内容复制
        yy      复制本行
        p       粘贴内容
                [删除的内容也可以被粘贴,
                删除内容和复制内容一样被先存入系统的缓存里边]
        n+yy    从当前行往下复制n行</p>

<pre><code>    y+光标移动的区域
</code></pre>

<p>④ 快捷操作
        r+字符  快速替换单个字符
        u       撤销undo
        .       点，重复上一次命令
        J       大写J，合并两行</p>
</li>
<li>
<p>编辑模式
从命令模式进入编辑模式
a:  光标向后移动一位
i:  光标没有动作
o:  另起空白行进入编辑模式
s:  删除光标所在字母</p>

<p>从编辑模式退回命令模式
esc</p>

<p>对编辑的内容进行保存
编辑模式----》命令模式----》尾行模式(保存退出动作)</p>
</li>
</ol>

<p>LINUX系统操作（中）
目录
一、linux系统的启动流程    1
1、选择操作系统  1
2、选择登陆界面（字符界面还是图形界面）  1
3、挂载文件系统  3
二、用户管理  4
1、用户与用户组的概念 4
2、用户与用户组的配置文件   4
（1）group 配置文件   5
（2）/etc/gshadow配置文件 6
（3）用户配置文件/etc/passwd    6
（4）/etc/shadow  7
3、用户组管理命令   7
（1）添加用户组  7
（2）修改用户组信息    8
（3）删除用户组  8
4、用户管理    8
（1）添加用户 8
（2）修改用户 9
（3）删除用户 9
5、密码管理    10
6、禁止账号登陆  11
7、添加删除组成员   11
8、赋予普通用户特殊权限  11
三、文件管理  13
1、文件目录权限  13
2、权限的说明 13
3、更改文件权限  15
（1）更改文件权限   15
（2）更改文件拥有者    17
（3）更改文件所属组    18
4、目录管理    18
（1）创建目录 18
（2）删除目录 19
5、文件创建与删除   19
6、复制文件或目录   20
7、移动文件或目录   21
8、搜索匹配行 21
9、显示文件内容  22
四、系统定时任务    23</p>

<p>一、linux系统的启动流程
1、选择操作系统
通过配置文件/etc/grub.conf里面的配置来完成</p>

<p>如果计算机安装了多个操作系统，则会有多个14行到17行的内容。
计算机默认启动的操作系统是通过 第10行的“default=操作系统的序号”来设置的。
2、选择登陆界面（字符界面还是图形界面）
linux系统里面，有字符界面，还有图形界面，到底进入到哪个界面是由/etc/inittab 配置文件里面的配置来决定的。
使用vi   /etc/inittab打开配置文件
（1）运行级别</p>

<p>在 linux里面运行级别有7种，
0     关机
1     单用户模式启动，使用该模式可以修复简单的系统故障，就类似与window里面的安全模式。
2      多用户模式，不开启网络服务
3      字符界面
4      未定义，保留模式，给linux的开发人员使用的。
5      图形界面
6      重启
一般常用是3（字符界面）和5（图形界面）</p>

<p>第26行说明当前系统进入图形界面，如果系统启动后，默认进入字符界面则需要把第26行改为： id:3:initdefault;</p>

<p>（2）根据运行级别运行对应的目录里面的服务。 
ls –l /etc/rc.d </p>

<p>如果我们选择了3运行级别，则运行rc.d/rc3.d目录里面的服务。 </p>

<p>以K开头的是需要关闭的服务 
以S开头的是需要开启的服务。 
不同的运行级别会运行不同的服务。 
注意：rc.d目录下面的rc.sysinit文件是每个运行级别都要运行的。 
rc.local文件是登录系统之前运行的一个文件。 </p>

<p>3、挂载文件系统
（1）挂载的概念
把系统里面的目录和磁盘里面的某个区域建立对应关系
（2）/etc/fstab配置文件来完成挂载分区。</p>

<p>第一个列：分区设备文件名或UUID（硬盘通用唯一识别码）
第二个列：挂载点（系统的目录）
第三个列：文件系统类型
第四个列：挂载参数
第五个列：指定分区是否被dump备份，0代表不备份，1代表每天备份，2代表不定期备份
第六列：指定分区是否fsck检测，0代表不检测，其他数字代表检测的优先级，那么当然1优先级比2高
二、用户管理
1、用户与用户组的概念</p>

<p>在计算机里面创建的用户必须属于一个组，一个组中可以有多个用户，一个用户可以分别属于多个组，但是要注意：一个用户只能有一个初始组，可以有多个附属组 </p>

<p>初始组（主组）：给用户一开始分配的或加入的组，一个用户只能有一个初始组 
附加组（附属组）：后面给用户分配的组，附属组可以有多个。 
2、用户与用户组的配置文件
在linux 里面，通过使用配置文件来记录用户与用户组信息的。
有4个配置文件；
用户组的配置文件：/etc/group
用户组的密码文件：/etc/gshadow
用户的配置文件 :/etc/passwd
用户密码的配置文件：/etc/shadow
（1）group 配置文件</p>

<p>每一行是表示一个组，用冒号分成了4列，
第一列：表示组名
第二列：表示组密码，此处是x，x不是真正的密码，真正的密码是存储到/etc/gshadow配置文件里面的。
第三列：组的id(GID)  0表示是管理员组  1-499是系统组，系统默认创建的组。500-65535之间是我们自己创建的组。
第四列：隶属于该附属组的用户。
（2）/etc/gshadow配置文件</p>

<p>每一行是表示一个组，用冒号分成了4列，每一行和/etc/group配置文件里面的行一一对应。
第一列：组的名称
第二列：组的密码，如果为! 或空则表示没有密码。
第三列：组的管理员，
第四列：隶属于该附属组的用户。
（3）用户配置文件/etc/passwd</p>

<p>每一行表示一个用户，通过使用冒号分成7列，
第一列：用户的名称
第二列：用户的密码，此处的x不是真正的密码，真正的密码是保存在/etc/shadow文件中的，
第三列：用户的id,如果是0，则是超级管理员，1-499是系统创建的用户（伪用户）的id。
    500-65535是我们自己创建的用户的id,如果把一个普通用户的id改成0，则该用户变成了超级管理员了。注意：伪用户不能登录，不能删除。
第四列；用户的主组的组id,
在创建一个用户时，如果没有指定该用户的主组，则会自动生成一个和用户名同名的组，该组就该用户的主组。
第五列：用户的备注信息。
第六列：用户的家目录
第七列：shell类型，执行的命令集类型。</p>

<p>（4）/etc/shadow</p>

<p>每一行表示一个用户, 每一行和/etc/passwd配置文件里面的行一一对应。
第一列：用户的名称
第二列：用户的密码，该密码是加密后的密码，如果有!或*则是没有密码。
3、用户组管理命令
（1）添加用户组 
语法：groupadd  [选项] 组名 
-g   添加用户组时指定组ID</p>

<p>（2）修改用户组信息 
语法：groupmod   [选项] 组名
-n 修改组名
-g 修改组ID </p>

<p>案例1：把wagangzai改名为datang
groupmod  -n 新组名  旧组名</p>

<p>案例2:把  datang组的组 id改为999
groupmod  -g 999   datang</p>

<p>（3）删除用户组 
语法：groupdel 组名
注意：如果一个组下有用户，是不能删除这个组的。
案例：比如把前面创建的emen组给删除掉</p>

<p>4、用户管理
（1）添加用户 
语法： useradd [选项]  用户名
-g  group_name :添加用户指定所属主组
-d  home      :添加用户时指定自己的家目录</p>

<p>案例1：添加一个yangguo的用户。
useradd yangguo
注意：在创建一个用户时，如果没有指定该用户的主组，则会自动生成一个和用户名同名的组，该组就该用户的主组。
案例2:  添加一个liangshan组，
在该组里面添加一个songjiang 的用户。</p>

<p>案例3：添加一个likui 的用户，主组为 liangshan,家目录为“/xiaokui”
useradd –g  liangshan –d  /xiaokui   likui</p>

<p>（2）修改用户 
语法：usermod [选项] 用户名
-c  comment  :修改备注信息
-l  login_name :修改用户名
-d  home_dir  :修改用户家目录
-g  group_name:修改用户所属组</p>

<p>案例1：把likui改名为lidakui  并且把家目录改为/home/xiaokui
usermode –l  新的名称   -d  新的家目录   用户名</p>

<p>（3）删除用户 
语法：userdel [选项] 用户名
-r   删除用户的家目录</p>

<p>5、密码管理 
新建的用户，如果没有设置密码则是无法登陆的。
语法：passwd [选项] 用户
-S  ：查看用户密码状态
-l  ：锁定用户的密码（禁止登录）
-u  ：解除用户密码锁定
-d  ：删除用户密码
录
案例1：给songjiang设置密码
语法：passwd  songjiang</p>

<p>加密之后的密码：</p>

<p>案例2：锁定songjiang用户</p>

<p>锁定宋江用户后，密码的状态，</p>

<p>也可以直接修改/etc/shadow文件里面用户的密码，也能够完成用户的锁定，注意，在修改密码时，一般在该密码前面添加一个特殊的符号，比如使用!，当解除锁定时，直接把密码前面的特殊符号给去掉即可。</p>

<p>案例3：删除songjiang用户的密码，
删除用户密码的用户，只能在本地登陆，不能进行远程登录。</p>

<p>案例4：查看songjiang用户的密码状态</p>

<p>6、禁止账号登陆 
（1）禁止某个账号登陆 
方式一：通过  passwd –l 用户名   命令执行，
方式二：通过修改/etc/shadow 配置文件中，用户对应的密码内容，一般前面添加特殊字符。</p>

<p>（2）禁止所有普通账号登陆</p>

<p>想要禁止所有的用户登录，则需要在/etc目录下面新建一个nologin 的文件。</p>

<p>建立一个新文件的命令是  touch  /etc/nologin命令。
注意：无法禁用root用户。
7、添加删除组成员 
语法：gpasswd [选项] 组名
-a  user_name   添加组成员
-d  user_name   删除组成员
案例1：把宋江用户添加到瓦岗寨附属组。
语法： gpasswd –a  songjiang    wagangzai</p>

<p>8、赋予普通用户特殊权限
普通用户的权限受限，比如通过普通用户执行添加用户的操作，会出现如下的提示 ：</p>

<p>/etc/sudoers 
在这个文件中，记录了哪些用户可以执行哪些命令， 
visudo命令   或  vi  /etc/sudoers
这两个命令都可以用来管理/etc/sudoers文件
案例：比如给宋江用户授予添加用户的权限。
使用 visudo 命令：</p>

<p>切换到宋江登录用户
sudo –l 查看当前用户可以执行哪些指令 </p>

<p>使用“sudo 某些命令” 来执行特权命令。
添加用户：
sudo  useradd 添加的用户</p>

<p>whereis  命令，查看该命令的全路径，</p>

<p>三、文件管理
1、文件目录权限 
对文件（目录）权限本身划分 
r       读          4
w      写          2
x       执行        1
假如对一个文件的权限是7  则表示对该文件的权限是全部，（读取、写，执行）
假如对一个文件的权限是5  则表示对该文件的权限是读和执行。</p>

<p>权限从用户的角度划分 
所有者：文件的拥有者，创建该文件的用户
所属组：默认是该文件的拥有者所属初始组里面的其他用户。
其他人：</p>

<p>2、权限的说明</p>

<p>最前面的第一列：
如果是一个“-”表示是一个文件
如果是一个  ”d”表示是一个文件夹
如果是一个 “l”表示是一个链接文件，链接文件就类似于window里面的快捷方式。</p>

<p>设置的权限：rw-r--r--
第一组：rw-  是文件的所有者的权限。当前权限是读和写，没有执行的权限。
第二组：r--   是授予所属组用户的权限，比如当前权限是读，没有写和执行的权限。
第三组：r--   是授予其他人的权限，比如当前权限是读，没有写和执行的权限。
可以把rw-r--r--变成数字表示：644</p>

<p>注意：如果想要对目录中的某个文件具有删除的权限，则如何设置。对一个文件有写权限，不能删除该文件，要想删除该文件，则必须对文件所在目录具有写的权限。</p>

<p>3、更改文件权限 
（1）更改文件权限 
语法1：chmod   [选项] &lt;权限数字&gt;&lt;文件或目录&gt;  注意：比较适合于设置权限
比如对一个文件的所有者具体有读写的权限，对所属组具有执行的权限，对其他人具有读取的权限。
chmod  614   one</p>

<p>语法2：chmod [{ugo}{+-=}{rwx}][文件或目录] 注：比较适合于修改权限。
-R:递归改变 是把目录下面的所有的内容跟着改变。
two.doc原来的文件权限。</p>

<p>对two.doc文件所属组添加执行的权限。
chmod   g+x  two.doc</p>

<p>比如想把文件的所有者去掉读的权限。
chmod  u-r two.doc
组合使用用法
chmod  u-r,o+w,g+w  two.doc
chmod  u=rwx two.doc</p>

<p>（2）更改文件拥有者 
语法：chown [用户][文件或目录] 
-R:递归改变</p>

<p>（3）更改文件所属组 
语法：chgrp  [用户组][文件或目录] 
-R:递归改变</p>

<p>4、目录管理 
（1）创建目录 
    语法：mkdir [选项] 目录名
    -p  :递归创建目录
    -m  :创建目录时指定权限 
案例1：比如在根目录下面建立一个 demo目录。
mkdir   /demo</p>

<p>案例2：比如在根目录下面的demo目录里面新建一个one 目录，one/two/three/four
mkdir –p  /demo/one/two/three/four</p>

<p>案例3：在/home建立一个目录，目录名称为public,权限设置为777.</p>

<p>（2）删除目录 
    语法：rmdir [选项] 目录名
    -p  :递归删除
注意：该命令只能删除空的目录。</p>

<p>5、文件创建与删除 
（1）创建文件 
    语法：touch 文件名 </p>

<p>（2）删除文件 
    语法：rm [选项] 文件名
    -r  :递归删除（用于删除文件夹）
    -f  :关闭确认</p>

<p>使用-rf的组合，可以删除非空的目录。</p>

<p>6、复制文件或目录 
语法：cp [选项]  &lt;源文件或目录&gt;&lt;目标文件或目录&gt; 
-R  :递归复制,复制目录时常用。
-p  :复制过程中保持文件原有属性。
-v  ：显示复制过程
案例1：把/home目录下面的two.doc文件给复制到/demo目录里面。
cp  /home/two.doc  /demo/</p>

<p>案例2：把/boot目录里面的所有的内容，复制的到/demo目录里面。
命令：cp  -R  /boot   /demo
复制成功后，查看/demo目录</p>

<p>7、移动文件或目录 
语法：mv [选项]  &lt;源文件或目录&gt;&lt;目标文件或目录&gt; 
-v  :显示过程
案例1：把/home下面的one.doc 文件给移动到/demo目录里面，
mv  /home/one.doc  /demo/one.doc</p>

<p>案例2：可以使用该命令进行对文件改名操作
比如，把/demo下面的one.doc文件改名为111.doc
mv  /demo/one.doc   /demo/111.doc</p>

<p>8、搜索匹配行 
语法：grep [选项] &lt;字符串&gt;&lt;源文件&gt; 
-n  :显示行号
-c  :共匹配多少行 
-i  :忽略大小写
-v  :排除指定字符串</p>

<p>比如显示出一个文件中除了注释的内容，
grep   –v   ^#    /etc/inittab </p>

<p>9、显示文件内容 
cat  查看文件的内容：
语法：cat   文件名称
注意：比较适合于查看内容比较少的文件。</p>

<p>head   可以显示出文件的前n行
语法：head –n  文件名称</p>

<p>tail  可以显示出文件的后n行
语法：tail –n  文件名称</p>

<p>more
比较适合显示内容比较多的文档。按空格则翻屏显示，按回车是逐行显示。
less
四、系统定时任务
用户的crontab设置 
选项： 
-e  编辑crontab定时任务 
-l  查询crontab任务 
-r  删除当前用户所有的crontab任务 
shell&gt;crontab –e</p>

<h1>
<a id="进入crontab编辑界面会打开vim编辑你的工作" class="anchor" href="#%E8%BF%9B%E5%85%A5crontab%E7%BC%96%E8%BE%91%E7%95%8C%E9%9D%A2%E4%BC%9A%E6%89%93%E5%BC%80vim%E7%BC%96%E8%BE%91%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>进入crontab编辑界面，会打开vim编辑你的工作。</h1>

<p>语法： </p>

<ul>
<li>* * * * 执行的任务 </li>
</ul>

<p>说明的案例：</p>

<p>比如要定义一个每天凌晨5点执行某个命令。</p>

<ul>
<li> 5  * * *</li>
</ul>

<p>案例：</p>

<ul>
<li>/5 * * * *  /bin/echo ‘hello world’ &gt;&gt; /demo/test 
5 5 * * 2 /sbin/shutdown –r now 
0 5 1,10,15 * * /root/sh/autobak.sh 
案例说明：
第一步：执行crontab –e编辑计划任务，会自动打开vi编辑器。
文件的内容：</li>
<li>* * * *   echo “nihao” &gt;&gt; /demo/nihao.txt</li>
</ul>

<p>保存退出即可，就会每隔一分钟，向nihao.txt文件里面写入nihao的字符串。</p>

<ul>
<li>* * * *    /wamp/php/php.exe  /amp/demo/a.php</li>
</ul>

<p>shell&gt;crontab –e</p>

<h1>
<a id="进入crontab编辑界面会打开vim编辑你的工作-1" class="anchor" href="#%E8%BF%9B%E5%85%A5crontab%E7%BC%96%E8%BE%91%E7%95%8C%E9%9D%A2%E4%BC%9A%E6%89%93%E5%BC%80vim%E7%BC%96%E8%BE%91%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>进入crontab编辑界面，会打开vim编辑你的工作。</h1>

<p>LINUX系统操作（下）
目录
一、配置网络  1
（1）使用配置文件配置ip地址。  1
（2）重启网络服务，让配置生效 1
（3）测试是否启动成功 2
（4）测试是否与外部其他的计算机连接成功。   2
二、远程连接linux的服务器：  4
三、挂载光驱  6
四、安装FTP服务   7
1、软件安装方式：   7
2、 RPM软件包安装语法：    7
3、 使用rpm包开始安装FTP服务：   8
五、安装LAMP环境  11
1、安装apche软件   11
（1）解压软件 11
（2）进入解压的目录， 12
（3）执行配置 12
（4）执行编译 12
（5）执行安装 12
（6）安装完成后，要启动apache的服务，    12
2、安装mysql 软件  13
3、安装php软件 16
（1）解压，    16
（2）进入解压的文件    16
（3）配置   16
（4）编译   16
（5）安装   17
（6）复制php的配置文件，注意：进入到php解压的目录  17
（7）配置让apache支持php 17
（8）编辑一个文件，测试是否和mysql连接成功。 17
4、新建一个虚拟主机测试，   17
（1）打开apche的配置文件，支持虚拟主机的配置。  17
（2）打开 apache的辅助配置文件。    18
5、把ecshop软件给部署到linux里面  19
（1）上传ecshop软件，进行解压    19
（2）把解压后的upload 目录，拷贝到虚拟主机里面。    19
（3）在浏览器访问域名，执行安装，出现如下提示，要修改如下目录的权限。 19
6、把apache和mysql配置为开机启动。   20</p>

<p>一、配置网络
（1）使用配置文件配置ip地址。
给网卡设置ip地址，使用网卡的配置文件，
第一块网卡的配置文件：/etc/sysconfig/network-scripts/ifcfg-eth0 
第二块网卡的配置文件：/etc/sysconfig/network-scripts/ifcfg-eth1
使用vi编辑器，打开该配置文件。</p>

<p>DEVICE      :网卡的设备名称
HWADDR      :网卡的物理地址（mac）
ONBOOT      :设置为yes则系统启动时，网卡也跟着启动
IPADDR      :ip地址
NETMASK :网卡的子网掩码
BOOTPROTO   ：网卡的设置方式，static静态方式，我们自己设置ip地址，如何dhcp动态获取。
TYPE            : 网络的类型，以太网。
注意：配置linux里面的ip地址不要和window主机的 ip地址重复。
当前设置如下：</p>

<p>（2）重启网络服务，让配置生效
语法： service network start|restart|stop
如果在启动时出现如下提示；说明有一个程序NetworkManger来管理网络，让该程序禁用即可。</p>

<p>禁用：NetworkMangaer服务</p>

<p>再次重新启动网络：</p>

<p>（3）测试是否启动成功
使用ifconfig命令来测试</p>

<p>（4）测试是否与外部其他的计算机连接成功。
使用ping命令
语法：ping 对方的ip地址。
要注意：让虚拟机软件支持连接外部的网络。</p>

<p>linux连接外部网络测试：</p>

<p>window主机连接linux 系统。</p>

<p>二、远程连接linux的服务器：
使用putty远程连接软件来连接linux的服务器。
要注意：被连接的linux服务器需要安装一个服务：ssh  该服务的端口号：22，
我们默认已经安装好了。 
查看该服务的状态，是已经运行了，</p>

<p>设置连接界面的字符集：</p>

<p>设置链接界面的字体</p>

<p>设置链接界面要保持连接，防止自动断开。</p>

<p>开始连接</p>

<p>如果连接失败，需要关闭防火墙，关闭防火墙的语法 ：
service iptables stop</p>

<p>三、挂载光驱
挂载光驱就是读取光驱里面的数据。</p>

<p>光驱的硬件位置：/dev/cdrom 
在系统里边需要一个目录，让其与光驱硬件进行挂载，建立映射关系，通读取该目录，就读取里面光驱里面的内容。 
语法： 
mount  硬件设备  挂载点 
卸载： 
umount  硬件设备|挂载点 </p>

<p>（1）需要把光盘加载到光驱里面（如果是真实的机器，直接把光盘放到光驱里面即可）</p>

<p>（2）新建一个目录，该目录用于和光驱硬件建立映射关系。</p>

<p>（3）开始挂载，使用新建的目录与光驱的硬件建立映射关系。
语法： 
mount  硬件设备  挂载点(新建的目录) 
mount  /dev/cdrom  /cdrom
出现如下提示，表示挂载成功。</p>

<p>（4）挂载成功后，读取/cdrom目录，就读取里了光盘里面的内容。</p>

<p>（5）取消挂载
umount  硬件设备|挂载点 
umoutn  /dev/cdrom   或  umount   /cdrom</p>

<p>四、安装FTP服务
1、软件安装方式： 
（1）.rpm :二进制软件包 
安装简单，安装速度快 
缺点：自定义性差，依赖性强 
比如：安装a 软件，提示要先安装 b 软件，安装b软件，又提示安装 c软件，安装c软件，又提示安装d软件。
（2）.tar.gz  :源代码编译安装 
开源，自由定制 
缺点：编译时间较长，一旦报错解决困难。 
（3）智能 yum方式 
特点：解决了依赖性，要求服务器有网络，不灵活，不可以设置自己需要的具体软件版本。 
2、 RPM软件包安装语法： 
安装： 
rpm  –ivh  包全名 
-i  安装
-v  :显示详细信息
-h  :显示进度 
卸载语法：
rpm –e 软件名
--nodeps 不检测依赖性
查询软件包是否安装
rpm –qa 软件名
-a 查询所有已经安装的软件包</p>

<p>3、 使用rpm包开始安装FTP服务：
注意：rpm包在linux的安装光盘里面。
（1）挂载光驱，读取光盘里面的数据。</p>

<p>（2）开启安装，
前提：已经要进入到光盘里面的Packages文件夹
语法：rpm  –ivh  包全名 </p>

<p>（3）要启动ftp服务，</p>

<p>（4）使用ftp客户端软件，进行连接，上传文件。
注意：root用户默认不能登录ftp服务的。</p>

<p>如果出现如下提示500的错误提示。：
原因：redhat面向目标是企业，为了安全，增加了一个selinux 服务，关闭该服务即可。 
在 /etc/selinux/config 
把enforcing=&gt;disabled
运行setenforce 0命令使立即生效</p>

<p>关闭selinux 服务的步骤：
第一步：使用vi  打开配置文件/etc/selinux/config </p>

<p>第二步：让该配置立即生效，运行setenforce 0命令使立即生效</p>

<p>再次连接ftp服务，就成功了。</p>

<p>注意点：如果连接不成功，
（1）查看vsftpd服务是否开启，（2）关闭防火墙(service iptables stop)（3）用户名或密码是否输入错误。
五、安装LAMP环境
安装顺序，建议是apache-&gt;mysql-&gt;php
源码安装的步骤：
解压软件包
configure配置
make编译
make install安装
1、安装apche软件
（1）解压软件
软件解压格式： 
后缀tar.gz    tar   –zxvf  压缩包 
后缀tar.bz2   tar   –jxvf   压缩包 
tar命令解压缩语法： 
-x 解包.tar文件 
-v显示详细信息 
-f指定解压文件 
-z解压缩 </p>

<p>（2）进入解压的目录，</p>

<p>（3）执行配置
可以使用./configure –help查看配置 的帮助。</p>

<p>（4）执行编译
make</p>

<p>（5）执行安装
make install</p>

<p>（6）安装完成后，要启动apache的服务，
开启服务语法：/usr/local/apache/bin/apachectl   start|stop|restart</p>

<p>查看是否启动成功：
netstat –tunpl |grep 80</p>

<p>apache启动成功后，进行测试：</p>

<p>注意：安装完成出现如下提示的解决方案：</p>

<p>步骤1：打开apache的配置文件：</p>

<p>查看自己的linux的主机名称：</p>

<p>步骤2:打开/etc/hosts的配置文件：</p>

<p>2、安装mysql 软件
（1）新建一个mysql的组
shell&gt;groupadd mysql
（2）新建一个mysql用户，加入到mysql组里面来
shell&gt;useradd  -g  mysql  mysql
（3）解压软件</p>

<p>（4）进入解压后的文件夹</p>

<p>（5）#配置mysql编译选项，指定安装路径及支持的字符集
shell&gt;./configure --prefix=/usr/local/mysql \
    --with-charset=utf8 \
    --with-extra-charsets=gbk,gb2312,binary</p>

<p>（6）执行编译
make
（7）执行安装
make  install
（8）复制mysql的配置文件，注意：是从解压的目录里面复制到/etc/my.cnf</p>

<p>（9）初始化数据库，</p>

<p>（10）安全性配置</p>

<p>（11）启动mysql 服务
注意：&amp;表示该服务在后台执行。</p>

<p>查看是否启动：</p>

<p>（12）登录mysql服务器，
注意：在安装完成后，默认 mysql是没有root用户密码的。</p>

<p>为了安全要更改mysql里面root用户的密码。
语法：
use  mysql
update user set password=PASSWORD(‘root’) where user=’root’;</p>

<h1>
<a id="清空权限缓存使更改立即生效" class="anchor" href="#%E6%B8%85%E7%A9%BA%E6%9D%83%E9%99%90%E7%BC%93%E5%AD%98%E4%BD%BF%E6%9B%B4%E6%94%B9%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>清空权限缓存，使更改立即生效。</h1>

<p>执行：flush privileges</p>

<p>重新登录：</p>

<p>关闭服务的一个命令：
pkill  服务名称<br>
比如要关闭apache则使用pkill httpd,比如要关闭mysql则使用 pkill mysqld,
注意：在默认情况下，操作源码包安装的软件，不要使用service来操作。</p>

<p>3、安装php软件
（1）解压，</p>

<p>（2）进入解压的文件</p>

<p>（3）配置</p>

<p>（4）编译
make 
（5）安装
make install
（6）复制php的配置文件，注意：进入到php解压的目录
cp  php-5.2.5/php.ini-dist /usr/local/php/lib/php.ini</p>

<p>（7）配置让apache支持php</p>

<p>步骤：打开apache的配置文件，添加如下代码：</p>

<p>（8）编辑一个文件，测试是否和mysql连接成功。</p>

<p>4、新建一个虚拟主机测试，
（1）打开apche的配置文件，支持虚拟主机的配置。</p>

<p>（2）打开 apache的辅助配置文件。</p>

<p>配置完成虚拟 主机后，出现如下提示：如何解决？</p>

<p>解决步骤
（1）开启访问权限，
打开apache的配置文件，</p>

<p>（2）打开 apache的配置文件，修改默认首页面，</p>

<p>再次测试就正常了：</p>

<p>5、把ecshop软件给部署到linux里面
（1）上传ecshop软件，进行解压
对.zip文件，解压使用unzip命令：
语法： unzip  压缩文件名称</p>

<p>（2）把解压后的upload 目录，拷贝到虚拟主机里面。</p>

<p>（3）在浏览器访问域名，执行安装，出现如下提示，要修改如下目录的权限。</p>

<p>修改权限如下：</p>

<p>6、把apache和mysql配置为开机启动。
打开 /etc/rc.local,linux系统每次启动后都会自动执行这个文件，在该文件中，加入以下两行内容：
/usr/local/apache/bin/apachectl start
/usr/local/mysql/bin/mysql_safe --user=mysql &amp;</p>

<p>如何卸载源码包安装的软件 ：停止服务，删除掉整个安装目录即可。
比如卸载apace则删除/usr/local/apache目录，比如卸载mysql则删除/usr/local/mysql目录。</p>

<p>网页静态化与mysql优化（一）
目录
网页静态化与mysql优化（一）  1
一、衡量大型网站的标准   1
二、大型网站带来的问题   2
三、高并发的解决方案：   2
四、大流量（带宽）的解决方案  2
1、配置压缩，减少数据传输的数据量。    2
2、减少http的请求，  5
3、把比较占用流量的资源单独部署服务器。  6
4、花钱买带宽。  7
五、大存储解决方案 7
1、使用缓存技术  7
2、对mysql进行优化    8
六、页面静态化技术：  8
1、概述：   8
2、几个重要的概念   8
3、实现方式    9
4、ob缓存的介绍   9
5、ob缓存对应的函数。  10
6、生成静态页面的案例：  13
7、生成静态页面的案例扩展：    14
8、静态化在smarty里面使用，   15
9、真静态的优缺点说明：  15
七、伪静态的讲解    15
1、什么是伪静态  15
2、实现方式，入门案例 16</p>

<p>一、衡量大型网站的标准
pv 值(page views):页面的浏览量
概念：一个网站的所有页面，在一天内，被浏览的总次数，达到千万级别，几百万也可以。
uv值(unique visitor)独立访客
概念：一个网站，在一天内，有多少个用户访问过我们的网站，几十万以上，
独立ip：
概念：一个网站，在一天内，有多少个独立的ip地址来访问我们的网站。
uv值略大于独立ip的。</p>

<p>如果要考虑公司的局域网，则uv值略大于独立ip的</p>

<p>二、大型网站带来的问题
大并发： 
概念：在同一时间点，有多少用户同时访问网站。 
大流量： 
大并发，必然要导致大流量，需要高的带宽。 
大存储： 
数据库存储，表达到G,T级别。 </p>

<p>三、高并发的解决方案：
网站重新架构，分层技术，负载均衡，集群，读写分离
负载均衡器： 
硬件： 
F5-BIGIP:立竿见影，效果非常好，价格昂贵。一些大型的网站公司和网游公司在用。 
软件： 
lvs(linux virtual server)集成到linux的内核里面了， 
nginx  (该软件可以做web服务器，也可以做负载均衡使用)
负载均衡器的策略： 
（1）轮询技术：就是负载均衡把请求轮流转发给 web服务器。 
（2）最少连接：负载均衡把请求转发给最空闲的web服务器。 
（3）ip哈希：同一地址的客户端始终请求同一台 web服务器。 </p>

<p>四、大流量（带宽）的解决方案</p>

<p>1、配置压缩，减少数据传输的数据量。
原理图：</p>

<p>缺点：在服务器端，要进行对数据压缩，要耗费时间，在浏览器端解压缩，要耗费时间。</p>

<p>原理：为了提高网页在网络上的传输速度，服务器对主体信息进行压缩。如常见的gzip压缩，deflate压缩，compress压缩以及google、chrome正在推的sdcn压缩。
查看浏览器支持的压缩格式：通过firbug等系列软件，查看请求的头信息。</p>

<p>Apache上利用gzip压缩算法进行压缩的模块有两种：mod_gzip和mod_deflate. 
Apache 1.x系列没有内建网页压缩技术，使用额外的第三方mod_gzip模块。
Apache2.0以上的版本中gzip压缩使用mod_deflate模块。
配置压缩的步骤：
（1）apache服务器，要开启deflate模块，或gzip模块
打开apache的配置文件，</p>

<p>（2）在虚拟主机里面添加如下的配置
 
DeflateCompressionLevel  6       #压缩级别为6，可选1-9，推荐为6 
AddOutputFilterByType DEFLATE  text/plain #压缩文本文件 
AddOutputFilterByType DEFLATE  text/html #压缩html文件 
AddOutputFilterByType DEFLATE  text/xml #压缩xml文件
 
DeflateCompressionLevel 指令来设置压缩级别。该指令的值可为1（压缩速度最快，最低的压缩质量）到9（最慢的压缩速度，压缩率最高）之间的整数，其默认值为6（压缩速度和压缩质量较为平衡的值）</p>

<p>注意：为什么要指定文件类型来压缩？
压缩也是要耗费cpu资源的，图片/视频等文件，压缩效果也不好，不要压缩。一般压缩文本格式的文件。
没有压缩之前：</p>

<p>添加压缩代码之后；</p>

<p>查看文件的类型，通过响应头里面的”content-type”属性来查看。</p>

<p>虚拟主机里面的配置：</p>

<p>2、减少http的请求，
主要是合并文件，合并js，css,背景图片等文件。把浏览器一次请求需要的js,css，背景图片文件，合并成一个文件，这样，浏览器请求一次即可。</p>

<p>效果：</p>

<p>3、把比较占用流量的资源单独部署服务器。
一般占用流量的资源就是视频和图片，</p>

<p>4、花钱买带宽。
五、大存储解决方案
1、使用缓存技术
目的：做到，少查或不查数据库，
（1）页面静态化技术（磁盘缓存）
把一个动态页面（操作数据库的）转换成一个静态的html页面。
原理：</p>

<p>apache处理静态页面的速度要远远快于处理php页面的速度。</p>

<p>（2）内存缓存
内存缓存技术有：memcache和redis以及mysql里面的memory引擎。
原理：</p>

<p>注意：计算机从内存里面读取数据的速度，要远远快于从磁盘里面读取。
2、对mysql进行优化
六、页面静态化技术：
1、概述：
就是把一个动态的页面变成一个静态页面，后续用户直接访问静态页面。</p>

<p>页面静态化技术分为两种：真静态和伪静态。
真静态：把一个动态的页面，转成一个静态的页面,即.html文件
伪静态：所谓伪静态是从url地址上看是一个静态页面，但是实际上还是对应一个动态页面，
比如：<a href="http://www.abc.com/news-sport-id12.html">http://www.abc.com/news-sport-id12.html</a>
实际上是操作。<a href="http://www.abc.com/news.php?type=sport&amp;id=12">http://www.abc.com/news.php?type=sport&amp;id=12</a>,
2、几个重要的概念
（1）动态网址：
所谓动态网址，一般来说去查询数据库，比如:<a href="http://www.abc.com/goods.php?id=120">http://www.abc.com/goods.php?id=120</a>
特点：查询数据库，速度慢；接收参数，安全性要注意（sql注入）；不利于seo搜索引擎优化。
（2）静态网址
比如：<a href="http://www.abc.com/index.htm%E8%BF%99%E4%B8%AA%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%BD%91%E5%9D%80%EF%BC%9A">http://www.abc.com/index.htm这个就是一个静态网址：</a>
特点：不查询数据库，速度快；不接收参数，安全性高；利于seo
（3）伪静态网址：
从形式上看是一个静态页面，但是实际上对应一个动态页面，
比如：<a href="http://www.abc.com/news-sport-id12.html">http://www.abc.com/news-sport-id12.html</a>
实际上是操作。<a href="http://www.abc.com/news.php?type=sport&amp;id=12">http://www.abc.com/news.php?type=sport&amp;id=12</a>,
特点：本身需要查询数据库，执行速度慢；不接收参数，因此安全；利于seo
3、实现方式
真静态：使用ob缓存技术来实现
伪静态：使用web服务器的rewrite机制（url的重写机制）来实现。</p>

<p>4、ob缓存的介绍
（1）程序缓存。
程序缓存，缓存的数据是，返回给浏览器的数据（包含头信息和主体信息）
程序缓存不能关闭，默认就有的。
（2）ob缓存
ob就是 output_buffering:输出缓存，缓存的数据是返回的响应的主体数据，可以自由的关闭打开。
在请求一个php的过程中，我们实际上经过三个缓存，ob缓存，程序缓存，浏览器缓存。 </p>

<p>注意点：如果开辟了ob缓存，主体数据首先存储到ob缓存里面，头信息要存储到程序缓存（无论是否开启ob缓存），当代码执行完毕后，ob缓存里面的数据刷新（移动）到程序缓存，程序缓存再输出到浏览器缓存中，最后输出内容。
（3）如何开启ob缓存。
有两种方式：
方式一：直接在页面中执行ob_start() 函数。
方式二：在php.ini文件中开启。
output_buffering = 容量|on|off</p>

<p>5、ob缓存对应的函数。
ob_start()开启 ob缓存，只针对当前页面有效。
ob_clean();清空ob缓存里面的数据</p>

<p>ob_get_contents();获取ob缓存里面的数据内容。</p>

<p>ob_end_clean();清空ob缓存，并关闭ob缓存。</p>

<p>ob_flush();把ob缓存里面的数据，给刷新（移动）到程序缓存，并不关闭ob缓存。</p>

<p>ob_end_flush();把ob缓存里面的数据，刷新（移动）到程序缓存，并关闭ob缓存，。</p>

<p>总结：
常用的是：ob_start()   ob_get_contents()   ob_clean()
$content = ob_get_contents();
file_put_contents(‘index.html’,$content);</p>

<p>案例1：
&lt;?php 
ob_start(); 
echo "abc";
header("content-type:text/html;charset=utf-8");
echo "hello";<br>
ob_clean();
echo "aa";
header("content-type:text/html;charset=utf-8");
?&gt;
6、生成静态页面的案例：
newslist.php新闻的列表页面</p>

<p>newsinfo.php新闻的详情页面。</p>

<p>7、生成静态页面的案例扩展：
给一个生存周期，比如说300秒，过了300秒后，要重新生成静态页面。</p>

<p>如果没有做静态化，并发量是1000，在300秒内，查询数据库多少次。300*1000
如果做了静态化，并发量是1000，而且缓存周期为300秒，在300秒内，查询数据库多少次？仅仅1次。</p>

<p>如何给一个页面设置生命周期。
比如生命周期为300秒，满足什么条件在有效期内。
创建文件的时间戳+生命周期&gt;当前的时间戳</p>

<p>8、静态化在smarty里面使用，
$smarty-&gt;cache_dir = “./cache/";  //缓存目录 
$smarty-&gt;caching = true;  //开启缓存,为flase的时侯缓存无效 
$smarty-&gt;cache_lifetime = 60;  //缓存时间(单位 秒) 
if(!$smarty-&gt;isCached(’01.html’)){ 
    //判断模板文件是否被缓存。 
} 
9、真静态的优缺点说明：
优点： 1. 速度快 2. 安全性高 3. 利于seo 
缺点：就是占有磁盘空间., 如果过大，对磁盘响应速度有影响
在什么情况下，建议不要使用真静态
1.  页面的数据更新频繁，最好不要使用真静态(比如股票，基金，等实时报价系统)
2.  会生成海量页面(比如大型论坛 bbs ,csdn)
3.  查询该页面一次后，以后再也不查询该页面.
4.  不愿意被搜索引擎抓取的页面.
5.  访问量小的页面.</p>

<p>七、伪静态的讲解
1、什么是伪静态
伪静态：把一个动态的地址伪装成一个静态的地址。
实现方式：利用web服务器的rewrite机制。
rewrite机制：将一个请求URL重写到另一个请求上！
比如：
index.html   重写成 index.php 
abc.php  重写成  123.php 
news_sport_id12.html   重写成  news.php?type=sport&amp;id=12 
原理图：</p>

<p>2、实现方式，入门案例
（1）开启重写模块
打开apache的配置文件，</p>

<p>（2）语法说明，
RewriteEngine  on  重写引擎开关，一旦开启，所有的重写条件都生效。
RewriteCond  重写条件，当达到什么条件时，完成重写。
RewriteRule :定义重写规则，哪个地址应该被重写到哪个目标地址。
具体的配置，可以在虚拟主机里面完成配置，也可以在.htaccess文件里面配置。</p>

<p>（3）入门案例；
比如请求index.html 页面，变成请求index.php页面。</p>

<p>网站静态化与mysql优化（二）
目录
一、伪静态 1
1、正则表达式的回顾    1
2、伪静态实现方式语法，详解。 5
（1）RewriteCond  重写条件    5
（2）RewriteRule :定义重写规则  6
3、入门案例： 6
4、伪静态在 ecshop里面的使用。   8
5、防盗链效果 9
6、[QSA]   10
二、 mysql优化  12
1、优化概述    12
2、分析需要优化的语句 12
（1）慢查询日志  13
（2）mysql里面的profiles机制，  14
3、mysql里面的索引， 16
（1）索引的分类：   16
（2）索引的创建  16
（3）索引的删除，   17
（4）索引的查看  18
4、创建索引的注意事项 18
5、索引的数据结构   19
（1）myisam引擎的索引    19
（2）innodb的索引的数据结构   19
6、explain(执行计划)工具使用   20
（1）语法分析：  21
（2）分析type列的值。   23</p>

<p>一、伪静态
1、正则表达式的回顾
（1）要求取出练习的4个数字</p>

<p>（2）要求取出，形式为：xxx-yyy-xxx的数据</p>

<p>正则中几个概念：
子表达式：简单理解成用小括号括起的部分就是一个子表达式，
捕获：把子表达式的内容，保存在内存。
反向引用：圆括号的内容被捕获后，可以在这个括号后被使用。
（3）要求取出，形式为：xxx-yzy-xxx的数据</p>

<p>（4）贪婪模式与非贪婪模式
如果有U即换成非贪婪匹配。
贪婪：尽可能的多匹配。
非贪婪：尽可能的少匹配。</p>

<p>（5）匹配中文</p>

<p>案例：结巴程序：
$str=”我我要要….学学php编编….程”;
直接变成：我要学习php编程
提示：使用该函数来完成，preg_replace()
2、伪静态实现方式语法，详解。</p>

<p>主要是三个配置：
RewriteEngine  on
RewriteCond
RewriteRule</p>

<p>RewriteEngine  on  重写引擎开关，一旦开启，所有的重写条件都生效。
（1）RewriteCond  重写条件
RewriteCond  重写条件，当达到什么条件时，完成重写。
语法为：
RewriteCond  判断依据  条件表达式  [条件标志] 
判断依据可以使用服务器变量。服务器可以得到一些特定信息 </p>

<p>条件表达式，可以为如下形式：
正则或特殊标识
-f   表示是一个文件。
-d   表示是一个目录
正则，正则表达式字符串。
条件标志： 
[OR]    条件间的或者关系，当出现多个条件时，默认为并且的关系，条件应该是或者的关系下，可以使用OR来表示! 
[NC]条件不区分大小写。条件匹配时不区分大小写
[OR,NC] 
（2）RewriteRule :定义重写规则
RewriteRule :定义重写规则，哪个地址应该被重写到哪个目标地址。
语法：
RewriteRule 匹配地址   目标地址 [标识] 
匹配的地址：所请求的地址，可使用正则匹配
目标地址： 所重写到的地址，可以使用反向引用！$N表示正则匹配到的第N个子模式！
比如：RewriteRule   goods-id(\d+).html  goods.php?id=$1 
标志：
[NC]        不区分大小写
[QSA]   查询字符串追加，在目标地址已经具有get参数时，会将真实请求的get参数追后边。
3、入门案例：
如果访问的文件存在，则访问该文件，若不存在，则执行重写：</p>

<p>比如请求： <a href="http://www.demo.com/index.html">www.demo.com/index.html</a>    如果index.html 文件存在，则请求该文件，如果不存在执行重写规则。
实现步骤：
使用分布式文件来完成配置，在网站的根目录下面新建一个.htacccess的文件。
（1）在www.demo.com网站根目录下面新建一个.htaccess的文件。
通过编辑器另存为的方式来建立该文件。</p>

<p>（2）修改虚拟主机里面的配置。</p>

<p>（3）在.htaccess文件里面的，具体的配置</p>

<p>4、伪静态在 ecshop里面的使用。</p>

<p>伪静态网址：<a href="http://www.myecshop.com/goods-36.html">http://www.myecshop.com/goods-36.html</a>
重写到该地址：<a href="http://www.myecshop.com/goods.php?id=36">http://www.myecshop.com/goods.php?id=36</a>
<a href="http://www.myecshop.com/goods.php?id=39">http://www.myecshop.com/goods.php?id=39</a>    该地址的伪静态网址是：
<a href="http://www.myecshop.com/goods-39.html">http://www.myecshop.com/goods-39.html</a></p>

<p>重写规则应该如何写？
goods-(\d+).html       goods.php?id=$1</p>

<p>让ecshop支持重写，把到商品详情页面的链接地址变成伪静态的。</p>

<p>具体的配置：</p>

<p>5、防盗链效果
（1）什么是盗链，
原理图说明：</p>

<p>（2）如何判断请求的来源，使用 referer头信息。</p>

<p>（3）具体的配置，只允许本网站的页面来访问该图片，</p>

<p>也可以把请求的图片重写到一个警示图片，</p>

<p>效果如下：</p>

<p>伪静态常用：把html地址，重写成php地址。
6、[QSA]
[QSA]   查询字符串追加，在目标地址已经具有get参数时，会将真实请求的get参数追后边。
123.php代码：</p>

<p>在重写规则里面没有带[QSA]</p>

<p>效果如下：</p>

<p>在重写规则里面添加[QSA]</p>

<p>效果如下：</p>

<p>二、 mysql优化
1、优化概述
设计角度：存储引擎的选择，字段类型选择，范式
利用mysql自身的特性：索引，查询缓存，分区分表，存储过程，sql语句优化配置，
部署大负载架构体系：主从复制(读写分离)。
硬件升级：
2、分析需要优化的语句 
要分析的sql语句是执行速度比较慢的。查找执行速度比较慢的sql语句。找到后，具体分析。
（1）慢查询日志
是一种mysql提供的日志，记录所有执行时间超过某个时间界限的sql的语句。这个时间界限，我们可以指定。在mysql中默认没有开启慢查询，即使开启了，只会记录执行的sql语句超过10秒的语句。
如何开启慢查询日志：
打开mysql的配置文件，window下是：my.ini    linux系统下是my.cnf</p>

<p>注意： 修改完成后，要重启mysql。
测试慢查询日志是否记录超过0.5秒的sql 语句。
benchmark(count,expr)函数可以测试执行count次expr操作需要的时间。</p>

<p>查看慢查询日志里面记录的sql语句的情况。</p>

<p>在mysql的客户端进行查看慢查询日志的时间界限</p>

<p>也可以更改该时间界限，只对当前会话有效。</p>

<p>（2）mysql里面的profiles机制，
该机制能够精确的记录执行sql语句的时间，能精确到小数点后8位
开启方式：直接在 mysql的客户端进行开启
set profiling=1|0(开启和关闭)</p>

<p>查看记录的时间：
show profiles</p>

<p>注意：不适应时，最好将其关闭</p>

<p>php当mysql的客户端，php代码如何实现，
//开启
$sql=”set profiling=1”；
mysql_query($sql);
//查询
$sql=”show profiles”;
mysql_query($sql);</p>

<p>一个sql语句执行比较慢，大多数的原因是没有用到索引，</p>

<p>3、mysql里面的索引，
索引的作用：是用于快速定位实际数据位置的一种机制。
索引在mysql中，是独立于数据的一种特殊的数据结构。
（1）索引的分类： 
普通索引： 
利用特定的关键字，标识数据记录的位置（磁盘上的位置，盘号，柱面，扇面，磁道）。 
唯一索引： 
限制索引的关键字不能重复的索引。 
主键索引： 
限制索引的关键字不能重复，并且不能为NULL。（不能为NULL的唯一索引）。一个表中只允许有一个主索引。 
全文索引：
索引的关键字，不是某个字段的值，而是字段值中有意义的词来作为关键字建立索引。
复合索引，如果一个索引（以上四种任何都可以），是依赖于多个字段创建的话，称之为复合索引。
一个myisam表的对应的三个文件,表结构文件.frm   数据文件.myd  索引文件.myi</p>

<p>添加一个普通索引后，索引文件会变大，</p>

<p>（2）索引的创建
第一种方式，在创建表时，一块创建索引。</p>

<p>第二种方式：建完表后，以alter方式建立索引。</p>

<p>（3）索引的删除，
删除主键索引：alter table   tablename   drop primary key<br>
在删除主键索引时，要注意是否有auto_increment属性，如果有，则先要删除该属性，才能删除主键索引。
删除其他索引：alter table  tablename   drop index 索引的名字 
注意：如果没有指定索引的名字则是使用该字段名称作为索引的名字的。</p>

<p>（4）索引的查看
show indexes from table_name; 
show index from table_name 
show create table table_name 
show keys from table_name 
desc table_name 
4、创建索引的注意事项 
（1）较频繁的作为查询条件字段应该创建索引
    select * from emp where empno = 1 
（2）唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
    select * from emp where sex = '男‘ 
比如： is_best  is_new   is_hot    is_sale   is_delete 
（3）更新非常频繁的字段不适合创建索引
    select * from emp where logincount = 1 
     比如登录的状态，
（4）不会出现在WHERE子句中字段不该创建索 </p>

<p>5、索引的数据结构
（1）myisam引擎的索引
索引的节点中存储的是数据的物理地址（磁道和扇区）
在查找数据时，查找到索引后，根据索引节点中的物理地址，查找到具体的数据内容 </p>

<p>（2）innodb的索引的数据结构
innodb的主键索引文件上 直接存放该行数据,称为聚簇索引，非主索引指向对主键的引用
myisam中, 主索引和非主索引,都指向物理行(磁盘位置).</p>

<p>注意: innodb来说, 
1: 主键索引 既存储索引值,又在叶子中存储行的数据
2: 如果没有主键, 则会Unique key做主键 
3: 如果没有unique,则系统生成一个内部的rowid做主键. 
4: 像innodb中,主键的索引结构中,既存储了主键值,又存储了行数据,这种结构称为”聚簇索引” 
先创建一个 myisam引擎的表，并插入数据
create table t5(
    id int primary key auto_increment,
    name varchar(12) not null  comment '名称'
)engine myisam charset utf8;</p>

<p>说明：mysiam引擎的表的数据是按照插入的顺序显示的。
再创建一个inodb引擎的表，并插入数据
create table t6(
    id int primary key auto_increment,
    name varchar(12) not null  comment '名称'
)engine innodb charset utf8;</p>

<p>说明：innodb引擎的表的数据是按照主键的顺序插入的。</p>

<p>6、explain(执行计划)工具使用 </p>

<p>主要用于分析sql语句的执行情况（并不执行sql语句）得到sql语句是否使用了索引，使用了哪些索引。 
语法：explain  sql语句\G   或 desc sql语句\G 
在mysql之前的版本中，explain只支持select语句，但是在最新的5.6版本中，它支持 explain update/delete了。 </p>

<p>做实验创建几张表：
create table user( 
    id int primary key auto_increment, 
    name varchar(32) not null default '', 
    age tinyint unsigned not null default 0, 
    email varchar(32) not null default '', 
    classid int not null default 1 
)engine myisam charset utf8; 
insert into user values(null,'xiaogang',12,'<a href="mailto:gang@sohu.com">gang@sohu.com</a>',4), 
(null,'xiaohong',13,'<a href="mailto:hong@sohu.com">hong@sohu.com</a>',2), 
(null,'xiaolong',31,'<a href="mailto:long@sohu.com">long@sohu.com</a>',2), 
(null,'xiaofeng',22,'<a href="mailto:feng@sohu.com">feng@sohu.com</a>',3), 
(null,'xiaogui',42,'<a href="mailto:gui@sohu.com">gui@sohu.com</a>',3); 
创建一个班级表：
create table class( 
    id int not null default 0, 
    classname varchar(32) not null default '' 
)engine myisam charset utf8; 
insert into class values(1,'java'),(2,'.net'),(3,'php'),(4,'c++'),(5,'ios'); 
（1）语法分析：
explain  sql语句：</p>

<p>select_type:SIMPLE
表示查询的类型，此处是一个简单的查询
table :user;
表示要查询的表。
type列：是指查询的方式，非常重要，是分析“查数据过程”的重要依据。 
可能的值：all   index   range   ref    const 
possible_key:可能用到的索引
注意：系统估计可能用的几个索引，但最终，只能用1个。 
key:最终用的索引。 
key_len:使用的索引的最大长度。 
rows:是指估计要扫描多少行。 
extra: 
using index :是指用到了索引覆盖，效率非常高 
using where:是指光靠索引定位不了，还得where判断一下。 
using temporary:是指用上了临时表，group by 与order by不同列时，或grop by,order by 别的表的列。 
using filesort:文件排序（文件可能在磁盘，也可能在内存）</p>

<p>（2）分析type列的值。
 all：是扫描所有的数据行，性能最差，一般是没有添加索引，或没有使用到索引，</p>

<p>index:比all性能稍好一点，是指要扫描所有的索引节点。</p>

<p>出现index, 则说明只在索引文件中查找。 
（1）索引覆盖的查询情况下，能利用上索引，但是又必须全索引扫描。 
（2）是利用索引来排序，但只能取出索引的列。 
range:意思是查询时，能根据索引做范围扫描。 </p>

<p>ref:是指，通过索引列，可以直接引用到某些数据行。</p>

<p>const,system,null这3个分别指查询优化到常量级别，甚至不需要查找时间。
一般按照主键来查询时，易出现 const,system 
或者直接查询某个表达式，不经过表时，出现null. </p>

<p>网站静态化与mysql优化（三）
目录
一、索引的使用细节 1
1、全值匹配    1
2、范围匹配（&lt;= &gt;= between and） 1
3、独立的列    2
4、左值匹配    3
5、or运算都有索引    4
6、多列索引： 5
7、当取出的数据量超过表中数据的20%，优化器就不会使用索引，而是全表扫描。  9
二、索引覆盖  9
三、分表技术  10
1、垂直分割。 10
2、水平分割。 11
四、翻页优化和延迟缓存   12
五、锁机制讲解   16
1、mysql里面的锁介绍 17
2、mysql表锁的演示： 17
3、mysql行锁的演示。 19
4、锁机制在php代码里面演示；    20
六、数据碎片与维护 21
七、表分区 22
1、基本概念    22
2、创建表分区的语法： 23
3、分区的类型 24
4、分区表的限制；   25
八、列类型的选择    26</p>

<p>一、索引的使用细节
1、全值匹配 
条件字段使用“=”</p>

<p>2、范围匹配（&lt;= &gt;= between and） </p>

<p>3、独立的列 
是指索引列不能是表达式的一部分，也不能是函数的参数 </p>

<p>注意：要求索引的列必须是独立的一列才能用到索引。</p>

<p>4、左值匹配 
在使用like(模糊匹配)的时候，在左边没有通配符的情况下，才可以使用索引。
在mysql里，以%开头的like查询，用不到索引。</p>

<p>比如：根据歌词搜索歌曲的名称，根据剧情搜索电影的名称。sphinx来完成。
5、or运算都有索引 
如果出现OR(或者)运算，要求所有参与运算的字段都存在索引，才会使用到索引。</p>

<p>6、多列索引： 
对于创建的多列(复合)索引，只要查询条件使用了最左边的列，索引一般就会被使用。 </p>

<p>因为联合索引是需要按顺序执行的，比如c1234组合索引，要想在c2上使用索引，必须先在c1上使用索引，要想在c3上使用索引，必须先在c2上使用索引，依此。 </p>

<p>假设某个表有一个联合索引（c1,c2,c3,c4）
A where c1=x and c2=x and c4&gt;x and c3=x 
B where c1=x and c2=x and c4=x order by c3 
C where c1=x and c4= x group by c3,c2 
D where c1=x and c5=x order by c2,c3 
E where c1=x and c2=x and c5=? order by c2,c3 
有谁知道下面A-E能否可以使用索引
该表插入的数据：
create table t4 ( 
c1 tinyint(1) not null default 0, 
c2 tinyint(1) not null default 0, 
c3 tinyint(1) not null default 0, 
c4 tinyint(1) not null default 0, 
c5 tinyint(1) not null default 0,
index c1234(c1,c2,c3,c4) 
); 
insert into t4 values (1,3,5,6,7),(2,3,9,8,3),(4,3,2,7,5); </p>

<p>分析：对name 和age 和email分别建立独立索引：最终只能使用到一个索引。</p>

<p>如果对name和age和email 建立了联合索引，在按照建立索引的顺序使用时，都用到了索引。</p>

<p>结论：如果有多个条件经常出现在where条件中，则可以对条件字段建立联合索引。</p>

<p>应用：比如goods表里面，cat_id和价格，就可以建立一个联合索引。
7、当取出的数据量超过表中数据的20%，优化器就不会使用索引，而是全表扫描。 </p>

<p>二、索引覆盖
索引覆盖是指：如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘再找数据，这种查询速度非常快，称为“索引覆盖” </p>

<p>索引覆盖就是，我要在书里 查找一个内容，由于目录写的很详细，我在目录中就获取到了，不需要再翻到该页查看。</p>

<p>如果在一个 sql 语句中，经常查询某些列，就可以把某些列建立一个联合索引，查询时就会用到索引覆盖，速度更快。</p>

<p>三、分表技术
1、垂直分割。
典型案例：把不经常查询的字段单独分割出来，形成一张新表。</p>

<p>扩展案例：
比如一个网站，需要存储如下信息，
电影信息
图片信息
音乐信息
软件信息
水果信息
方案1：可以建立一张大表，表中有各种类型的字段，
比如以上信息：
id  title   导演   主演   作词  作曲   语言  出版  下载地址    产地  甜度<br>
方案2:可以针对不同的类型建立不同的表。
比如电影表
movie 表
id  title   addtime   viewcount    导演   主演    地区    剧情   上映时间 
music表
id  title   addtime   viewcount    作词   作曲    语言   原唱
soft表
id   title  addtime   viewcount    语言   作者    下载地址……
方案3：使用内容主表+附加表。
内容主表：用于存储各种类型的公有的字段信息，
附加表：用于存储各种类型独有的一些字段信息。
当查询公有的信息时就无需连表查询，只有当查询具体数据的时候，需要连表。
后面讲的dedecms的表的设计就是如此。</p>

<p>内容主表的记录数  ====   各个附加表记录数的之和。</p>

<p>2、水平分割。
比如用户注册，存储用户的表，可以分表，
原来：user表，
分表后，形成三张表，表名为：
user_0     user_1    user_2;
在用户注册时，用户如何存储呢、用户到底存储到哪张表呢？
需要单独一张表比如 user表，该表就一个字段，用于生成用户的id,
根据id与分表的数量进行取模运算，比如此处是3个表，
取模的值如果为0则存储到user_0表里面，
如果取模的值为1则存储到user_1表里面
如果取模的值为2则存储到user_2表里面</p>

<p>四、翻页优化和延迟缓存 
limit offset,N  当offset非常大时，效率极低。 
原因是： mysql并不是跳过offset行，然后单取N行。而是取offset+N行， 
返回时，放弃前offset行，返回N行。效率较低，当offset越大是，效率越低
优化方式：
（1）非技术手段限制分页，比如百度翻页一般不会超过70页，谷歌不会超过40页。
//计算总的记录数
$total = 
//定义每页显示数量
$perpage  = 10;
//计算总的页数
$pagecount  = min(ceil($total/$perpage),70);
（2）不用offset，用条件查询：
$sql=”select * from user limit 10,10”;
$sql=”select * from user where id&gt;10 limit 10”</p>

<p>缺点：如果数据有被删除，则取出的数据结果会不一致。</p>

<p>解决方案：
解决：数据不进行物理删除（可逻辑删除）
最终在页面上显示数据时，逻辑删除的条目不显示即可。
（一般来说，大网站的数据都是不物理删除的，只做逻辑删除，比如is_delete=1）
（3）非要物理删除，还要用offset精确查询，还不限制用户分页，怎么办
我们现在必须要查，则只查索引，不查数据，得到id 
再用id去查具体条目，这种技巧就是延迟索引。 
第一步：
//select * from user limit 10000,10 （没有用到索引）
//取出数据的id<br>
select  id from user limit  10000,10(用到索引覆盖)
第二步：根据取出 id再查具体的数据，因为使用id查询比较快，因为id是主键。
因此使用一个连接查询，就可以，我们使用内连接。inner  join   left join  right join</p>

<p>五、锁机制讲解
比如有如下操作：
（1）从数据库中取出id的值，（2）把这个值加1，（3）在把该值存回到数据库。
假如该id初始值为100；
如果有两个用户同时操作。
第一个用户 ：
id=100
100+1
id=101
第二个用户：
id=100
100+1
id=101
经过两个用户操作数据库，值应该为102才对，
假如是一个购物网站，库存还剩1件，有两个用户同时购买1件商品，
mysql中的锁：同一个时间只有一个人可以获得锁，其他人只能阻塞等待第一个人释放锁。
第一个用户                             第二个用户
get lock（获得锁）                        waiting。。。。
id=100                                   waiting。。。。
100+1                                   waiting。。。。
id=101                                   waiting。。。。
unlock(释放锁)                           get lock(获取锁)
                                                                                                                    id=101
                                        id+1
                                        id=102
                                       unlock(释放锁)</p>

<p>1、mysql里面的锁介绍
mysql 的锁有以下几种形式：
表级锁：开销小，加锁快，发生锁冲突的概率最高，并发度最低。myisam引擎属于这种类型。
行级锁：开销大，加锁慢，发生锁冲突的概率最低，并发度也最高。innodb属于这种类型。 </p>

<p>2、mysql表锁的演示：
（1）添加读锁，
对myisam表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的操作。 </p>

<p>添加读锁语法：lock  table 表名 read     释放锁的语法；unlock tables</p>

<p>添加完读锁后，自己不能修改该表</p>

<p>注意：当前进程只能操作被锁定的表，如果想要锁定多张表，可以使用如下语句；
 lock table tablename1  read, tablename2 read;</p>

<p>（2）添加写锁
对myisam表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</p>

<p>当前进程就可以执行读写操作。</p>

<p>总结：
read:所有人都只可以读，只有释放锁之后才可以写。 
write:只有锁表的客户可以操作这个表，其他客户读都不能读。</p>

<p>缺点：阻塞。有些功能需要锁多张表，而有些表整个网站都要用，一旦锁定，会让整个网站处在阻塞状态
3、mysql行锁的演示。
innodb存储引擎是通过给索引上的索引项加锁来实现的，这就意味着：只有通过索引条件检索数据，innodb才会使用行级锁，否则，innodb使用表锁。 
语法： 
begin;
执行语句； 
commit; </p>

<p>4、锁机制在php代码里面演示；
建立一个表，原始数据是100，</p>

<p>模拟并发进行测试；
比如模拟50个并发，使用apache里面有一个ab.exe工具，可以使用该工具进行模拟并发</p>

<p>ab.exe工具的语法：
ab.exe –n 总的请求数量 –c并发数   网页的地址；
php代码：</p>

<p>六、数据碎片与维护 
在长期的数据更改过程中，索引文件和数据文件，都将产生空洞，形成碎片，我们可以通过一个nop操作（不产生对数据实质影响的操作）来修改表，</p>

<p>执行如下操作： delete from t9 where id=1;  操作完成后，数据应该减少三分之一才对。
执行完成该语句后，发现数据文件并没有减少三分之一，这样在数据文件中，就会产生了一个垃圾的空洞的数据文件，因此需要整理。</p>

<p>整理方法：
第一种方法：执行：alter table table_name engine 原来的存储引擎。</p>

<p>第二种方法：执行该语句：optimize  table  table_name</p>

<p>执行后，</p>

<p>注意：修复表的数据及索引碎片，就会把所有的数据文件重新整理一遍，使之对齐，这个过程，如果表的行数比较大，也是比较耗费资源的操作，所以，不能频繁的修复。
如果表的update操作很频繁，可以按周月来修复。 
七、表分区
1、基本概念
基本概念，把一个表，从逻辑上分成多个区域，便于存储数据。
采用分区的前提：数据量非常大。</p>

<p>比如一个用户表，想分成4个区域，如何分呢？
用户的id  1   到1000  分到  东区
用户的id  1001   到2000  分到 南区
用户的id  2001   到3000  分到 西区
用户的id  大于3001   的 分到 北区</p>

<p>2、创建表分区的语法：
create  table user (
    //创建表的语句
)engine myisam charset utf8
partition by 分区类型（分区的关键字）(
    //分区的项
);
比如前面规划的案例：
create table user(
    id int,
    name varchar(32)
)</p>

<p>3、分区的类型
list :条件值为一个数据列表。 
通过预定义的列表的值来对数据进行分割
例子：假如你创建一个如下的一个表，该表保存有全国20家分公司的职员记录，这20家分公司的编号从1到20.而这20家分公司分布在全国4个区域，如下表所示：
职员表：
id  name   store_id(分公司的id) 
北部    1,4,5,6,17,18 
南部    2,7,9,10,11,13 
东部    3,12,19,20 
西部    8,14,15,16 
create table p_list( 
    id int, 
    name varchar(32), 
    store_id int 
)partition by list (store_id)( 
    partition p_north values in (1,4,5,6,17,18), 
    partition p_east values in(2,7,9,10,11,13), 
    partition p_south values in(3,12,19,20), 
    partition p_west values in(8,14,15,16) 
); 
测试是否用到了分区：
explain partitions select * from p_list where store_id=20\G
注意：在使用分区时，where后面的字段必须是分区字段，才能使用到分区。</p>

<p>Range（范围） 
这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区
create table p_range( 
    id int, 
    name varchar(32), 
    birthday date 
)partition by range (month(birthday))( 
    partition p_1 values less than (3), 
    partition p_2 values less than(6), 
    partition p_3 values less than(9), 
    partition p_4 values less than MAXVALUE 
); 
less than   小于等于； 
MAXVALUE可能的最大值 
4、分区表的限制；
只能对数据表的整型列进行分区，或者数据列可以通过分区函数转化成整型列
最大分区数目不能超过1024 
如果含有唯一索引或者主键，则分区列必须包含在所有的唯一索引或者主键在内</p>

<p>不支持外键
 不支持全文索引（fulltext）
按日期进行分区很非常适合，因为很多日期函数可以用。但是对于字符串来说合适的分区函数不太多 </p>

<p>八、列类型的选择 
1、在精度要求高的应用中，建议使用定点数来存储数值，以保证结果的准确性。 
要用decimal不要使用float
mysql&gt; create table t1(price float(9,2),dprice decimal(9,2));
mysql&gt; insert into t1 values(1234567.55,1234567.55); </p>

<p>2、录入手机号带来的问题， 
使用char(11)会占用较多的字节，gbk占用2字节<em>11，utf-8占用3</em>11， 
可以使用bigint,宽度是20，只占用8个字节。 
3、 ip地址也可以采用int整型。
使用函数进行转换：
inet_aton()：把ip地址转换成整数 
inet_ntoa();把整数转换成ip地址。 
IPv4存储为int型 
PHP：ip2long(),long2ip()
MySQL: inet_aton(), inet_ntoa();
4、根据需求选择最小整数类型。比如用户在线状态：离线，在线，离开，忙碌，隐式等，可以采用0,1,2,3,来表示。 
5、避免字段内容为null，原因：null不利于索引，要用特殊的字节来标注，在磁盘上占据的空间其实更大。 
NULL的判断只能用is null,is not null 
NULL 影响查询速度,一般避免使值为NULL 
mysql&gt; create table t3(name char(1) not null default '')engine myisam; 
Query OK, 0 rows affected (0.01 sec) </p>

<p>mysql&gt; create table t4(name char(1))engine myisam; 
Query OK, 0 rows affected (0.01 sec) </p>

<p>为大型网站提速--memcached缓存技术
目录
一、memcache 的介绍    1
1、memcached基本概念   1
2、基本原理    2
3、与mysql 进行比较   2
二、memcache的安装 3
三、客户端操作memcache   5
1、设置数据    7
2、删除数据    9
3、其他命令    9
4、状态命令： 10
5、缓存时间的设置的讨论  10
四、php操作 memcache    11
1、先安装memcache的扩展，让php支持。    11
2、入门案例： 12
五、php数据类型存储memcache探讨   13
六、案例操作  15
七、案例扩展，   16
八、memcache在tp框架里面使用   18
九、memcache的分布式存储    19
1、session数据入memcache的问题：    19
2、分布式系统具体的配置  21
十、其他事项  22
1、memcache适合于存储哪些数据 22
2、memcache的安全性    23
3、数据过期的问题   23
4、数据存储空间满了，还能否存储数据呢？  23
5、如果需要设置许多缓存项时，失效时间最好不要设置为相同的。    24</p>

<p>一、memcache 的介绍
1、memcached基本概念
（1）Memcached是danga的一个项目，最早是LiveJournal 服务的，最初为了加速 LiveJournal 访问速度而开发的，后来被很多大型的网站采用。 官方网站: <a href="http://www.danga.com">www.danga.com</a>  和 memcached.org 
（2）Memcached是一个高性能的分布式的内存对象缓存系统，目前全世界不少人使用这个缓存项目来构建自己大负载的网站，来分担数据库的压力，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。
2、基本原理</p>

<p>3、与mysql 进行比较
（1）与mysql一样，是一个c/s架构的软件。
（2）mysql里面的数据，是存储到磁盘里面的，memcache里面的数据是存储到内存里面的，一旦断电，服务器重启，则会丢失数据。
（3）要使用mysql则先要创建数据库，再创建表，以及表结构。在memcache里面数据的存储是键值对。可以理解成两列的表， key与value
name   小刚
age     12
email    <a href="mailto:xiaogagn@sohu.com">xiaogagn@sohu.com</a>
二、memcache的安装
方式一：直接使用，无需安装，（在开发时推荐使用）</p>

<p>（1）把软件拷贝到指定位置，一般和其他的安装软件（比如apache等）在同级目录下面，主要是便于管理。</p>

<p>（2）以cmd的方式，运行memcache</p>

<p>启动后，该窗口不要关闭，一旦关闭，则服务就停止了。</p>

<p>方式二：把 memcahce安装成window的一个服务，（在生产环境中推荐使用）
通过查看memcached 的帮助。</p>

<p>注意：在把 memcache安装成window的一个服务时，要以管理员的方式启动cmd.</p>

<p>查看服务是否安装成功：</p>

<p>安装可能失败的原因： 
（1） 如果你是用win7,win8系统，他对安全性要求高，因此，需要大家使用管理员的身份来安装和启动. 具体是 程序开始===&gt;所有程序==》附件==》cmd(单击右键，选择以管理员的身份来执行) 
（2）存放memcache.exe 目录不要有中文或者特殊字符
（3） 安装成功，但是启动会报告一个错误信息，提示缺少xx.dll ，你可以从别的机器拷贝该dll文件，然后放入到system32下即可. 
（4）如果上面三个方法都不可以，你可以直接这样启动mem 
cmd&gt;memcached.exe  -p  端口 【这种方式不能关闭窗口 </p>

<p>三、客户端操作memcache
使用，telnet连接memcache服务器端。
memcache的默认端口号是11211.
语法：telnet    ip地址   端口号</p>

<p>注意：telnet客户端无法使用的解决方案：</p>

<p>1、设置数据
（1）添加数据，
语法：add  key  是否压缩（0|1）  缓存时间  数据的长度
key ：键的名称
是否压缩：0表示不压缩，1表示要压缩，压缩的目的让数据变小，存储更多的数据。
缓存时间：失效时间，表示过了该时间数据就失效。
数据的长度：单位是字节，</p>

<p>注意：在使用add添加数据时，如果该键已经存在，则添加失败，不会覆盖。</p>

<p>（2）修改数据
replace key  0|1  缓存时间  数据的长度
注意：如果键不存在，则修改失败。</p>

<p>（3）设置数据
set key  0|1  缓存时间  数据长度
如果键已经存在，则是修改，如果键不存在，则是添加。</p>

<p>2、删除数据
语法：delete key</p>

<p>flush_all 是删除所有的缓存项</p>

<p>3、其他命令
incr  增加指定的值
语法：incr key number</p>

<p>decr  减少指定的值</p>

<p>比如有1000件商品，需要在60秒内抢购。
一开始就设置number的值为1000   ，当用户抢购时执行decr number ,如果执行后返回的值大于0则说明抢购成功，
4、状态命令：
stats </p>

<p>通过查看状态的参数，主要是计算命中率，
get_hits/cmd_get  ====得出一个命中率，命中率越高越好，如果命中率比较低，则需要调整缓存项。</p>

<p>5、缓存时间的设置的讨论
在设置缓存时间有两种设置方式：
（1）使用秒数（时间间隔）&lt;=2592000
（1）使用到期的时间戳  该时间戳必须要大于当前的时间戳才有效。
在设置时，设置的参数都是整数，如何区分是时间戳还是时间间隔呢？
在使用时间间隔设置缓存时间时，有一个限制的，不能超过30天，30<em>24</em>3600秒2592000
比如如果要把一个缓存项失效时间设置为2个月如何设置呢？
time()+30<em>24</em>3600<em>2
比如要把一个缓存项失效时间设置为10天如何设置？
有两种设置方案：
使用时间间隔：  10</em>24<em>3600
使用时间戳： time()+10</em>24*3600
比如如果一个缓存项失效时间设置为123489,该值是时间戳还是时间间隔。
如果该值小于等于2592000则是时间间隔，如果大于该值是时间戳，</p>

<p>注意：如果缓存时间设置为0，表明此数据永不过期
四、php操作 memcache
1、先安装memcache的扩展，让php支持。
（1）准备php支持的扩展文件，要注意要和php的版本对应。</p>

<p>（2）把扩展文件拷贝到php的安装目录下面的ext目录里面。</p>

<p>（3）打开php.ini的配置文件，引入扩展。</p>

<p>（4）要重启apache
（5）使用phpinfo 函数测试是否引入成功。</p>

<p>2、入门案例：</p>

<p>五、php数据类型存储memcache探讨
标量类型：整型   浮动型  布尔  字符串</p>

<p>说明标量类型是可以存储到memcache 里面的，都是以字符串的形式存储的，最后输出也变成了字符串。
非标量类型的存储：数组  对象  null  资源</p>

<p>取出数据的代码：</p>

<p>数组 对象 资源  null在 memcache里面存储的形式。</p>

<p>说明：数组 对象 资源 是以序列化之后的结果存储到memcache里面的。
但是在取出数据时，又自动反序列化之后显示的。
序列化与反序列化的过程是由memcache的客户端完成的，无需我们自己干预。
说明则memcache里面存储的数据，是以字符串的形式来存储的。
注意：不能把资源类型存储到memcache里面，因为在取出资源类型时，把资源类型变成了整型。在实际应用中，存储数组的情况居多。
六、案例操作
想把一个sql语句的执行结果，给缓存到memcache里面。
要注意说明的，sql语句执行的结果数据要小于1MB。
在mecache 里面，键与值是有要求的，
键的长度要小于250字节。
数据值的大小要小于1MB。</p>

<p>七、案例扩展，
把新闻内容存储到memcache里面。
新闻列表页面newslist.php</p>

<p>新闻详情页面newsinfo.php</p>

<p>思考：如果新闻内容修改了如何办？修改完成新闻后要清空缓存即可。
八、memcache在tp框架里面使用
分两步：
（1）初始化memcache
S(array(
    ‘type’=&gt;’memcache’,
    ‘host’=&gt;’ip地址’,
    ‘port’=&gt;端口号
));
（2）具体的操作
获取数据；
$data = S(key);
设置数据：
S(key,value,失效时间);
清空数据：
S(key,null)</p>

<p>九、memcache的分布式存储
1、session数据入memcache的问题：
应用图示：</p>

<p>具体的配置：
打开php.ini 配置文件：</p>

<p>可以使用函数ini_set()函数改变php.ini 的配置，只对当前页面有效。
ini_set(“session.save_handler”,’memcache’);
ini_set(‘session.save_path’,’tcp://ip地址1:端口,tcp://ip地址2:端口’)</p>

<p>注意：使用session的方式和以前是一样的。
session信息存储到memcache里面是以sessionid为键的，失效时间与session相同的。</p>

<p>2、分布式系统具体的配置
注意两点：
（1）要实现分布式配置需要两台以上memcache服务器（2）使用一个算法，该算法决定数据向哪台服务器存储。</p>

<p>（2）配置实现：
设置数据
取出数据：</p>

<p>注意：在设置数据与取出数据是，memcache服务器添加顺序与个数要一致。原因是使用的算法是取模算法，
在设置数据或取出数据时，根据键名转换成一个数字与服务器的个数进行取模。取模的结果就决定向哪台服务器存储数据。
注意：memcache服务器的算法是取模算法，是内置的，我们自己无需干预。
十、其他事项
1、memcache适合于存储哪些数据
（1）安全性不是很高的数据，丢失无所谓的数据，因为memcache服务器，一旦重启或关机，则会丢失所有的数据。
（2）查询比较频繁的数据，比如热点新闻，等等。
（3）更新比较频繁的数据，比如用户的在线状态。
（4）一个键值，数据量不要很大，要小于1MB的数据。
2、memcache的安全性
memcache没有任何的安全认证（比如用户名与密码），因为是主要做缓存使用，不是做数据存储使用的。
-l   监听的ip地址，启动后，只能监听该网卡（ip地址）进来的请求。
可以把memcache服务器放入到内网中，与互联网隔离，让其他外网用户无法访问。 </p>

<p>3、数据过期的问题
在memcache里面数据过期后，不会自动删除，当get时，发现过期后，才删除该数据。
• Lazy Expiration
memcached内部不会监视记录是否过期，而是在get时查看记录的时间戳，检查记录是否过
期。这种技术被称为lazy（惰性）expiration。
因此，memcached不会在过期监视上耗费CPU时间。</p>

<p>4、数据存储空间满了，还能否存储数据呢？
• LRU
memcached会优先使用已超时的记录的空间，但即使如此，也会发生追加新记录时空间不
足的情况，此时就要使用名为 Least Recently Used（LRU）机制来分配空间。
顾名思义，这是删除“最近最少使用”的记录的机制。因此，当memcached的内存空间不足时
（无法从slab class 获取到新的空间时），就从最近未被使用的记录中搜索，并将其空
间分配给新的记录。从缓存的实用角度来看，该模型十分理想</p>

<p>5、如果需要设置许多缓存项时，失效时间最好不要设置为相同的。
主要目的：防止缓存雪崩现象。</p>

<p>redis的操作
目录
redis的操作  1
一、NOSQL 1
1、出现背景： 1
2、特点  1
3、优缺点：    1
4、NOSQL使用场景   1
5、常见nosql产品   2
二、redis介绍   2
1、概述  2
2、与memcache比较说明 2
三、安装启动  3
1、安装软件    3
2、启动软件    4
四、数据类型讲解:   4
1、字符串类型 4
2、hashes类型及操作   7
3、lists类型 9
4、集合的操作 13
5、有序集合    17
五、服务器相关的命令  17
六、安全认证  21
七、php当客户端操作redis    22
1、安装扩展    22
2、入门使用    24
八、高级案例  24
九、持久化机制   25
1、snapshotting(快照)默认方式    26
2、持久化机制之aof方式 27</p>

<p>一、NOSQL
NoSQL ,（Not Only SQL），泛指非关系型数据库。 
NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。
1、出现背景： 
随着互联网web2.0网站的兴起，传统的关系型数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点，得到了非常迅速的发展。
2、特点
NoSQL 通常是以key-value形式存储， 
不支持SQL语句， 
没有表结构 
3、优缺点： 
优点：
大数据量的扩展（高并发读写的性能 分布式存储） 
配置简单 
灵活、高效的操作与数据模型 
低廉的成本 
不足之处： 
没有统一的标准 
没有正式的官方支持 
各种产品还不算成熟
4、NOSQL使用场景
（1）对数据高并发读写
（2）对海量数据的高效率存储和访问
（3）对数据的高可扩展性和高可用性。</p>

<p>5、常见nosql产品</p>

<p>二、redis介绍
1、概述
（1）redis是一个开源的，先进的key-value存储。它通常被称为数据结构服务器，
（2）它支持存储的value类型很多，包括string(字符串)、list(链表)、set(集合)、Zset(有序集合)。 
（3）为了保证效率数据都是缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。 
（4）提供的API语言包括：C、C++、C#、Clojure     Common Lisp  Erlang  Haskell Java Javascript Lua Objective-C Perl PHP Python Ruby Scala Go Tcl </p>

<p>2、与memcache比较说明
redis与memcache比较
（1）数据类型:memcache支持的数据类型就是字符串，redis支持的数据类型有字符串，哈希，链表，集合，有序集合。
（2）持久化：memcache数据是存储到内存里面，一旦断电，或重启，则数据丢失。redis数据也是存储到内存里面的，但是可以持久化，周期性的把数据给保存到硬盘里面，导致重启，或断电不会丢失数据。
（3）数据量：memcahce一个键存储的数据最大是1M,而redis的一个键值，存储的最大数据量是1G的数据量。
三、安装启动
1、安装软件
（1）下载软件，上传到linux服务器。</p>

<p>（2）解压软件</p>

<p>（3）进入解压后的目录，</p>

<p>（4）直接执行make
（5）执行安装，在安装时指定安装的目录
make PREFIX=/usr/local/redis install </p>

<p>安装成功后， 在安装的目录下面生成一个bin目录，该目录下面有5个文件。</p>

<p>redis-benchmark 是性能测试工具。
redis-check-aof和redis-check-dump文件是日志检测工具
redis-cli是客户端连接程序
redis-server是服务器端启动程序
（6）在解压的目录里面复制配置文件到安装目录里面。</p>

<p>2、启动软件
（1）使用vim打开配置文件,进行配置，让redis服务在后台执行。</p>

<p>（2）执行启动
语法：redis-server 指定配置文件</p>

<p>查看是否启动成功：
redis的默认启动端口是： 6379，</p>

<p>关闭服务：pkill redis-server</p>

<p>（3）客户端连接 redis服务器
语法：redis-cli  -h ip地址 –p端口
如果是本机，端口默认，则直接执行redis-cli即可。</p>

<p>四、数据类型讲解:
它支持存储的value类型很多，包括string(字符串)、list(链表)、set(集合)、Zset(有序集合)。
1、字符串类型
String是最简单的类型，一个 key对应一个Value，</p>

<p>set
设置键值
语法  set  key   value</p>

<p>注意：如果key存在，则是修改，如果key 不存在则是添加。</p>

<p>get
获取键值
语法：get key</p>

<p>setnx 
设置键值，在设置时，要判断该键是否存在，如果存在，则设置失败。
语法：setnx key value</p>

<p>setex 
设置键值,在设置键值时，指定该键的有效期，单位是秒。
语法：setex  key 有效期  value</p>

<p>mset 
设置键值，可以一次性设置多个键值。
语法：mset key1 value1  key2 value2……..</p>

<p>mget 
获取键值，可以一次性获取多个键值。
语法：mget key1 key2……..</p>

<p>incr(incrby)
自增操作，加1操作，如果该键不存在，则返回1.
语法；incr  key</p>

<p>incrby
加法操作，可以指定相加的值
语法： incrby key number</p>

<p>2、hashes类型及操作 
Redis hash是一个string类型的field和value的映射表。它的添加、删除操作都是0（1）（平均）。hash特别适合用于存储对象。相较于将对象的每个字段存成单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。 </p>

<p>hset 
设置哈希的值：
语法： hset   key   field  value</p>

<p>hget 
获取哈希里面的field的值
语法： hget   key   field</p>

<p>hmset 
设置哈希的值,可以一次性设置多个field
语法：hmset key field1 value1  field2 value2……</p>

<p>hmget 
获取哈希的里面多个field的值
语法：hmget key  field1 feild2 ….</p>

<p>hlen 
计算哈希里面field的个数
语法；hlen key</p>

<p>hdel 
删除哈希里面指定field
语法：hdel key  field</p>

<p>hgetall 
返回哈希里面所有的field与value
语法：hgetall key</p>

<p>3、lists类型 
list是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等，操作中key 理解为链表的名字
可以把链表理解成一个容器，存储一些字符串元素。
可以模拟栈的操作：</p>

<p>可以模拟队列的操作。</p>

<p>注意：存在链表中的元素是有顺序的，0表示是头部的元素，依次类推。链表中就可以存在重复的元素。</p>

<p>lpush 
从头部向链表里面添加元素
语法：lpush  key  value</p>

<p>lrange 
是获取链表里面的元素
语法：lrange key 开始下标  结束下标
如果开始下标为0则是从头部开始取，如果结束下标为-1则是到链表的尾部结束。</p>

<p>rpush 
从尾部向链表里面添加元素
语法：lpush  key  value</p>

<p>lrem 
删除链表里面的元素
语法：lrem key 删除个数 指定的元素</p>

<p>ltrim 
保留指定范围的元素
语法：ltrim  key 开始下标  结束下标</p>

<p>lpop 
删除链表头部的一个元素
语法：lpop key</p>

<p>lindex 
返回链表中指定下标的元素。
语法：lindex key 下标</p>

<p>Lsize:计算链条里键的个数。
4、集合的操作
sets类型及操作 
set是集合，它是string类型的无序集合。set是通过hash table实现的、添加、删除和查找的复杂度都是0(1)。对集合我们可以取并集、交集、差集。通过这些操作我们可以实现sns中的好友推荐和blog的tag功能。</p>

<p>集合的概念和数学里面的集合 的概念类似。
集合的特点：集合里面的元素具有唯一性，无序性。</p>

<p>sadd 
向集合里面里面添加元素
语法： sadd  key</p>

<p>smembers 
返回集合里面的元素
语法：smembers key</p>

<p>srem 
删除集合中指定 的元素
语法：srem key 指定的元素</p>

<p>sdiff 
返回集合中的差集，在集合1中出现过，不在集合2中出现的元素。</p>

<p>sinter
返回两个集合的交集。
语法：sinter 集合1  集合2 </p>

<p>sunion 
返回集合的并集，多个集合合并，去掉重复的元素。
语法：sunion 集合1 集合2</p>

<p>scard 
返回集合中元素的个数</p>

<p>sismember 
判断某个元素是否在该集合里面。
语法：sismember 集合名称  指定的元素。</p>

<p>5、有序集合
给集合中的元素添加顺序编号（下标）</p>

<p>五、服务器相关的命令
keys
获取当前的键，可以使用通配符。* ?</p>

<p>exists
判断key是否存在，
语法：exists key</p>

<p>del
删除指定的key
语法：del key</p>

<p>expire
给指定的键设置失效时间
语法：expire key 失效时间（秒）</p>

<p>ttl 
返回该键的未失效时间。</p>

<p>type
返回key的类型，</p>

<p>select
选择数据库，在redis 里面，默认有16个数据库（0-15），默认是进入的0号数据库。
语法：select 数据库的编号（0-15）</p>

<p>dbsize 
查看当前数据里面的键的数量</p>

<p>flushdb 
清空当前数据库里面的键。</p>

<p>flushall 
清空所有数据库里面的键</p>

<p>六、安全认证
设置客户端连接后进行任何其他操作前需要使用的密码。 
注意：因为 redis速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150k次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解
配置方法：
使用vi打开redis的配置文件。</p>

<p>注意：设置完成密码后，要关闭redis服务，重新开启。</p>

<p>如果设置了密码，没有经过授权，则可以连接，但无法操作。
认证方式，有两种，可以在登录时授权，也可以在登录后授权。</p>

<p>方式一：在客户端登录redis服务的时候，
语法：redis-cli    –a 密码</p>

<p>方式二：客户端登录服务器后，执行auth可以授权。
语法：auth 密码</p>

<p>七、php当客户端操作redis
1、安装扩展
（1）准备扩展，要注意安装的扩展要和php的版本对应。要安装不带nts的。</p>

<p>（2）要把对应扩展的两个文件，拷到php的安装目录ext目录下面。
 注意：如果你的php版本是5.3系列的直接拷贝一个文件即可（php_redis.dll）。 
（3）打开php.ini的配置文件，要引入扩展
注意：extension=php_igbinary.dll一定要放在extension=php_redis.dll的前面，否则此扩展不会生效。</p>

<p>（4）重启apache，使用phpinfo函数进行测试</p>

<p>2、入门使用</p>

<p>八、高级案例
完全是redis来做，
1、用户的注册</p>

<p>2、用户的显示</p>

<p>九、持久化机制
redis是一个支持持久化的内存数据库，也就是说redis需要经常将内存中的数据同步到硬盘来保证持久化。 
redis支持两种持久化方式： 
（1）snapshotting(快照)默认方式 
（2）append-only file( 缩写aof)的方式
1、snapshotting(快照)默认方式
快照是默认的持久化方式。这种方式是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb.可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key修改就自动做快照。</p>

<p>具体的配置：</p>

<p>假如有1个键发生了更新。
0       60       60      60     60     60  60  300      900</p>

<p>可以手动发起快照，有两种操作方法
方法一：未登录时，
语法：./redis-cli  -a  密码  -h ip地址   bgsave  手动发起一次快照保存操作</p>

<p>方法二：已经登录
语法：直接执行bgsave</p>

<p>2、持久化机制之aof方式
由于快照方式是在一定间隔做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。 
aof比快照方式有更好的持久化性，是由于在使用aof时，redis会将每一个收到的写命令都通过write函数追加到文件中，当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容
具体的配置：
appendonly   yes    //启用 aof 持久化方式
appendfilename   appendonly.aof   //保存命令的文件</p>

<h1>
<a id="appendfsync-always---每次收到写命令就立即强制写入磁盘最慢的但是保证完全的持久化不推荐使用" class="anchor" href="#appendfsync-always---%E6%AF%8F%E6%AC%A1%E6%94%B6%E5%88%B0%E5%86%99%E5%91%BD%E4%BB%A4%E5%B0%B1%E7%AB%8B%E5%8D%B3%E5%BC%BA%E5%88%B6%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E6%9C%80%E6%85%A2%E7%9A%84%E4%BD%86%E6%98%AF%E4%BF%9D%E8%AF%81%E5%AE%8C%E5%85%A8%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>appendfsync always   //每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用</h1>

<p>appendfsync everysec   //每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐</p>

<h1>
<a id="appendfsync-no---完全依赖-os性能最好持久化没保证" class="anchor" href="#appendfsync-no---%E5%AE%8C%E5%85%A8%E4%BE%9D%E8%B5%96-os%E6%80%A7%E8%83%BD%E6%9C%80%E5%A5%BD%E6%8C%81%E4%B9%85%E5%8C%96%E6%B2%A1%E4%BF%9D%E8%AF%81" aria-hidden="true"><span class="octicon octicon-link"></span></a>appendfsync no   //完全依赖 os，性能最好,持久化没保证</h1>

<p>aof文件的重写，把备份文件里面的命令操作重新整理成命令，
比如incr number执行10次后，结果为10，默认是保存了10次incr number命令，aof执行重写后，就直接把10次incr number变成set number  10,会 减少aof 的文件的容量，提高效率。
手动重写：bgrewriteaof 命令，
可以在未登录执行，也可以在登录后执行。</p>
        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/tjloved" class="avatar"><img src="https://avatars1.githubusercontent.com/u/15959225?v=3&amp;s=60" width="48" height="48"></a> <a href="https://github.com/tjloved">tjloved</a> maintains <a href="https://github.com/tjloved/tjloved.githup.io">我的博客</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <a href="https://github.com/tjloved/tjloved.githup.io/tarball/master" class="tar">tar</a><a href="https://github.com/tjloved/tjloved.githup.io/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
    <p class="name"></p>
  </div>

  
</body>
</html>
